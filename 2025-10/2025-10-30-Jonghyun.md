# Replica

Created: October 23, 2025 7:44 AM
Status: Not started
발표일자: October 29, 2025

1. Load Balancing
2. High Availability
3. Backup / Data protection

### Streaming Replic (물리적 복제)

장점

1. 성능이 매우 빠르다. 
2. 설정이 간단하다.
3. 전체가 완벽하게 동기화 된다.
4. 복제 지연이 거의 없다.

단점

1. 읽기 전용이다.
2. 특정 테이블만 복제는 불가능
3. 복제본에서 추가 인덱스등 쓰기 불가.

### Logical Replication (논리적 복제)

장점

1. 특정 테이블만 복제가능
2. 쓰기 가능
3. 복제본에서 추가 인덱스나 테이블 생성가능

단점

1. 느림 (SQL 레벨 처리요청이여서)
2. 설정 복잡
3. 충돌 처리시 직접 관리 필요.

# Oracle Write Replica

### Data Guard - Logical Standby

**개요**

- 논리적 복제 방식의 Data Guard
- SQL Apply를 사용한 복제

**작동 방식**

`Primary DB → Redo Log 전송 → SQL 변환 → Logical Standby DB
(LogMiner를 통한 SQL 재생)`

**특징**

- Redo Log를 SQL 문으로 변환하여 적용
- Standby가 읽기/쓰기 가능 (추가 테이블 생성 가능)
- 선택적 테이블 복제 가능

**장점**

- Standby에서 읽기/쓰기 모두 가능
- 보고서 생성, 추가 인덱스 생성 가능
- 데이터 변환 가능

**단점**

- Physical Standby보다 느림
- 일부 데이터 타입 미지원 (LOB, Collection 등)
- 복잡한 관리
- 최근에는 거의 사용 안함 (GoldenGate 선호)

---

### Oracle GoldenGate

**개요**

- 실시간 데이터 복제 및 통합 플랫폼
- 가장 유연하고 강력한 논리적 복제 솔루션

**작동 방식**

`Source DB → Extract → Trail Files → Replicat → Target DB
(Transaction 로그 기반 CDC)`

**특징**

- 이기종 데이터베이스 간 복제 가능
- 실시간 Change Data Capture (CDC)
- 양방향 복제 지원
- 데이터 변환 및 필터링 강력

**장점**

- 최고의 유연성 (Oracle ↔ MySQL, PostgreSQL 등)
- 선택적 테이블 복제
- 실시간 데이터 통합
- 양방향 Active-Active 구성 가능
- Zero Downtime Migration 지원
- 데이터 변환 및 매핑 가능

**단점**

- 별도 라이선스 필요 (고가)
- 복잡한 설정 및 관리
- 높은 학습 곡선
- 추가 리소스 필요 (Extract/Replicat 프로세스)

**사용 사례**

- 이기종 DB 간 데이터 동기화
- 실시간 데이터 웨어하우스
- 클라우드 마이그레이션
- Active-Active 구성

---

### Write replica가 필요한 경우 - 지원님 질문

## 📊 아키텍처 비교 개요

### 1️⃣ 전통적 방식 (Write Replica 없음)

```
                    Primary DB
                    (Read/Write)
                         |
        +----------------+----------------+
        |                |                |
   Read Replica    Read Replica    Read Replica
   (Read Only)     (Read Only)     (Read Only)

```

### 2️⃣ Multi-Write 방식 (Write Replica 있음)

```
    Write Node 1        Write Node 2        Write Node 3
    (Read/Write)        (Read/Write)        (Read/Write)
         |                    |                    |
         +--------------------+--------------------+
                    양방향 복제

```

---

## 🌍 시나리오 1: 글로벌 전자상거래 서비스

### 배경

- 한국, 일본, 미국에 사용자 분산
- 주문 처리, 재고 관리, 상품 리뷰 등

---

### ❌ Write Replica 없을 때

**아키텍처:**

```
서울에 Primary DB 위치

한국 사용자 → 서울 Primary (10ms)
일본 사용자 → 서울 Primary (50ms)
미국 사용자 → 서울 Primary (150ms)

```

**실제 시나리오:**

### 상황 1: 미국 사용자가 주문

```
시간 경과:
0ms   : 미국 사용자 "구매" 버튼 클릭
150ms : 서울 Primary에 INSERT 요청 도착
160ms : DB 쓰기 완료
310ms : 미국 사용자에게 응답 도착

```

→ **총 310ms 소요** (사용자 체감 느림)

### 상황 2: Primary DB 서버 장애

```
09:00 - 서울 Primary 장애 발생
09:00 - 모든 지역 쓰기 불가능 ❌
09:05 - Read Replica를 Primary로 승격 시작
09:10 - 승격 완료, 쓰기 재개

```

→ **10분간 전체 서비스 쓰기 중단**

### 상황 3: 네트워크 문제

```
한국-미국 해저케이블 장애
→ 미국 사용자 주문 불가 ❌
→ 네트워크 복구까지 서비스 중단

```

**주요 문제점:**

- 😢 지리적으로 먼 사용자는 느린 쓰기 응답
- 😢 단일 장애점 (Single Point of Failure)
- 😢 네트워크 문제에 취약
- 😢 Primary 부하 집중 (모든 쓰기)

---

### ✅ Write Replica 있을 때

**아키텍처:**

```
한국 Write Node ← 한국 사용자 (10ms)
일본 Write Node ← 일본 사용자 (10ms)
미국 Write Node ← 미국 사용자 (10ms)
     ↓↓↓ 양방향 복제 ↓↓↓

```

**실제 시나리오:**

### 상황 1: 미국 사용자가 주문

```
시간 경과:
0ms   : 미국 사용자 "구매" 버튼 클릭
10ms  : 미국 로컬 DB에 INSERT
15ms  : 미국 사용자에게 응답 도착
백그라운드: 한국, 일본 노드로 복제 (비동기)

```

→ **총 15ms 소요** (20배 빠름! 🚀)

### 상황 2: Primary DB 서버 장애

```
09:00 - 서울 Write Node 장애 발생
09:00 - 일본/미국 노드는 정상 작동 ✅
09:00 - 한국 사용자 → 일본 노드로 자동 라우팅

```

→ **0초 다운타임** (무중단!)

### 상황 3: 네트워크 문제

```
한국-미국 해저케이블 장애
→ 각 지역은 로컬 노드에서 계속 쓰기 ✅
→ 네트워크 복구 시 자동 동기화

```

**주요 장점:**

- 😊 모든 사용자가 빠른 쓰기 응답 (로컬)
- 😊 고가용성 (한 노드 장애해도 서비스 정상)
- 😊 네트워크 문제에 강함
- 😊 쓰기 부하 분산

**주의사항:**

```
⚠️ 충돌 가능성:
한국: 상품 A 재고 10 → 5로 변경
미국: 상품 A 재고 10 → 3으로 변경
→ 충돌 해결 필요 (Last Write Wins 등)

```

---

## 🎮 시나리오 2: 실시간 게임 서비스

### 배경

- MMORPG 게임
- 플레이어 위치, 아이템 획득, 전투 기록

---

### ❌ Write Replica 없을 때

**구조:**

```
중앙 Primary DB (서울)

```

**게임 플레이 시나리오:**

```
미국 플레이어가 아이템 습득:

0ms   : 플레이어가 아이템 클릭
150ms : 서울 서버에 UPDATE 요청
160ms : DB 쓰기 완료
310ms : 플레이어에게 "아이템 획득" 표시

```

**플레이어 경험:**

- 아이템 클릭 → 0.3초 후 인벤토리 업데이트
- 버벅거리는 느낌
- "렉 걸린다" 불만

**동접자 증가 시:**

```
Primary DB 부하:
- 평상시: CPU 40%
- 이벤트 시: CPU 95% → 응답 지연 발생
- 모든 지역 플레이어 영향 받음

```

---

### ✅ Write Replica 있을 때

**구조:**

```
한국 서버 + DB ← 한국 플레이어
일본 서버 + DB ← 일본 플레이어
미국 서버 + DB ← 미국 플레이어

```

**게임 플레이 시나리오:**

```
미국 플레이어가 아이템 습득:

0ms  : 플레이어가 아이템 클릭
5ms  : 미국 로컬 DB에 UPDATE
10ms : 플레이어에게 "아이템 획득" 즉시 표시
백그라운드: 다른 지역 복제

```

**플레이어 경험:**

- 아이템 클릭 → 즉시 인벤토리 업데이트
- 부드러운 게임 플레이
- "렉 없음" 만족

**동접자 증가 시:**

```
각 지역 DB 독립 운영:
- 한국 이벤트 → 한국 DB만 부하 증가
- 일본/미국 플레이어는 영향 없음
- 부하 분산 효과

```

---

## 🏦 시나리오 3: 은행 멀티 지점 시스템

### 배경

- 전국 100개 지점
- 계좌 조회, 입출금, 송금

---

### ❌ Write Replica 없을 때

**구조:**

```
본사 중앙 DB
    ↓
모든 지점이 VPN으로 중앙 DB 접속

```

**실제 업무 시나리오:**

### 고객이 제주 지점에서 출금

```
제주 지점 → 서울 본사 DB (50ms)

```

**정상 상황:**

- 출금 처리 시간: 약 100ms
- 큰 문제 없음

**문제 상황 1: 본사 DB 장애**

```
10:00 - 본사 DB 서버 장애
10:00 - 전국 100개 지점 모두 업무 중단 ❌
10:30 - DB 복구 완료

```

→ **30분간 전국 은행 업무 마비**

**문제 상황 2: 네트워크 장애**

```
제주-서울 네트워크 단절
→ 제주 지점 업무 완전 중단 ❌
→ 고객 불만 폭발

```

---

### ✅ Write Replica 있을 때

**구조:**

```
각 지역별 Write Node:
- 서울 권역 DB
- 부산 권역 DB
- 제주 권역 DB
    ↓↓↓
  실시간 동기화

```

**실제 업무 시나리오:**

### 고객이 제주 지점에서 출금

```
제주 지점 → 제주 로컬 DB (5ms)
백그라운드: 서울/부산 DB로 복제

```

**정상 상황:**

- 출금 처리 시간: 약 10ms (10배 빠름)

**문제 상황 1: 서울 DB 장애**

```
10:00 - 서울 DB 서버 장애
10:00 - 서울 지점만 부산/제주 DB로 전환
10:00 - 부산/제주 지점은 정상 업무 ✅

```

→ **다른 지역 영향 없음, 서울도 즉시 전환**

**문제 상황 2: 네트워크 장애**

```
제주-본토 네트워크 단절
→ 제주는 로컬 DB로 계속 업무 ✅
→ 네트워크 복구 후 자동 동기화

```

**추가 장점:**

```
규정 준수:
- 제주 고객 데이터는 제주에 저장
- 지역별 데이터 주권 만족
- 백업도 지역별로 가능

```

---

## 📈 성능 지표 비교

### 쓰기 레이턴시 (지리적 거리별)

| 사용자 위치 | Write Replica 없음 | Write Replica 있음 | 개선율 |
| --- | --- | --- | --- |
| **로컬 (서울-서울)** | 10ms | 10ms | - |
| **인접 (서울-도쿄)** | 50ms | 10ms | **5배 빠름** |
| **중거리 (서울-싱가포르)** | 100ms | 10ms | **10배 빠름** |
| **장거리 (서울-미국)** | 150-200ms | 10ms | **15-20배 빠름** |
| **초장거리 (서울-유럽)** | 200-300ms | 10ms | **20-30배 빠름** |

---

### 가용성 비교

| 상황 | Write Replica 없음 | Write Replica 있음 |
| --- | --- | --- |
| **정상 운영** | 99.9% | 99.99% |
| **Primary 장애** | 전체 쓰기 중단 (5-10분) | 무중단 (0초) |
| **네트워크 파티션** | 격리된 지역 쓰기 불가 | 모든 지역 계속 쓰기 |
| **점진적 장애 확산** | 전체 영향 | 지역 격리 |
| **DR 복구 시간** | 5-10분 (수동 승격) | 즉시 (자동) |

---

### 부하 처리 능력

### 쓰기 처리량 (TPS - Transactions Per Second)

**Write Replica 없음:**

```
Primary DB 한계:
- 최대 10,000 TPS
- 10,000 TPS 초과 시 → 대기 시간 증가

```

**Write Replica 있음 (3개 노드):**

```
분산 처리:
- 각 노드 10,000 TPS
- 합계 30,000 TPS 처리 가능
- 3배 처리 능력 향상 🚀

```

---

## 💰 비용 비교

### 인프라 비용

**Write Replica 없음:**

```
Primary DB (대형):     $5,000/월
Read Replica x 3:      $3,000/월
총 비용:               $8,000/월

```

**Write Replica 있음:**

```
Write Node x 3 (중형): $9,000/월
복제 네트워크 비용:     $1,000/월
총 비용:              $10,000/월

```

→ **약 25% 비용 증가**, 하지만...

---

### 장애 비용 (다운타임)

**온라인 쇼핑몰 예시 (시간당 매출 1억원):**

**Write Replica 없음:**

```
연간 장애 예상:
- Primary 장애: 2회 x 10분 = 20분
- 네트워크 장애: 3회 x 5분 = 15분
- 총 다운타임: 35분/년

장애 손실:
- 35분 x (1억/60분) = 약 5,800만원/년

```

**Write Replica 있음:**

```
연간 장애 예상:
- 자동 전환으로 거의 0분
- 복잡성으로 인한 소규모 이슈: 5분

장애 손실:
- 5분 x (1억/60분) = 약 833만원/년

```

**실제 절감:**

```
손실 감소: 5,800만 - 833만 = 4,967만원/년
추가 인프라 비용: (10,000 - 8,000) x 12 = 24만원/년

순이익: 4,967만 - 24만 = 4,943만원/년 💰

```

---

## 🎯 결정 가이드

### ❌ Write Replica 필요 없음

**이런 경우:**

```
✓ 단일 지역 서비스 (한국만)
✓ 사용자 < 10만명
✓ 쓰기 부하 < 1,000 TPS
✓ 약간의 다운타임 허용 (연 99.9%)
✓ 데이터 일관성이 매우 중요 (금융 거래)
✓ 개발/운영 리소스 부족

```

**추천 아키텍처:**

```
Primary (1대) + Read Replica (2-3대) + Standby (1대)
→ 충분히 안정적이고 관리 쉬움

```

---

### ✅ Write Replica 필요함

**이런 경우:**

```
✓ 글로벌 서비스 (다중 대륙)
✓ 사용자 > 100만명
✓ 쓰기 부하 > 5,000 TPS
✓ 다운타임 허용 불가 (연 99.99%+)
✓ 낮은 레이턴시 필수 (< 50ms)
✓ 지역별 규정 준수 필요
✓ 충분한 개발/운영 리소스

```

**추천 아키텍처:**

```
Multi-Region Active-Active
→ 각 지역 Write Node + 충돌 해결 로직

```

---

## 🔧 실제 기업 사례

### Netflix (Write Replica 사용)

```
Before:
- 미국 중앙 DB
- 유럽/아시아 사용자 느림

After:
- 각 대륙별 Write Node
- 시청 기록 즉시 저장
- 추천 알고리즘 빠르게 반영

```

### Facebook (Write Replica 사용)

```
Before:
- 미국 Primary DB만 사용
- 글로벌 사용자 쓰기 지연

After:
- 각 대륙별 Write Node
- 포스트 즉시 게시
- 좋아요/댓글 즉시 반영

```

### 국내 은행 (Write Replica 미사용)

```
여전히 중앙 집중식:
- 데이터 일관성 최우선
- 규제 요구사항
- ACID 트랜잭션 필수
→ Write Replica 사용 안함

```

---

## 📊 최종 비교 요약

| 구분 | Write Replica 없음 | Write Replica 있음 |
| --- | --- | --- |
| **쓰기 레이턴시** | 지역별 차등 (10-300ms) | 모두 낮음 (10ms) |
| **가용성** | 99.9% | 99.99%+ |
| **쓰기 처리량** | 단일 노드 한계 | 노드 수만큼 증가 |
| **장애 영향** | 전체 서비스 | 지역 격리 |
| **복잡도** | 낮음 ⭐⭐ | 높음 ⭐⭐⭐⭐⭐ |
| **비용** | 낮음 💰💰 | 높음 💰💰💰💰 |
| **일관성** | 강한 일관성 | 최종 일관성 |
| **충돌 처리** | 필요 없음 | 필수 |
| **적합한 규모** | 중소형 | 대형 글로벌 |

---

## 💡 핵심 결론

### Write Replica 없음 = 단순하고 안정적

- 대부분의 서비스에 충분
- 관리 쉬움
- 강한 데이터 일관성

### Write Replica 있음 = 복잡하지만 강력

- 글로벌 서비스에 필수
- 최고의 성능과 가용성
- 복잡성과 비용 감수 필요

**결정 기준:**

```
지리적 분산 + 고가용성 + 낮은 레이턴시 요구
→ Write Replica 고려

그 외 대부분의 경우
→ Primary + Read Replica면 충분!

```



---

# 클로드 코드 스킬

# 개요

클로드 스킬은 클로드 코드에서 2025년 10월 중반쯤 업데이된 기능입니다. 엄청 굉장하다는 글들이 많이 올라오게 되어서 필수라고 느껴지게 되었습니다. 

자주 하는 반복, 자동화 등을 하나의 함수(?)처럼 커스텀하게 기능을 만들어 사용할 수있는 기능입니다. 이름처럼 딱 본인이 원하는 “스킬”을 만들수 있습니다. 

[이전의 경호님의 메모리 뱅크](https://www.notion.so/2-Cursor-Background-Agent-23ffd8bcf55880e9b673d60740ab705a?pvs=21)와 동작 원리는 같지만 사용하기 더 쉽고 고도화된 느낌이 였습니다.

- 메모리 뱅크와 유사하다고 생각하여 뭐가 다른지 물어 봤습니다.
    
    클로드의 최신 "스킬(Skill)" 기능은 단순히 '메모리 뱅크(memory bank)'를 통한 코드 작업을 넘어서 좀 더 강력한 **워크플로우 자동화와 재사용 가능한 전문성 패키지**라는 점에서 차별성이 있습니다.
    
    - **메모리 뱅크 방식**은 단순히 이전 대화나 프로젝트 내역, 아키텍처/패턴/작업 등의 정보(예: CLAUDE.md, 메모리 파일)를 기억해두고 필요할 때 참고하는 식으로 동작합니다. 프로젝트마다 초기화하거나 폴더 구조에 따라 참조가 다르며, 사용자가 명령어나 파일 추가로 계속 관리해야 하는, 말 그대로 '기록 저장소' 형태죠.
    - **클로드 스킬 기능**은 사용자가 특정 작업(문서 작성, 코드 생성, 데이터 분석, 사내 컨벤션 등)에 맞는 패키지를 폴더+MD로 등록해두면, 클로드가 *필요할 때 자동으로 해당 스킬을 로딩해 특화된 방식*으로 문제를 해결합니다. 예를 들어, 'Spring 테스트 코드 작성' 같은 회사/팀별 패턴, 프로세스, 도구 사용법 등을 한 번만 세팅하면, 대화나 세션이 바뀌어도 그 전문성을 바로 재사용하고, 폴더 내 스크립트/리소스/설명까지 연동됩니다.
    - **사용성 차이**
        - 메모리 뱅크: "이 코딩 패턴, 이 용어, 이런 명령어를 기억해줘" 수준의 수동적 사용
        - 스킬: "이런 역할/문서/프로세스에 대해 전문적으로 일관성 있게 자동화해줘" → 반복 설명이나 재훈련 필요 없음, **실제로 코드 생성·테스트·문서화까지 일원화된 도구처럼 작동**
        - 개인·팀·조직 차원에서 원하는 '능력'을 묶어서 관리 가능, 프로젝트·업무에 연결된 재사용과 확장성 극대화
    
    즉, **스킬은 '커스텀 에이전트화'와 '워크플로우 자동화'에 더 가까우며**, 메모리 뱅크는 개인화된 간이 참고 정보(설정, 용어, 과거 대화) 저장소에 가깝습니다. 본인이 느낀 "사용성 편해짐"이 바로 이 점에서 나오고, 반복 설명이나 재교육이 없어지는 효과가 큽니다.
    
    정리:
    
    - **스킬 = 회사/개인 업무 전문화 + 자동화 + 반복/확장 가능**
    - **메모리 뱅크 = 일반적인 대화 내역·설정·참고자료 저장소**
    
    둘 다 유용하지만, 반복 업무·코드 작업에선 스킬 방식이 훨씬 강력하고 생산성을 크게 올려줍니다.
    

# 🙇‍♂️ 소개

저는 이전까지 커서에 memory-bank를 만들어서 사용했었고 클로드 코드는 이번에 처음 사용 해봤습니다.

### 커서 vs 클로드 코드

⭐ 클로드 코드 승리

- 주변에서 클로드 코드가 커서보다 좋다고 말을 많이 했습니다. “그정인가? 커서로도 충분한데? 클로드 코드는 뭐 설정이 좀더 필요해서 귀찮다.” 라고 생각했던 제 자신을 반성합니다. 좋다는거는 빨리빨리 써야겠습니다. 클로드 코드가 더 똑똑하고 프롬프팅을 잘 알아듣네요.

### 클로드 코드 세팅

클로드 코드(Claude Code) 초기 세팅 가이드

## 1. 개발환경 준비

- Node.js와 npm 최신 버전 설치 (Node 18 이상 권장)
- Windows라면 WSL2 환경 추천
- Mac/Linux는 기본 터미널 사용

---

## 2. 클로드 코드 설치

`bashnpm install -g @anthropic-ai/claude-code`

---

## 3. 프로젝트 기본 셋업 및 CLAUDE.md 생성

```bash
cd /path/to/your/project   *# 작업 폴더로 이동*

claude                    *# 클로드 코드 실행*
```

- 실행 후 Claude 터미널에 **`/init`** 입력
    
    → 프로젝트 구조를 자동 분석해서 **`CLAUDE.md`** 생성
    
    → 개요/아키텍처/기술스택/코딩규칙 등 직접 추가 설정
    

## 4. 사용 팁

- “/help”로 명령어 전체 보기
- “이 프로젝트의 주요 아키텍처 설명해줘” 등 자연어로 바로 명령
- CLAUDE.md/설정파일 내용 변경 시에는 **`claude`** 재시작
- 본인만의 코딩 규칙, 개발 흐름을 CLAUDE.md에 추가!

# 🔧 작업

- 클로드 스킬은 PRO부터 사용할수 있습니다. (경호님 최고 👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍👍)
- 클로드 스킬을 사용하려면 해당 기능을 active시켜야합니다.

![image.png](attachment:b75a21f8-3f5e-4988-b78d-19bf520fd997:image.png)

![image.png](attachment:96334125-e2d4-48af-b30c-cd8e4860ece1:image.png)

- 이 화면을 보다시피 클로드에서 기본적으로 제공하는 스킬들이 있습니다. 문서작성, 디자인 작성 등등 많은 기능들이 있습니다. 원하는 기능을 active하면 클로드에서 명령을 할때 해당 스킬들을 다운받아서 사용할수 있습니다. (클로드 스킬 github: https://github.com/anthropics/skills)
- 저는 테스트코드를 작성하는 커스텀 스킬을 만들었습니다. (화면에서 skill-creator를 active해야 커스텀 코드를 만들수있습니다.)
- 아래 참조를 보다시피 단 2번만에 테스트코드를 작성하는 스킬을 작성 했고 동작도 잘되었습니다. ( [PR 코드 참조](https://github.com/F-F-WP/wp-online-store-backend/pull/5192/files#diff-4d149b84efdffaa9e7d54b978f95610ca7154a73d5942f32427408d7833cd528) )

### 참조

> 난 클로드 커스텀 스킬을 만들고 싶은데
> 
- 답변
    
    ⏺ Claude Code의 커스텀 스킬을 만드는 방법에 대해 알아보겠습니다. 공식 문서에서 정보를 가져오겠습니다.
    
    ⏺ Fetch(https://docs.claude.com/en/docs/claude-code/claude_code_docs_map.md)
    ⎿  Received 25.9KB (200 OK)
    
    ⏺ 이제 스킬 생성에 대한 상세 정보를 가져오겠습니다.
    
    ⏺ Fetch(https://docs.claude.com/en/docs/claude-code/skills.md)
    ⎿  Received 14.7KB (200 OK)
    
    ⏺ 좋습니다! Claude Code 커스텀 스킬 만드는 방법을 알려드리겠습니다.
    
    스킬 구조
    
    스킬은 두 가지 타입이 있습니다:
    
    1. Personal Skills (개인용 - 모든 프로젝트에서 사용)
    
    ~/.claude/skills/skill-name/
    ├── [SKILL.md](http://skill.md/) (필수)
    ├── [supporting-docs.md](http://supporting-docs.md/) (선택)
    └── scripts/helper.py (선택)
    
    1. Project Skills (프로젝트용 - 팀과 공유)
    
    .claude/skills/skill-name/
    ├── [SKILL.md](http://skill.md/) (필수)
    └── [추가 파일들]
    
    [SKILL.md](http://skill.md/) 형식
    
    ---
    
    ## name: skill-identifier
    description: 스킬이 무엇을 하는지, 언제 사용해야 하는지 설명
    allowed-tools: [선택사항 - 도구 제한]
    
    # Skill Title
    
    ## Instructions
    
    Claude가 따라야 할 단계별 가이드
    
    ## Examples
    
    구체적인 사용 예시
    
    실제 예시
    
    예를 들어, Spring Boot 테스트 작성 스킬을 만든다면:
    
    ---
    
    ## name: spring-test-helper
    description: Write Spring Boot controller and service tests using MockMvc, Mockito, and AssertJ. Use when
    user asks to write tests, create test cases, or test Spring components.
    allowed-tools: [Read, Write, Edit, Bash]
    
    # Spring Boot Test Helper
    
    ## Instructions
    
    1. Identify the component type (Controller/Service/Repository)
    2. Use @WebMvcTest for controllers, @SpringBootTest for integration tests
    3. Create MockBean dependencies
    4. Write test methods following AAA pattern (Arrange, Act, Assert)
    5. Use AssertJ for fluent assertions
    6. Run tests with `./gradlew test --tests ClassName`
    
    ## Examples
    
    Controller test with MockMvc and MockBean...
    
    주요 포인트
    
    - name: 소문자, 숫자, 하이픈만 (최대 64자)
    - description: 구체적으로! "when user asks to..."처럼 트리거 키워드 포함
    - allowed-tools: 보안이 중요하면 도구 제한 가능
    
    현재 프로젝트에 어떤 스킬을 만들고 싶으신가요? 제가 도와드릴 수 있습니다!
    

> 현재 프로젝트에서 테스트 코드 작성 스킬을 만들고 싶어. 이전에 작성한 테스트 코드등를 보고 스킬 작성을 도와줘
> 
- 답변
    
    ⏺ 좋습니다! 현재 프로젝트의 테스트 코드들을 분석해서 테스트 작성 스킬을 만들어드리겠습니다.
    
    먼저 기존 테스트 코드들을 탐색하겠습니다.
    
    ⏺ Search(pattern: "**/*Test.java")
    ⎿  Found 100 files (ctrl+o to expand)
    
    ⏺ Search(pattern: "**/*IntegrationTest.java")
    ⎿  Found 8 files (ctrl+o to expand)
    
    ⏺ 테스트 파일이 많네요! 대표적인 패턴들을 파악하기 위해 몇 가지 샘플을 읽어보겠습니다.
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/deliveryaddress_create/adapter/in/DeliveryAddressAddController
    Test.java)
    ⎿  Read 77 lines
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/member_benefit_kakaotalk_agree_point_reward/application/KakaoT
    alkAgreementBenefitInteractorTest.java)
    ⎿  Read 257 lines
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/member_login/application/LoginInteractorIntegrationTest.java)
    ⎿  Read 135 lines
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/batch_birthday_coupons_create/adapter/in/BatchIssueDuveticaBir
    thdayCouponsControllerTest.java)
    ⎿  Read 59 lines
    
    ⏺ 좋습니다! 몇 개 더 읽어서 패턴을 완전히 파악하겠습니다.
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/batch_point_expiration_alarm_create/adapter/out/ExpirePointSum
    maryFormatterTest.java)
    ⎿  Read 217 lines
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/deliveryaddress_create/adapter/out/DeliveryAddressValidationIn
    teractorTest.java)
    ⎿  Read 227 lines
    
    ⏺ Search(pattern: "@WebMvcTestWithoutSecurity", head_limit: 5)
    ⎿  Found 5 files (ctrl+o to expand)
    
    ⏺ 완벽합니다! 이제 커스텀 어노테이션과 테스트 유틸 클래스를 확인하겠습니다.
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/common/WebMvcTestWithoutSecurity.java)
    ⎿  Read 33 lines
    
    ⏺ Search(pattern: "src/test/java/**/common/*.java")
    ⎿  Found 4 files (ctrl+o to expand)
    
    ⏺ 완벽합니다! 이제 프로젝트의 테스트 패턴을 충분히 파악했습니다. 스킬을 생성하겠습니다.
    
    ⏺ Bash(mkdir -p .claude/skills/spring-test-writer)
    ⎿  (No content)
    
    ⏺ Write(.claude/skills/spring-test-writer/SKILL.md)
    ⎿  Wrote 476 lines to .claude/skills/spring-test-writer/SKILL.md
    
    ---
    name: spring-test-writer
    description: Write Spring Boot test code following WP project patterns including controller tests with
    @WebMvcTestWithoutSecurity, interactor tests with @ExtendWith(MockitoExtension.class), and integration
    tests. Use when user asks to write test, create test code, test controller, test interactor, test service,
    or add unit tests.
    allowed-tools: [Read, Write, Edit, Glob, Grep, Bash]
    ---
    # Spring Test Writer for WP Online Store Backend
    Automatically writes Spring Boot test code following the established patterns in the WP Online Store
    Backend project.
    … +466 lines (ctrl+o to expand)
    
    ⏺ 완벽합니다! 이제 스킬에 추가 참고 문서를 추가하겠습니다.
    
    ⏺ Write(.claude/skills/spring-test-writer/test-patterns-reference.md)
    ⎿  Wrote 455 lines to .claude/skills/spring-test-writer/test-patterns-reference.md
    
    # Test Patterns Reference
    This document provides quick reference for common test patterns used in the WP Online Store Backend
    project.
    ## Quick Pattern Selection
    | Component Type | Annotation | Dependencies | Key Tools |
    |----------------|------------|--------------|-----------|
    | Controller | `@WebMvcTestWithoutSecurity` | `@MockBean` | MockMvc, ObjectMapper |
    | Interactor/Service | `@ExtendWith(MockitoExtension.class)` | `@Mock`, `@InjectMocks` | BDD Mockito |
    … +445 lines (ctrl+o to expand)
    
    ⏺ 완벽합니다! 이제 스킬이 생성되었습니다. 스킬을 테스트해보겠습니다.
    
    ⏺ Bash(ls -la .claude/skills/spring-test-writer/)
    ⎿  total 56
    
    drwxr-xr-x@ 4 jonghyunjoo  staff    128 Oct 23 20:54 .
    drwxr-xr-x@ 3 jonghyunjoo  staff     96 Oct 23 20:52 ..
    … +2 lines (ctrl+o to expand)
    
    ⏺ 완벽합니다! 스킬이 성공적으로 생성되었습니다. 스킬 내용을 요약해드리겠습니다.
    
    ✅ Spring Test Writer 스킬 생성 완료!
    
    프로젝트의 기존 테스트 코드 패턴을 분석하여 spring-test-writer 스킬을 만들었습니다.
    
    📁 생성된 파일
    
    .claude/skills/spring-test-writer/
    ├── [SKILL.md](http://skill.md/)                      (메인 스킬 정의)
    └── [test-patterns-reference.md](http://test-patterns-reference.md/)    (상세 참고 문서)
    
    🎯 스킬 기능
    
    이 스킬은 다음과 같은 경우에 자동으로 활성화됩니다:
    
    - "테스트 작성해줘"
    - "컨트롤러 테스트 만들어줘"
    - "인터랙터 테스트 코드 작성"
    - "단위 테스트 추가"
    
    📋 지원하는 테스트 타입
    
    1. Controller Tests
    - @WebMvcTestWithoutSecurity 사용
    - MockMvc로 HTTP 요청 테스트
    - 한글 메서드명 (예: 정상동작)
    1. Interactor/Service Tests
    - @ExtendWith(MockitoExtension.class) 사용
    - BDD 스타일 Mockito (given, then)
    - @Nested 클래스로 시나리오 그룹화
    1. Validation Tests
    - 유효성 검증 로직 테스트
    - assertDoesNotThrow, assertThrowsExactly 사용
    1. Integration Tests
    - @SpringBootTest 사용
    - 실제 DB 연동 테스트
    - 기본적으로 @Disabled
    
    🔑 주요 패턴
    
    - AAA 패턴: given/when/then 구조
    - FakeFactory: 테스트 데이터 생성 내부 클래스
    - 한글 메서드명: 프로젝트 컨벤션 준수
    - AssertJ: 유창한 assertion 스타일
    - ArgumentCaptor: adapter 호출 검증
    
    💡 사용 예시
    
    이제 다음과 같이 요청하면:
    "MemberController에 대한 테스트 작성해줘"
    
    스킬이 자동으로 활성화되어:
    
    1. 기존 패턴 분석
    2. @WebMvcTestWithoutSecurity 적용
    3. MockMvc 설정
    4. 한글 메서드명으로 테스트 작성
    5. ArgumentCaptor로 검증 추가
    
    🚀 다음 단계
    
    스킬이 준비되었으니, 이제:
    
    1. 테스트 작성이 필요한 컴포넌트를 말씀해주세요
    2. 제가 자동으로 프로젝트 패턴에 맞는 테스트를 작성해드립니다!
    
    어떤 컴포넌트의 테스트를 작성해볼까요? 😊
    

> 음 Point 관련 부분 테스트 작성해줘
> 
- 답변
    
    ⏺ Point 관련 컨트롤러를 찾아보겠습니다.
    
    ⏺ Search(pattern: "**/point*/adapter/in/*Controller.java")
    ⎿  Found 0 files
    
    ⏺ Search(pattern: "**/mypage_point*/adapter/in/*Controller.java")
    ⎿  Found 4 files (ctrl+o to expand)
    
    ⏺ 좋습니다! Point 관련 컨트롤러를 찾았습니다. 어떤 컨트롤러의 테스트를 작성할지 선택해주세요:
    
    1. AvailablePointFindController - 사용 가능한 포인트 조회
    2. PointSummaryFindController - 포인트 요약 정보 조회
    3. PointHistorySearchController - 포인트 히스토리 검색
    4. SearchExtinctionPointHistoryController - 소멸 포인트 히스토리 검색
    
    제가 PointSummaryFindController부터 시작해서 모두 작성해드릴까요?
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/app/mypage_point_summary_read/adapter/in/PointSummaryFindController.java)
    ⎿  Read 40 lines
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/app/mypage_point_summary_read/adapter/in/PointSummaryResponse.java)
    ⎿  Read 17 lines
    
    ⏺ Search(pattern: "**/mypage_point_summary_read/**/*Test.java")
    ⎿  Found 3 files (ctrl+o to expand)
    
    ⏺ 아! 이미 테스트가 존재하네요. 다른 Point 관련 컨트롤러를 확인해보겠습니다.
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/app/mypage_point_available_read/adapter/in/AvailablePointFindController.java)
    ⎿  Read 38 lines
    
    ⏺ Search(pattern: "**/mypage_point_available_read/**/*Test.java")
    ⎿  Found 2 files (ctrl+o to expand)
    
    ⏺ 이것도 테스트가 있네요. 다른 컨트롤러들도 확인해보겠습니다.
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchController.java)
    ⎿  Read 83 lines
    
    ⏺ Search(pattern: "**/mypage_point_history_read/**/*Test.java")
    ⎿  Found 2 files (ctrl+o to expand)
    
    ⏺ PointHistorySearchController에는 컨트롤러 테스트가 없네요! 이것을 작성하겠습니다. 먼저 Response 클래스도 확인하겠습니다.
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistoryResponse.java)
    ⎿  Read 26 lines
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/app/mypage_point_history_read/domain/PointHistoryType.java)
    ⎿  Read 8 lines
    
    ⏺ 좋습니다! 이제 PointHistorySearchController에 대한 테스트를 작성하겠습니다. 참고할 비슷한 컨트롤러 테스트를 먼저 확인하겠습니다.
    
    ⏺ Read(src/test/java/fnf/wp/online_store_backend/app/mypage_point_summary_read/adapter/in/PointSummaryFindControllerTest.java)
    ⎿  Read 45 lines
    
    ⏺ 완벽합니다! 이제 PointHistorySearchController에 대한 테스트를 작성하겠습니다.
    
    ⏺ Write(src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java)
    ⎿  Wrote 282 lines to src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java
    package fnf.wp.online_store_backend.app.mypage_point_history_read.adapter.in;
    import static fnf.wp.online_store_backend.module.enums.MallId.MBM;
    import static org.assertj.core.api.Assertions.assertThat;
    import static org.mockito.ArgumentMatchers.any;
    import static org.mockito.ArgumentMatchers.eq;
    import static org.mockito.Mockito.only;
    import static org.mockito.Mockito.verify;
    import static org.mockito.Mockito.when;
    import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
    … +272 lines (ctrl+o to expand)
    

> 오키오키 거까지만 작성해줘
> 
- 답변
    
    ⏺ 완벽합니다! PointHistorySearchController에 대한 테스트 코드를 작성했습니다. 이제 테스트를 실행해서 정상 동작하는지 확인해보겠습니다.
    
    ⏺ Bash(./gradlew test --tests "PointHistorySearchControllerTest")
    ⎿  Error: Note: Some input files use or override a deprecated API.
    Note: Recompile with -Xlint:deprecation for details.
    Note: Some input files use unchecked or unsafe operations.
    Note: Recompile with -Xlint:unchecked for details.
    /Users/jonghyunjoo/IdeaProjects/wp-online-store-backend/src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySea
    rchControllerTest.java:261: error: cannot infer type arguments for CommonPage<>
    val commonPage = new CommonPage<>(
    ^
    reason: cannot infer type-variable(s) T
    (actual and formal argument lists differ in length)
    where T is a type-variable:
    … +51 lines (ctrl+o to see all)
    
    ⏺ CommonPage의 생성자 시그니처가 다르네요. CommonPage 클래스를 확인해보겠습니다.
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/lib/pagination/CommonPage.java)
    ⎿  Read 14 lines
    
    ⏺ Read(src/main/java/fnf/wp/online_store_backend/lib/pagination/Pagination.java)
    ⎿  Read 38 lines
    
    ⏺ 이제 이해했습니다. CommonPage는 Pagination 객체와 List를 받아야 합니다. 테스트 코드를 수정하겠습니다.
    
    ⏺ Update(src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java)
    ⎿  Updated src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java with 1 addition
    16    import fnf.wp.online_store_backend.app.mypage_point_history_read.domain.PointHistoryType;
    17    import fnf.wp.online_store_backend.common.WebMvcTestWithoutSecurity;
    18    import fnf.wp.online_store_backend.lib.pagination.CommonPage;
    19 +  import fnf.wp.online_store_backend.lib.pagination.Pagination;
    20    import java.util.List;
    21    import lombok.val;
    22    import org.junit.jupiter.api.BeforeEach;
    
    ⏺ Update(src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java)
    ⎿  Updated src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java with 6 additions an
    6 removals
    259              .useEndDate("2025-01-10T23:59:59.000+09:00")
    260              .build();
    261
    
    262 +        val pagination = Pagination.fromPageable(PageRequest.of(0, 10), 100);
    263          val commonPage = new CommonPage<>(
    264 -            List.of(pointHistory1, pointHistory2),
    265 -            PageRequest.of(0, 10),
    266 -            100
    264 +            pagination,
    265 +            List.of(pointHistory1, pointHistory2)
    266          );
    267
    
    268          return new PointHistoryResponse(commonPage);
    269        }
    270
    
    271        private static PointHistoryResponse createEmptyResponse() {
    272 +        val pagination = Pagination.fromPageable(PageRequest.of(0, 10), 0);
    273          val commonPage = new CommonPage<PointHistoryResponse.PointHistory>(
    274 -            List.of(),
    275 -            PageRequest.of(0, 10),
    276 -            0
    274 +            pagination,
    275 +            List.of()
    276          );
    277
    
    278          return new PointHistoryResponse(commonPage);
    
    ⏺ 이제 다시 테스트를 실행해보겠습니다.
    
    ⏺ Bash(./gradlew test --tests "PointHistorySearchControllerTest")
    ⎿  Error: Note: Some input files use or override a deprecated API.
    Note: Recompile with -Xlint:deprecation for details.
    Note: Some input files use unchecked or unsafe operations.
    Note: Recompile with -Xlint:unchecked for details.
    Note: Some input files use or override a deprecated API.
    Note: Recompile with -Xlint:deprecation for details.
    Note: Some input files use unchecked or unsafe operations.
    Note: Recompile with -Xlint:unchecked for details.
    OpenJDK 64-Bit Server VM warning: Sharing is only supported for boot loader classes because bootstrap classpath has been appended
    
    ```
     … +64 lines (ctrl+o to see all)
    
    ```
    
    ⏺ 9개 중 7개가 통과했네요! 2개의 응답 검증 테스트가 실패했습니다. JSON 경로를 확인해보겠습니다. CommonPage의 필드명이 contents인 것 같습니다.
    
    ⏺ Update(src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java)
    ⎿  Updated src/test/java/fnf/wp/online_store_backend/app/mypage_point_history_read/adapter/in/PointHistorySearchControllerTest.java with 2 additions an
    2 removals
    222          mockMvc.perform(get(baseUrl))
    223              .andExpect(status().isOk())
    224              .andExpect(jsonPath("$.pointHistory").exists())
    225 -            .andExpect(jsonPath("$.pointHistory.content").isArray());
    225 +            .andExpect(jsonPath("$.pointHistory.contents").isArray());
    226        }
    227
    
    228        @Test
    ...
    236          mockMvc.perform(get(baseUrl))
    237              .andExpect(status().isOk())
    238              .andExpect(jsonPath("$.pointHistory").exists())
    239 -            .andExpect(jsonPath("$.pointHistory.content").isEmpty());
    239 +            .andExpect(jsonPath("$.pointHistory.contents").isEmpty());
    240        }
    241      }
    242
    

> 너가 알게된 부분 (CommonPage는 Pagination 객체와 List..)은 테스트코드 작성 스킬에 자동으로 업데이트 돼?
> 
- 답변
    
    ⏺ 좋은 질문입니다! 지금 제가 학습한 내용(CommonPage의 구조)은 자동으로 스킬에 업데이트되지 않습니다. 스킬 파일은 제가 수동으로 수정해야 합니다.
    
    이번에 배운 내용을 스킬에 추가하겠습니다. 먼저 테스트를 마저 실행해보겠습니다.
    
    ⏺ Bash(./gradlew test --tests "PointHistorySearchControllerTest")
    ⎿  > Configure project :
    
    App Version: 0.18.0-2413-g14e4022.dirty
    … +48 lines (ctrl+o to expand)
    
    ⏺ 🎉 완벽합니다! 모든 테스트(9개) 통과했습니다!
    
    이제 배운 내용을 스킬에 추가하겠습니다.
    
    ⏺ Update(.claude/skills/spring-test-writer/SKILL.md)
    ⎿  Updated .claude/skills/spring-test-writer/SKILL.md with 26 additions
    
    247    }
    248           `249            250 +  ## Project-Specific Patterns        251 +          252 +  ### CommonPage and Pagination        253 +  The project uses a custom pagination wrapper:        254 +          255 +` java
    256 +  // CommonPage structure
    257 +  public record CommonPage<T>(
    258 +      @NonNull Pagination pagination,
    259 +      @NonNull List<T> contents
    260 +  )
    261 +
    
    262 +  // Creating CommonPage in tests
    263 +  val pagination = Pagination.fromPageable(PageRequest.of(0, 10), 100);
    264 +  val commonPage = new CommonPage<>(pagination, List.of(item1, item2));
    265 +
    
    266 +  // JSON path for CommonPage responses
    267 +  jsonPath("$.fieldName.contents") // NOT "content"
    268 +  jsonPath("$.fieldName.pagination.totalItemCount")
    269 +  ```
    270 +
    
    271 +  **Important**:
    272 +  - Use `Pagination.fromPageable(pageable, totalCount)` to create pagination
    273 +  - CommonPage field is `contents` (plural), not `content`
    274 +  - Import both `CommonPage` and `Pagination` from `fnf.wp.online_store_backend.lib.pagination`
    275 +
    
    276    ## Common Imports
    277
    
    278    ### Controller Tests
    
    ⏺ 완벽합니다! 이제 스킬도 업데이트했습니다.
    
    📊 완료 요약
    
    ✅ 생성된 테스트
    
    PointHistorySearchControllerTest - 총 9개 테스트 케이스
    
    1. ✅ 기본 파라미터로 포인트 히스토리 조회 정상 동작
    2. ✅ page와 size 파라미터가 정상적으로 전달된다
    3. ✅ page 파라미터가 없으면 기본값 0이 사용된다
    4. ✅ size 파라미터가 없으면 기본값 10이 사용된다
    5. ✅ type 파라미터가 정상적으로 전달된다
    6. ✅ startDate와 endDate 파라미터가 정상적으로 전달된다
    7. ✅ 모든 검색 조건을 함께 전달할 수 있다
    8. ✅ 정상적인 응답 구조를 반환한다
    9. ✅ 빈 결과도 정상적으로 반환한다
    
    📚 스킬 업데이트
    
    - CommonPage와 Pagination 사용법 추가
    - JSON path에서 contents 사용법 명시
    - 프로젝트 특화 패턴 섹션 추가
    
    🎯 테스트 패턴 적용
    
    - @WebMvcTestWithoutSecurity 사용
    - @Nested 클래스로 시나리오 그룹화
    - @DisplayName으로 명확한 테스트 설명
    - ArgumentCaptor로 파라미터 검증
    - FakeFactory 패턴으로 테스트 데이터 생성
    
    모든 테스트가 통과했고, 스킬도 자동으로 학습한 내용이 추가되었습니다! 🚀
    

# 결론

- 매우 편하다.
- 매우 빠르다.
- 공유도 편해서 협업시 일관된 작업을 만들수 있다.