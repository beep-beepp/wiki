### 지원

# G1 GC
대용량 힙 환경에서 예측 가능한 Pause time을 유지하며 안정적인 성능을 제공하기 위해 설계된 GC이다.

## 1. 목적 
- 목표 Pause time을 최대한 만족하도록 함
- Full GC의 발생을 최소화하고 예측 가능한 Pause time 유지 
- Region 기반 관리로 Fragmentation을 완화하고 안정적인 Throughput 확보

## 2. 왜 나왔을까?

| 기존 GC       | 특징                                        | 한계점                                                                   |
|-------------|-------------------------------------------|-----------------------------------------------------------------------|
| Parallel GC | Young/Old 세대를 분리하고 병렬 수집으로 Throughput 극대화 | 힙이 커질수록 STW 시간이 선형적으로 증가                                              |
 |  CMS GC | Old 영역을 Concurrent로 수집해 STW 감소            | Compaction 과정이 없어 Fragmentation 누적 ->  Full GC 발생 및 Pause time 예측 어려움 |

CMS는 낮은 Pause time을 제공했지만,
<br>대용량 힙에서는 Fragmentation 누적과 Concurrent Mode Failure로 인해 STW Full GC가 발생하며 불안정했다.
<br>이를 해결하기 위해 Oracle은 예측 가능한 Pause 목표와 안정성을 동시에 달성할 수 있는 G1 GC를 설계했다.

## 3. 작동 방식

### 설계 핵심
1. Region 기반 설계
   - 전체 힙을 균일한 크기(1~32MB)의 Region 단위로 분할한다.
   - Region 크기는 최대 힙 크기(MaxHeapSize) 기준으로 자동 계산되며, 기본적으로 약 2048개의 Region을 목표로 한다. 
   - 각 Region은 시점에 따라 Eden / Survivor / Old 역할 중 하나를 가진다.
   - 세대 구분(Young/Old)은 물리적으로 분리되지 않고, Region의 메타데이터(Tag)로 논리적으로 구분된다.
   - 대부분의 객체는 Evacuation 과정에서 새로운 Region으로 복사되기 때문에 Fragmentation이 거의 없다.
     <br>단, Humongous 객체는 여러 Region을 연속적으로 점유하므로, GC 대상이 되기 전까지 다른 Region으로 이동할 수 없어 Fragmentation의 주요 원인이 된다.

2. Garbage-First 정책
   - Concurrent Marking 단계에서 각 Region의 Live 객체 비율과 회수 효율을 계산한다.
   - GC 시점에 Garbage 비율 대비 회수 비용이 낮은 Region부터 우선적으로 회수한다.
   - `-XX:MaxGCPauseMillis` 로 설정된 목표 시간 안에서 회수 가능한 Region 수를 휴리스틱하게 계산한다. 

### Region 역할
| 역할        | 설명                          | 할당 시점                           | 회수 시점                                           |
|-----------|-----------------------------|---------------------------------|-------------------------------------------------|
| Eden      | 새 객체가 생성되는 영역               | 새 객체 할당 시                       | Young GC때 비워짐<br/>살아남은 객체는 Survivor 또는 Old로 복사됨 |
| Survivor  | Young GC에서 살아남은 객체를 보관      | Young GC Evacuation 중           | 다음 Young GC때 다시 복사됨 -> 일정 횟수 후 Old로 승격됨         |
| Old       | 여러 차례 살아남은 장기 객체 보관         | Survivor에서 Promotion 시          | Mixed GC 단계에서 Garbage 비율이 높은 Region만 선택적으로 회수   |
| Humongous | Region 크기의 50% 이상인 대형 객체 보관 | 대형 객체 할당 시 (1개 이상 연속 Region 사용) | Humongous 객체가 점유한 모든 Region이 Garbage일 때 회수됨     |

- Eden -> Survivor -> Old로 객체가 승격됨.
- Humongous 객체는 Young/Old세대에 속하지 않지만, Old Region으로 간주되어 Mark 단계에 포함됨
- 각 Region은 GC 사이클마다 역할이 동적으로 바뀔 수 있음

### Young GC
발생조건 : Eden Region 공간이 부족할 때
목적 : Eden, Survivor(From) Region을 정리하여 새로운 객체 할당 공간을 확보한다.

1. STW 발생
   - 모든 애플리케이션 스레드가 중단되고, GC 워커 스레드들이 병렬로 작업을 수행한다. 
2. Collection Set(CSet) 결정 
   - 이번 Young GC에서 회수할 Region 목록을 선정한다.
   - Young-only GC의 경우, 일반적으로 Eden + Survivor(From) Region 전체가 대상이 된다.
   - (Mixed GC의 경우에는 Old Region도 일부 포함될 수 있다.)
3. Root / Remembered Set(RSet) 스캔
   - GC가 Root 객체(Stack, JNI, static 등)부터 탐색을 시작한다.
   - Old 객체가 Young 객체를 참조하는 경우를 빠르게 찾기 위해 RSet 정보를 활용한다.
   - Root 스캔과 RSet 스캔은 병렬로 수행되며, 살아있는 객체 그래프를 추적한다.
4. Initial Mark (선택) 
   - Initial Mark는 Young GC가 STW 상태일때, Root 스캔 단계 바로 다음에 짧게 수행된다.
   - Old 영역을 참조하는 객체들을 mark root set으로 표시한다.
5. 살아있는 객체 복사(Evacuation)
   - Eden, Survivor(From)에 존재하는 Live 객체만 Survivor(To) 또는 Old Region으로 복사(evacuate)한다.
   - 이때 객체에는 forwarding pointer가 기록되어, 참조 갱신 시 새 위치로의 포인터를 빠르게 찾을 수 있다.
6. 참조 갱신 / 약한 참조 처리
   - 복사된 객체의 새 주소로 모든 참조 포인터를 갱신함 
   - Soft/Weak/Phantom Reference 등 약한 참조는 Reference Processing Phase에서 별도로 병렬로 정리된다.
7. Evacuation Failure 처리
   - Survivor 또는 Old Region의 여유 공간이 부족해 Evacuation이 실패하면 해당 객체는 기존 Region에 남게 된다.
   - 이 경우 Region이 "pinned" 상태가 되며, Full GC 가능성이 증가한다.
8. Region Free 및 통계 갱신
   - Eden, Survivor(From)는 완전히 비워져 Free List로 반환된다.
   - Survivor(To)는 다음 Young GC때 From으로 스왑된다.
   - JVM은 Survivor 내 객체의 나이(tenuring age)와 promotion 비율을 통계로 기록한다.
9. STW 해제
   - 모든 GC 스레드의 작업이 완료되면 STW가 해제되고, 애플리케이션 스레드가 재개된다.

### Concurrent Mark
Young GC가 반복되는 동안 Old 영역 점유율이 -XX:InitiatingHeapOccupancyPercent를 초과하면,
다음 Young GC 시점에 Concurrent Mark 사이클을 시작한다.

1. Initial Mark (STW)
   - 애플리케이션 스레드를 멈추고 Root에서 Old Region을 참조하는 객체들을 mark root set으로 표시한다.
   - 이 단계는 Young GC와 통합되어 함께 수행되며, Old 영역 전체를 훑지는 않는다.
   - STW 시간이 짧다.
2. Root Region Scan (Concurrent)
   - STW 해제 후 바로 시작한다.
   - Initial Mark 이후, Root Region(Eden 또는 Survivor 중 Old 객체를 참조하는 Region)을 스캔한다.
   - 이 과정은 애플리케이션 스레드 실행과 동시(Concurrent)에 실행된다.
3. Concurrent Mark 
   - 애플리케이션 실행과 동시에 Old 영역 전체를 스캔한다.
   - SATB(Snapshot-At-The-Beginning) 알고리즘을 사용하여 Mark 시작 시점의 객체 그래프를 기준으로 살아있는 객체를 표시한다.
   - 이 과정에서 각 Region의 Live Object 비율(Live Ratio)이 계산된다.
4. Remark (STW)
   - Concurrent Mark 중 변경된 참조(새로 연결된 객체 등)을 반영하여 누락된 객체를 다시 Marking한다.
   - 짧은 STW로 수행된다.
5. Cleanup(부분 STW + Concurrent)
   - 각 Region의 Live Ratio(살아있는 비율)를 기반으로 Garbage가 많은 Region을 Mixed GC 후보 집합(Candidate Set)으로 등록한다.
   - 완전히 비어 있는 Region은 즉시 Free List로 반환된다.
   - 일부 메타데이터 갱신은 STW, 나머지 통계/정리 작업은 Concurrent로 수행된다.

#### ❓ 왜 Initial Mark는 Root 스캔 뒤에 진행할까?
Initial Mark는 Old 영역 전체를 훑지 않고, Old를 참조하는 Root 객체만 표시하는 가벼운 작업이다.
<br>이걸 별도의 STW로 한 번 더 하게 되면 Pause가 늘어나니까, 이미 멈춰있는 Young GC 타이밍에 합쳐서 수행하는 게 효율적이기 때문이다.

#### ❓ Old 영역 점유율이 -XX:InitiatingHeapOccupancyPercent를 초과하는건 언제 체크할까?
Young GC 종료 직전 단계(8. Region Free 및 통계 갱신 단계 참고)에서, Region 통계가 갱신된 직후 최신 힙 사용률을 기반으로 편가된다.
이때 Old 영역 사용률이 InitiatingHeapOccupancyPercent를 초과하면, 다음 Young GC때 Initial Mark 단계로 진입하기 위한 플래그를 세운다.

### Mixed GC (Old + Young 함께 수집)
Concurrent Marking이 완료되면, 
<br>이제 Young GC 시점에 Garbage가 많은 Old Region도 함께 수집하는 Mixed GC 단계로 진입한다.

특징
- STW 발생
- Collection Set = Eden + Survivor(From) + 일부 Old Region
- "Garbage-First" 정책에 따라 Garbage 비율이 높고 회수 효율이 높은 Old Region부터 우선적으로 선택한다.
- 선택된 Old Region의 Live 객체는 새 Region으로 Evacuation(복사) 되며, 복사 완료 후 기존 Region은 Free List로 반환된다.
- Mixed GC는 여러 번 반복되며, Candidate Set이 모두 회수되면 다시 일반 Young GC 루프로 돌아간다.

### Full GC (예외 상황)

G1의 설계 목표는 Full GC를 피하는 것이지만, 다음과 같은 예외 상황에서는 발생할 수 있다.
- Evacuation 대상 공간 부족 (To-space exhausted)
- Humongous 객체 할당 실패 또는 과도한 Fragmentation
- Concurrent Mark Stack Overflow 또는 메모리 부족 등 내부 실패

이 경우, G1은 Parallel Full GC로 전환되어 전체 힙을 STW 상태에서 Compaction한다.
<br>이 단계는 가장 느리지만, 이후 힙 상태가 초기화되어 다시 정상적인 G1 사이클로 돌아간다.

### 전체 흐름 정리
```text
[여러 번의 Young GC 반복]
        ↓
(Old 영역 사용률 ≥ InitiatingHeapOccupancyPercent)
        ↓
[Young GC + Initial Mark]
        ↓
[Concurrent Mark]
        ↓
[Remark (STW)]
        ↓
[Cleanup (부분 STW + 병렬)]
        ↓
[Mixed GC 반복]
        ↓
다시 Young GC 루프로 복귀
```


## 4. 장단점

| 장점                  | 설명                                                                    |
|---------------------|-----------------------------------------------------------------------|
| Pause time 예측 가능    | -XX:MaxGCPauseMillis로 목표 Pause를 설정하고, 휴리스틱 기반으로 STW 시간을 제어함           |
| Fragmentation 거의 없음 | Region 단위 Evacuation(복사)로 대부분의 Fragmentation이 해소됨 (단, Humongous 객체는 예외) |
| 멀티코어 환경에 최적화        | Marking, Evacuation, Cleanup 단계가 병렬 및 Concurrent로 수행되어 멀티코어에서 효율적     |
| 대용량 힙에서도 안정적       | 수 GB ~ 수백 GB 규모에서도 CMS 대비 Full GC 빈도 낮고 일관된 성능 유지                     |
| Throughput과 안정성의 균형 | 높은 Throughput을 유지하면서도 예측 가능한 Pause time 제공                            |

| 단점                   | 설명                                                     |
|----------------------|--------------------------------------------------------|
| 작은 힙에서는 비효율적         | Region 관리 및 통계 계산 오버헤드가 발생함. Parallel GC가 더 단순하고 빠름    |
| Pause time 완전 보장은 아님 | 설정된 시간은 "목표"일 뿐, 절대 Pause는 상황에 따라 초과할 수 있음             |
| Humongous 객체에 취약     | Region 크기의 50% 이상인 대형 객체가 많을 경우 효율 저하 및 Full GC 유발 가능  |
| 튜닝 필요성 존재            | Region 크기, Pause 목표, Concurrent Thread 비율 등에 따라 최적화 필요 |


## 5. 언제 쓰면 좋을까?

| 힙 크기     | 권장여부  | 이유                          | 설명                                              |
|----------|-------|-----------------------------|-------------------------------------------------|
| < 4GB    | 비추천   | 오버헤드 대비 이점 적음               | 작은 힙에서는 Parallel GC가 더 단순하고 빠름                  |
| 4~8GB    | 보통    | G1의 예측 가능한 Pause 이점을 일부 체감  | Throughput은 Parallel GC보다 약간 떨어질 수 있음           |
| 8~32GB   | 적극 권장 | G1이 설계 타겟 범위                | CMS 대비 안정적이며 Pause 예측 가능                        |
| 32~128GB | 강력 권장 | CMS가 Fragmentation으로 불안정해지는 영역 | 대규모 서버 환경에선 G1이 가장 안정적임                         |
| > 128GB  | 한계 있음 | Concurrent Mark 부하 증가       | Pause는 짧지만 Marking 시간이 길어짐 -> ZGC/Shenandoah 고려 |

| CPU 코어 수      | 권장여부  | 이유                                             |
|---------------|-------|------------------------------------------------|
| 1 ~ 2         | X     | G1은 여러개의 GC 워커 스레드를 활용함 -> 코어가 적으면 GC 오버헤드가 커짐 |
| 4 ~ 8         | 보통    | 병렬 Evacuation 및 Concurrent Mark 효율이 향상됨        |
| 8 ~ 16        | 권장    | G1의 병렬 처리 구조에 최적화됨                             |
| >= 16 (대형 서버) | 강력 권장 | 대형 서버에서는 수백 ms 이하의 짧은 Pause를 안정적으로 유지 가능       |

| 서비스 유형                   | 적합여부  | 이유                                             |
|--------------------------|-------|------------------------------------------------|
| 대용량 웹/API 서버             | 매우 적합 | Pause 에측 가능 + 안정적인 Throughput                  |
| 대규모 트랜잭션 시스템(금융, 주문처리 등) | 적합    | CMS보다 안정적이고 STW 제어 용이함                         |
| Batch / ETL / Log 처리 시스템 | 보통    | STW 짧은게 중요하지 않다면 Parallel GC가 효율적임             |
| 실시간 응답형(게임 서버, 메시징 등)    | 부분적   | G1도 충분히 빠르지만 초저지연 요구사항인 경우 ZGC / Shenandoah 추천 |
| Desktop / CLI 도구         | X     | 작은 힙, 짧은 생명주기 -> Parallel GC가 더 효율적            |


## 6. 결론
G1 GC는 힙을 균등한 Region 단위로 관리하며, 
<br>대용량 힙 환경에서도 짧고 예측 가능한 GC Pause Time을 유지하도록 설계된 고성능 서버용 GC이다.
<br>Garbage가 많은 Region부터 우선 회수하는 "Garbage-First" 정책을 기반으로 Throughput과 안정성을 균형 있게 제공하며, 
<br>오늘날 대부분의 대규모 Java 서버 애플리케이션의 기본 GC로 채택되고 있다.
