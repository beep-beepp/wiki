### 지원

# CMS GC

## 1. 목적
Parallel GC 다음 세대에 나온 Latency 중심의 GC이다.

**CMS(Concurrent Mark-Sweep)** 는 이름 그대로
- **Concurrent** : 애플리케이션 스레드가 동작하는 동안 일부 GC 작업을 병행해서 수행하고,
- **Mark-Sweep** : 살아있는 객체를 표시하고(Mark), 죽은 객체를 쓸어내는(Sweep) 알고리즘을 사용한다.

즉, STW 시간을 최소화해서 끊김 없는 서비스를 목표로 한 GC이다.


## 2. 왜 나왔는가?

Parallel GC는 Throughput은 높지만, STW가 길었다.
그래서 웹서버나 실시간 시스템(결제, 검색 등)은 몇 초 동안 멈추는 걸 감당하지 못했다.
그래서 Java 5에서 Latency를 줄이기 위한 GC로 CMS가 등장했다.
즉, **Throughput -> Latency** 중심으로 무게가 옮겨간 첫 GC이다.


## 3. 작동 방식

CMS GC도 Serial, Parallel GC처럼 Generational GC 모델을 사용한다.

### Minor GC (Young GC)
- CMS는 Old 영역에만 적용되는 GC이다.
- 그래서 Minor GC는 기존과 동일하게 Parallel Scavenge 방식을 사용한다.

### Major GC (Full GC)

| **단계**                 | **동시 여부** | **설명**                                                                                       |
|------------------------|-----------|----------------------------------------------------------------------------------------------| 
| 1) Initial Mark        | X(STW)    | GC Root set(스택변수, static 필드 등)에서 직접 참조하는 Old 객체만 Mark. 짧은 STW.                               |
| 2) Concurrent Mark     | O         | 애플리케이션이 실행하는 동안, Initial Mark에서 표시된 객체를 기준으로 객체 그래프를 따라가며 살아있는 객체를 Mark.                     |
| 3) Concurrent Preclean | O         | Concurrent Mark 중 애플리케이션이 새로 만든 참조나 삭제한 참조를 추적/보정.<br/>Write Barrier를 이용해 Old 영역내 참조 변경분 반영. |
| 4) Remark              | X(STW)    | 애플리케이션을 다시 멈추고, Preclean 이후 남은 변경분(Dirty Card)을 최종적으로 반영.                                    |
| 5) Concurrent Sweep    | O         | 죽은 객체를 실제로 해제하고, 빈 공간을 free list에 등록함. 이때 Compact는 수행하지 않음.                                  |
| 6) Concurrent Reset    | O         | 다음 GC를 위해 Mark Bitmap과 내부 관리 자료구조(Free list, Card Table)등을 초기화함.                             |

### ❓ Write Barrier란?
Write Barrier는 객체 참조가 변경될 때마다 JVM이 해당 변경을 가로채어 GC가 필요한 메타데이터(대표적으로 Card Table)에 기록하는 메커니즘이다.
CMS GC에서 이 Card Table을 읽어 Preclean과 Remark 단계에서 변경을 반영한다.

**동작과정**
<br>CMS에서 Write Barrier은 **Card Table + Dirty Bit** 방식으로 동작한다.

1. Old 영역을 작은 카드 단위(Card, 보통 512byte~2KB)로 나눈다.
2. 객체 참조가 변경될 때마다 JVM이 Write Barrier를 통해 해당 카드에 Dirty Bit(변경됨) 표시를 남긴다.
   - 즉, "이 카드 영역 안에서 참조가 바뀌었어"라는 로그를 남기는 것. 
3. GC는 이 정보를 활용해 두 단계에서 동작한다.
   - Preclean 단계: Dirty로 표시된 카드들을 미리 스캔해서 변경된 참조를 반영한다.
   - Remark 단계: 아직 남아 있는 Dirty 카드를 최종적으로 한 번 더 반영한다.

## 4. 장단점

| **구분**        | **장점**                                         | **단점**                                                                     |
|---------------|------------------------------------------------|----------------------------------------------------------------------------|
| Latency       | STW 구간이 매우 짧음(Initial Mark, Remark 합쳐 수 ms 수준) | Concurrent 단계 중에도 CPU 사용량이 늘어 애플리케이션 처리 지연 가능성                             |
| Throughput    | 짧은 Latency 덕분에 응답 시간의 일관성이 높음                  | 전체 Throughput은 Parallel GC보다 낮음 (동시 실행 오버헤드 때문)                            |
| Fragmentation | Compaction을 생략해 GC 자체는 빠름                      | 메모리 조각이 발생해 공간 활용도 저하 -> 심하면 Full GC 전환 가능성<br/>(Concurrent Mode Failure)) |
| CPU 사용        | GC와 애플리케이션이 동시에 실행돼 리소스 활용도가 높음                | 멀티코어 필요. 단일 코어에서는 경쟁(OS level에서 CPU 스케쥴링 경쟁)으로 인해 효율 저하                    |
| 안정성/예측성       | Low latency(서버, 웹 요청) 환경에서 안정적                 | Fragmentation 누적으로 인해 예기치 못한 Full GC 발생시 STW 수초 단위로 증가 가능                  |


### ❓ Concurrent Mode Failure이란?
- CMS는 Concurrent Sweep 단계에서 Old 영역을 제때 청소하지 못해, 새 객체를 위한 연속된 공간이 부족해지는 상황을 말한다.
  - GC는 객체를 항상 연속된 메모리 블록에 할당해야 하는데, 조각이 많으면 전체 여유 공간이 충분해도 "붙어 있는" 빈 공간이 없어서 새 객체를 못 넣는 상황이 발생한다.
  - 이게 바로 CMS의 Allocation Failure이다.
- 이때 JVM이 강제로 STW Full GC를 실행하며, Parallel GC 수준의 긴 멈춤이 발생한다.
  - CMS 자체적으로 자신의 Full GC(STW Mark-Compact)를 수행한다.
  - Full GC는 Compaction을 포함하므로, STW가 수백 ms~수 초에 이를 수 있다. 즉, CMS가 원래 의도했던 "Low latency" 특성이 무너진다.
  - CMS의 가장 큰 리스크가 바로 이 것 때문인데, 보통 이게 **예측 불가능한 STW**를 만들기 때문에 G1 GC가 CMS를 대체하게 된 이유 중 하나다. 

## 5. 언제 쓰면 좋을까?

## 적합
- Low latency가 중요한 서버(금융거래, 검색엔진 등)
- CPU 코어가 충분하고(4 코어 이상), 약간의 Throughput 손해를 감수할 수 있는 환경
- Throughput보다 응답시간이 KPI인 서비스

## 비적합
- 단일코어 / CPU 여유가 없는 서버
- 배치, ETL, 백그라운드 처리 (Throughput이 더 중요함)
- 대형 힙 (Fragmentation 위험)

### ❓ 대형 힙일수록 Fragmentation이 왜 더 자주 발생할까?
**1. 객체 크기가 다양해짐**
<br>힙이 커질수록 들어오는 객체 크기도 다양해짐 (수 KB ~ 수 MB)
<br>그러면 다양한 크기의 빈 공간이 여러 곳에 흩어지게 되어, free list 관리가 복잡해지고 적절한 공간이 찾기 어려워진다.

### CMS가 효율적으로 동작하는 힙 크기

| **크기**            | **적합성** | **이유**                                                         |
|-------------------|---------|----------------------------------------------------------------|
| ~4GB(작은 힙)        | X       | GC 빈도 높음. 동시성 이점 없음. Serial GC가 더 빠름.                          |
| 4GB ~ 16GB(중간 크기) | O       | 병렬 GC 대비 짧은 STW + Fragmentation 관리 가능. CPU 코어 4개 이상이면 안정적.     |
| 16GB ~ 32GB(큰 힙)  | 주의 필요   | Fragmentation 누적. Concurrent Mode Failure 발생 가능.               |
| 32GB 이상(초대형 힙)    | X       | Fragmentation 누적 심화. Sweep 시간 길어짐. Full GC시 수 초 ~ 수십 초 STW 발생. |


**2. Sweep 비용 증가 -> 제때 청소 불가**
<br>대형 힙일수록 죽은 객체가 흩어져 있는 위치를 탐색하는데 시간이 오래 걸린다.
<br>Concurrent Sweep이 끝나기 전에 Old 영역이 다시 꽉 차면, CMS가 제때 청소를 마치지 못해 Concurrent Mode Failure가 발생한다. 

**3. Fragmentation 누적**
<br>CMS는 Compaction을 수행하지 않기 떄문에, 시간이 지날수록 작은 빈 블록이 계속 쌓인다.
<br>이로 인해 공간은 많아도 연속된 큰 블록이 부족해 새 객체를 할당하지 못하고, STW Full GC로 전환될 수 있다.

## 6. 결론

CMS GC는 Old 영역을 애플리케이션 스레드와 동시에 정리하는 Concurrent 방식의 GC로, 
<br>짧은 STW시간 때문에 응답성이 중요한 시스템에 적합하지만, Fragmentation, 높은 CPU 부하, 복잡한 튜닝이 단점이다.
