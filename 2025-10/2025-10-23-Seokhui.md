### 석희

# Spring 부가 기능은 어떻게 동작할까?

Spring은 **선언적 프로그래밍(Declarative Programming)**을 지원하기 위해 **AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)** 기반의 **프록시(Proxy)** 객체를 생성해 여러 부가기능을 제공.

### 선언적 프로그래밍(Declarative Programming)?

- 프로그래밍 패러다임 중 하나로 무엇(What)을 할 것인지 “목표”를 중심으로 코드를 작성하는 방식.
- **“어떻게(How)”** 할지는 프레임워크/런타임/시스템이 알아서 처리.
- “이 메서드는 트랜잭션 안에서 실행해줘” 혹은 “예외나면 3번 재시도 해줘”와 같이 **“목표”만 선언**
    
    실제 처리 방식은 Spring이 알아서 적용(**e.g. Spring @Transactional, @Retryable)**
    
- **반대로 명령형 프로그래밍(Imperative Programming)**도 있는데 **“어떻게(How)”** 할 것인지 구체적으로 절차(순서)를 명시하여 코드를 작성하는 방식.
- for/while/if 등으로 세부 로직 구현
- 트랜잭션 직접 시작/커밋/롤백 코드 작성

### **AOP(Aspect-Oriented Programming)**

- 소프트웨어의 “관점(aspect)”을 기준으로, 비즈니스 로직(주 로직)과 공통 관심사(로깅, 트랜잭션, 보안, 캐싱 등)를 분리해서 개발하는 방식.


### Cross cutting concerns(횡단 관심사)

- **여러 모듈/계층/비즈니스 로직 전반에 걸쳐 반복적으로 적용되어야 하는 공통 기능**
- 즉, 하나의 모듈/클래스/기능에 국한되지 않고 **애플리케이션의 다양한 부분을 “가로질러” 영향을 미치는 관심사(Concern)**
    
    

### 분리를 하지 않고 개발하게 되면 어떤 문제가 발생할까?

- **코드 중복 & 유지보수 어려움**
    - 각 서비스/컨트롤러/DAO마다 반복해서 같은 로직 삽입 → **중복, 비효율**
    - 하나라도 빠지거나 잘못 적용되면 “전체 정책”이 무너질 수 있음
- **비즈니스 로직 오염**
    - “주 목적”이 아닌 공통 코드를 섞어쓰게 되면 핵심 로직(비즈니스 로직)의 **가독성/집중력 저하**
- **확장성 저하**
    - 요구사항이 바뀔 때, 모든 클래스/메서드 수정 필요 → **변경 비용 급증**

### 이를 해결하기 위한 해결책 AOP(Aspect-Oriented Programming)

- 모든 서비스 메서드에 트랜잭션, 로깅, 권한체크 등 반복적인 코드 중복을 분리하여 한 곳에 모아 관리.

```java
// 1. Aspect 선언
@Aspect
@Component
public class LoggingAspect {

    // 2. Pointcut: com.example.service 하위 모든 메서드
    @Pointcut("execution(* com.example.service..*(..))")
    public void serviceMethods() {}

    // 3. Advice: 메서드 실행 전(before)
    @Before("serviceMethods()")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("[Before] 메서드 호출: " + joinPoint.getSignature());
    }

    // 4. Advice: 메서드 실행 후(after)
    @After("serviceMethods()")
    public void logAfter(JoinPoint joinPoint) {
        System.out.println("[After] 메서드 호출 종료: " + joinPoint.getSignature());
    }

    // 5. Advice: 메서드 실행 전/후 전체(Around)
    @Around("serviceMethods()")
    public Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("[Around-전] " + joinPoint.getSignature());
        Object result = joinPoint.proceed();  // 실제 대상 메서드 호출
        System.out.println("[Around-후] " + joinPoint.getSignature());
        return result;
    }
}

```

- 로깅/트랜잭션/보안 등 공통 기능을 별도의 “Aspect(관점)”로 구현하고, **실행 시점에 Proxy/Advice로**
    
    **“자동 삽입”**
    
- 비즈니스 코드에서는 본래 목적에만 집중해서 **유지보수성과 확장성 모두 크게 개선**
- 실제 서비스/컨트롤러 코드는 전혀 수정하지 않아도 모든 곳에 공통 로그가 자동 적용

### 1. **Advice**

- **실제로 실행될 부가기능 코드(로깅, 트랜잭션 등)**
- 언제 실행되는가에 따라 종류가 나뉨
    - `@Before`: 대상 메서드 “전”에 실행
    - `@After`: 대상 메서드 “후”에 실행(성공/실패 상관없이)
    - `@AfterReturning`: 정상 종료 후 실행
    - `@AfterThrowing`: 예외 발생 시 실행
    - `@Around`: 메서드 실행 “전/후 전체”를 감쌈 (가장 강력/자주 씀)

### 2. **JoinPoint**

- **Advice가 “끼어들 수 있는 실행 지점”**
    - 메서드 호출, 객체 생성, 필드 접근 등(스프링에서는 거의 메서드 호출)
- Advice 코드에서 `JoinPoint`/`ProceedingJoinPoint`로 실행 대상 정보에 접근 가능

### 3. **Pointcut**

- **Advice를 적용할 구체적 위치/조건을 명시**
    - “어떤 클래스/메서드에 Advice를 걸 것인가?”
- 예시:
    - `execution(* com.example.service.*.*(..))`
        
        → com.example.service 패키지 내 모든 메서드
        
    - `@annotation(MyCustomLog)`
        
        → 커스텀 어노테이션이 붙은 메서드만
        

## Proxy

- 실제 객체(Real Subject) 대신 클라이언트와 실제 객체 사이에 위치해 메서드 호출을 **중개/대리**하는
    
    “대리 객체”
    

## **Spring에서 Proxy**

- **AOP, DI, 부가기능** 제공을 위한 **핵심 메커니즘**
- 실제 Bean(서비스, 리포지토리 등)을 프록시 객체로 감싸서 클라이언트(= 다른 Bean, 컨트롤러 등)가 메서드를 호출하면 프록시가 메서드 호출을 **가로채서(Intercept)** 필요한 부가기능 (@Retryable,@Transactional, @Cacheable, @Async 등)을 삽입 그 다음 실제 객체에 위임

### 1. Proxy**는 누가, 언제 만드는가?**

- **프록시 객체는 개발자가 직접 만드는 게 아니라, Spring 프레임워크(컨테이너)가 Bean을 등록할 때 자동으로 생성.**
- 어떤 방식(JDK/CGLIB)으로 만들지는 Spring의 AOP 프레임워크(예: ProxyFactoryBean, BeanPostProcessor)**가 로직을 가지고 결정.

### 2. Proxy **생성 로직: Spring의 내부 프로세스**

- **Spring이 @Service/@Component 등의 빈을 생성할 때**
    1. **AOP 부가기능이 필요한지 감지**
        
        (예: @Transactional, @Retryable, @Cacheable 등 Aspect/Advice가 필요하면)
        
    2. **Proxy 생성 전략 결정**
        - 대상 클래스가 **인터페이스를 구현**하고 있으면 → **JDK 동적 프록시** 사용
        - **인터페이스가 없으면** → **CGLIB 프록시** 사용
        - `proxyTargetClass=true` 설정 시 무조건 CGLIB (인터페이스로 구현되어 있어도)
    3. **Proxy 객체 생성**
        - 실제 클래스 대신 Proxy 객체가 Spring 컨테이너에 Bean으로 등록됨
    4. **외부에서 Bean을 주입/호출할 때 Proxy가 동작**


### 3. **JDK 동적** Proxy **- 어떻게 작동하는가?**

- **자바 표준 API**인 `java.lang.reflect.Proxy`가 런타임에 새로운 클래스를 “동적으로” 생성(메모리상에서 바이트코드를 만들어서 클래스로 로딩)
- **조건:**
    - 반드시 인터페이스 기반
    - 프록시 객체의 타입은 “인터페이스 타입”
- **실행 흐름:**
    1. 클라이언트(예: Controller)가 `myService`를 호출
    2. 실제로는 `myService` 인터페이스의 Proxy 객체가 대신 호출을 받음
    3. Proxy가 MethodInvocationHandler의 코드를 실행
    4. 부가기능(Advice) 삽입 후, 진짜 구현체에 위임

## 4. **CGLIB** Proxy **- 어떻게 작동하는가?**

- *CGLIB(라이브러리)**은
    - 구체 클래스(Concrete Class)를 “상속”하는 “서브클래스”를
        
        런타임에 **직접 바이트코드 생성(ASM을 이용)** → JVM에 클래스 로딩
        
- **조건:**
    - 인터페이스가 없거나, proxyTargetClass=true
    - 클래스/메서드가 final이면 상속이 불가하므로 CGLIB도 불가
- **실행 흐름:**
    1. Spring이 원본 클래스의 서브클래스를 동적으로 생성
    2. 해당 서브클래스가 메서드를 오버라이드해서 부가기능(Advice)을 삽입
    3. 클라이언트가 Bean을 호출하면, 실제로는 이 CGLIB Proxy(서브클래스)가 호출을 받아서 동작

## 5. 정리

- Spring은 부가기능이 필요한 Bean(예: @Service, @Component)을 등록할 때 **프록시 객체**(Proxy Bean)를 생성.
- 이 프록시는 public 메서드가 **외부(다른 Bean 등)에서 호출될 때** "Advice"라 불리는 부가기능 로직(@Retryable, @Transactional 등)을 중간에 삽입.
- 예외가 발생하거나 특정 조건이 맞을 때
    
    → Advice가 개입하여, 트랜잭션 롤백/재시도/캐싱 등 부가기능을 동작시킴.
    


## 주의사항

- **@Retryable 등 AOP 기반 부가기능은 반드시 public 메서드에 붙여야 함**
- Bean 외부에서, 반드시 DI(Spring 주입)를 통해 호출해야 프록시를 경유해서 부가기능이 적용됨
- 직접 new 연산자 등으로 객체 생성해서 쓰면 부가기능 미적용
- private, protected, default 메서드는 모두 미적용
- public 메서드/클래스, Spring DI를 준수.

# 비슷하게 동작하는 것들은 어떤게 있을까?

Spring의 여러 부가기능이 **동일한 AOP/프록시 구조**로 동작.

- **@Transactional**: 트랜잭션 시작/커밋/롤백 관리
- **@Cacheable, @CachePut, @CacheEvict**: 캐싱 제어
- **@Async**: 비동기 실행
- **@Secured, @PreAuthorize**: 권한 체크
- **@Scheduled**: 스케줄링 실행(단, 이건 별도 스케줄러에서 호출)
- **@EventListener**: 이벤트 리스너(내부적으로 프록시/Advice 동작)

이 모든 부가기능은

- public 메서드
- 외부(다른 Bean)에서 호출
- Spring DI/프록시 경유를 전제로만 정상 동작.
