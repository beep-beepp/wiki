# ZGC
ZGC는 Z Garbage Collector는 Java의 ultra-low-latency GC이다.
<br>STW 시간을 수 ms 단위로 유지하기 위해 설계된 Concurrent 방식의 Garbage Collector이다.

## 1. 목적
1. Pause Time 최소화
   - 기존 GC(G1, CMS, Parallel 등)는 STW 구간이 힙 크기에 비례해서 늘어났다. 
   - ZGC는 힙 크기와 무관하게, Pause time을 10ms 이하 수준으로 유지할 수 있다.
   - 즉, 4GB든 4TB든 Pause time은 거의 일정하다.
2. Large Heap Scalability
   - 현대 서버는 수백 GB ~ TB 단위의 메모리를 사용한다.
   - ZGC는 최대 16TB 힙 메모리까지 지원하며, 대규모 JVM 애플리케이션에서도 안정적으로 동작한다.
3. High Throughput
   - 대부분의 저지연 GC는 Throughput을 희생하지만, ZGC는 GC 작업 대부분을 Concurrent로 수행하기 때문에 Throughput 손실이 거의 없다.
   - 대부분의 작업(Mark, Relocation 등)을 애플리케이션 스레드와 병렬로 수행한다.
4. Predictable Performance
   - GC로 인한 긴 멈춤이 없어, 응답 시간이 일정하고 예측 가능한 시스템을 만들 수 있다.
   - 특히 실시간 트랜잭션, 서버 애플리케이션, 금융 시스템에서 강점을 보인다.

## 2. 왜 나왔는가?
1.**기존 GC의 구조적 한계**
- G1, CMS, Parallel GC 같은 기존 GC들은 STW 구간이 길다.
- 이 Pause 구간은 힙 크기에 비례해서 증가한다.
  <br>예를 들어 힙이 4GB면 STW가 수십 밀리초지만, 200GB면 수 초까지도 갈 수 있다.
- 대규모 메모리를 쓰는 현대 애플리케이션에서는 이런 "긴 Pause time"이 서비스 장애로 직결된다.
  <br>예: 거래 시스템 응답 지연, 스트리밍 끊김, API timeout 등

즉, 기존 GC로는 대용량 힙 + 짧은 Pause time을 동시에 만족시킬 수 없었어.

2. **현대 시스템 환경 변화**
- 서버의 RAM 용량이 수백 GB ~ TB 단위로 커졌다.
- Java 기반의 대규모 실시간 서비스(예: 결제, 게임 서버, 광고, 거래소 등)가 급격히 늘어났다.
- 이런 환경에서는 수 밀리초 단위의 짧은 Pause time이 절대적으로 필요하다.

ZGC는 이런 시대적 요구에 맞춰 힙 크기와 관계없는 짧은 Pause time을 목표로 등장했다.

## 3. 작동 방식

ZGC는 Region 기반 GC 모델을 사용한다. 
- 힙을 동일한 크기의 Region으로 나누어, 필요한 Region만 선택적으로 수거(Partial GC)한다.
- 모든 단계가 가능한 한 Concurrent로 수행되어 GC 중에도 애플리케이션이 거의 멈추지 않는다.

### Region 구조
- 힙은 수 MB 단위(보통 2MB ~ 16MB)의 Region으로 나뉜다.
- 각 Region은 다음 중 하나의 상태를 가진다.

| 상태             | 설명                              |
|----------------|---------------------------------|
| Active Region  | 현재 객체들이 존재하는 활성 상태의 영역          |
| Garbage Region | 모든 객체가 수거되어 비워진 영역              |
| Relocation Set | Compaction 대상 Region (객체 이동 예정) |

GC는 전체 힙이 아닌, Relocation Set으로 선택된 Region만 대상으로 동작한다.

### 주요 단계

| 단계                    | 동시여부   | 설명                                                                                 |
|-----------------------|--------|------------------------------------------------------------------------------------|
| Initial Mark          | X(STW) | GC Root에서 직접 참조하는 객체를 Mark. 매우 짧은 STW 발생.                                          |
| Concurrent Mark       | O      | 애플리케이션이 실행되는 동안, 살아있는 객체를 탐색하며 Mark. Colored Pointer를 이요해 객체의 상태를 포인터에 직접 인코딩함.    |
| Remark                | X(STW) | Concurrent Mark 중 변경된 참조를 보정하여 최종 Mark 완료함. STW는 수 ms 수준.                          |
| Prepare Relocation    | O      | Compaction 대상 Region(=Relocation Set)을 선정하고, 객체의 새 위치를 계산함.                        |
| Concurrent Relocation | O      | 살아있는 객체를 새로운 Region으로 복사함. 이때 Load Barrier를 통해 참조가 자동으로 최신 주소로 갱신됨.                |
| Concurrent Remap      | O      | 모든 참조가 새로운 주소로 갱신되면, 이전 Region을 Garbage로 표시하고 해제함. <br/>다음 GC 사이클을 위한 내부 자료구조 초기화. |

## 4. 장단점

## 5. 언제 쓰면 좋을까?

## 6. 결론
