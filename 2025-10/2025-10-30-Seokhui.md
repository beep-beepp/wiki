## Spring 에서는 왜 객체를 직접 사용하지 않고 왜 프록시를 사용할까?

- 스프링에서는 자주 사용하는 것들에 대해 대리 객체를 두고 거기에 비즈니스 로직과 부가기능 로직을 분리하기 위해서 프록시라는 걸 둔다.

**만약 프록시가 없고 객체를 직접 사용한다면?** 

- 트랜잭션, 캐싱등의 로직들을 비즈니스 로직에 한땀 한땀 모두 구현해 줘야 한다. (비즈니스 로직 오염)

- **관심사의 분리(Separation of Concerns)**
    - 비즈니스 로직: 실제로 구현하고 싶은 핵심 기능
    - 부가 기능: 트랜잭션, 로깅, 보안, 캐싱 등 (횡단 관심사, Cross-cutting Concerns)
- **프록시의 역할**
    - 실제 객체를 감싸서(Wrap)
    - 메서드 호출을 가로채서(Intercept)
    - 부가 기능을 실행하고
    - 실제 객체의 메서드를 호출

반복되는 기술적인 코드는 프레임워크가 처리하고, 개발자는 비즈니스 로직에만 집중을 위해.


# 트랜잭션 전파 (Transaction Propagation)
트랜잭션 전파는 **이미 트랜잭션이 진행중인 상황에서 추가로 트랜잭션을 시작할 때, 기존 트랜잭션을 어떻게 처리할지 결정하는 정책**이다.

### 실무 상황 예시

```java
@Transactional
public void 회원가입(User user) {
    userRepository.save(user);           *// 회원 저장*
    포인트지급(user);                     *// 포인트 지급*
    이메일발송(user);                     *// 환영 이메일*
}

@Transactional
public void 포인트지급(User user) {
    pointRepository.save(new Point(user, 1000));
}

@Transactional
public void 이메일발송(User user) {
    emailRepository.save(new Email(user));
}
```

**질문: 포인트지급()이나 이메일발송()에서 예외가 발생하면?**

- 회원가입도 롤백되나?
- 각각 독립적인 트랜잭션인가?
- 어디까지 롤백되나?

→ 이걸 결정하는 게 **트랜잭션 전파 속성**



## 2. 주요 전파 타입 (필수 3가지)

### (1) REQUIRED (기본값) 

**"진행중인 트랜잭션이 있으면 참여, 없으면 새로 시작"**

```java
@Transactional  *// propagation = Propagation.REQUIRED (기본값)*
public void 외부메서드() {
    내부메서드A();
    내부메서드B();
}

@Transactional
public void 내부메서드A() {
    *// 외부메서드의 트랜잭션에 참여*
}

@Transactional
public void 내부메서드B() {
    *// 외부메서드의 트랜잭션에 참여*
}
```

**동작:**
```
[외부메서드 트랜잭션 시작]
    ↓
[내부메서드A 실행] ← 같은 트랜잭션
    ↓
[내부메서드B 실행] ← 같은 트랜잭션
    ↓
[전체 커밋 또는 롤백]
```

**특징:**

- 하나의 물리적 트랜잭션 사용
- 어느 하나라도 실패하면 전체 롤백
- 가장 일반적인 케이스 (기본값인 이유)

**실무 예시:**

```java
@Transactional
public void 주문처리(Order order) {
    orderRepository.save(order);      *// 주문 저장*
    재고차감(order);                   *// 재고 차감*
    포인트차감(order);                 *// 포인트 차감*
}
*// → 하나라도 실패하면 전체 롤백 (원자성 보장)*
```

---

### (2) REQUIRES_NEW

**"무조건 새로운 트랜잭션 시작, 기존 트랜잭션은 보류"**

```java
@Transactional
public void 외부메서드() {
    내부메서드A();
    내부메서드B();
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void 내부메서드A() {
    *// 새로운 독립적인 트랜잭션*
}
```

**동작:**
```
[외부 트랜잭션 시작]
    ↓
[외부 트랜잭션 보류(suspend)]
    ↓
    [내부 트랜잭션 시작]
    [내부 트랜잭션 커밋/롤백]  ← 독립적으로 커밋
    ↓
[외부 트랜잭션 재개(resume)]
    ↓
[외부 트랜잭션 커밋/롤백]
```

**특징:**

- 완전히 독립된 물리적 트랜잭션
- 내부 트랜잭션의 롤백이 외부에 영향 없음
- 외부 트랜잭션의 롤백이 내부에 영향 없음

**실무 예시:**

```java
@Transactional
public void 회원가입(User user) {
    userRepository.save(user);
    
    try {
        로그저장(user);  *// 로그 저장 실패해도 회원가입은 성공*
    } catch (Exception e) {
        log.error("로그 저장 실패", e);
    }
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void 로그저장(User user) {
    auditLogRepository.save(new AuditLog(user));
    *// 여기서 예외 발생해도 회원가입은 커밋됨*
}
```

**언제 사용?**

- 로그/감사 기록 (실패해도 본 작업은 성공해야 함)
- 알림 발송 (실패해도 본 작업은 성공)
- 통계/집계 (부가 작업)

---

### (3) NESTED

**"중첩 트랜잭션 사용, 부모는 자식에게 영향 주지만 자식은 부모에게 영향 안 줌"**

```java
@Transactional
public void 외부메서드() {
    내부메서드A();  *// 실패해도 외부는 계속 진행 가능*
    내부메서드B();
}

@Transactional(propagation = Propagation.NESTED)
public void 내부메서드A() {
    *// 중첩 트랜잭션 (Savepoint 사용)*
}
```

**동작:**
```
[외부 트랜잭션 시작]
    ↓
    [Savepoint 생성]
    [내부 로직 실행]
    [성공 시 Savepoint 유지, 실패 시 Savepoint로 롤백]
    ↓
[외부 트랜잭션 커밋]
```

**특징:**
- Savepoint 기반 (JDBC Savepoint)
- 외부가 롤백되면 내부도 함께 롤백
- 내부가 롤백되어도 외부는 영향 없음 (catch 필요)
- JPA에서는 지원 안 함 (주의!)

**실무 예시:**

```java
@Transactional
public void 주문처리(Order order) {
    orderRepository.save(order);
    
    try {
        쿠폰적용(order);  *// 쿠폰 적용 실패해도 주문은 진행*
    } catch (Exception e) {
        log.warn("쿠폰 적용 실패", e);
    }
}

@Transactional(propagation = Propagation.NESTED)
public void 쿠폰적용(Order order) {
    *// 실패 시 여기만 롤백*
}
```

---

## 주의사항

### (1) Self-Invocation 문제

```java
@Service
public class UserService {
    
    @Transactional
    public void 외부메서드() {
        내부메서드();  *// ❌ 프록시를 거치지 않음!*
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void 내부메서드() {
        *// REQUIRES_NEW가 작동 안 함!*
    }
}
```

**왜 안 될까?**

```java
*// 실제로 이렇게 호출됨*
UserService proxy = context.getBean(UserService.class);
proxy.외부메서드();  *// 프록시를 통과*
    ↓
this.내부메서드();   *// 내부에서는 this로 직접 호출! (프록시 X)*
```

**해결 방법:**

**방법 1: 별도 클래스 분리 (가장 추천)**

```java
@Service
public class UserService {
    @Autowired
    private InternalService internalService;
    
    @Transactional
    public void 외부메서드() {
        internalService.내부메서드();  *// ✅ 프록시 통과*
    }
}

@Service
public class InternalService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void 내부메서드() {
        *// 정상 작동*
    }
}
```

**방법 2: Self Injection**

```java
@Service
public class UserService {
    @Autowired
    private UserService self;  *// 자기 자신 주입*
    
    @Transactional
    public void 외부메서드() {
        self.내부메서드();  *// ✅ 프록시 통과*
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void 내부메서드() {
        *// 정상 작동*
    }
}
```

---

### (2) Checked Exception vs Unchecked Exception

```java
@Transactional
public void 메서드A() throws Exception {  *// Checked Exception*
    throw new Exception();  *// ❌ 롤백 안 됨!*
}

@Transactional
public void 메서드B() {
    throw new RuntimeException();  *// ✅ 롤백됨!*
}
```

**Spring 기본 정책:**

- **RuntimeException (Unchecked)**: 롤백
- **Exception (Checked)**: 롤백 안 함 (커밋)

**해결 방법:**

```java
@Transactional(rollbackFor = Exception.class)
public void 메서드() throws Exception {
    throw new Exception();  *// ✅ 이제 롤백됨*
}
```

---

### (3) NESTED는 JPA에서 지원 안 함

```java
@Transactional(propagation = Propagation.NESTED)
public void 메서드() {
    *// JPA 사용 시 예외 발생:// JpaDialect does not support savepoints*
}
```

**이유:**

- NESTED는 JDBC Savepoint 기반
- JPA는 영속성 컨텍스트 관리 때문에 Savepoint 지원 안 함

**대안:**

- REQUIRES_NEW 사용
- 또는 순수 JDBC 사용

---

## 5. 실전 패턴

### 패턴 1: 원자성 보장 (REQUIRED)

```java
@Transactional
public void 주문처리(Order order) {
    주문저장(order);      *// 같은 트랜잭션*
    재고차감(order);      *// 같은 트랜잭션*
    결제처리(order);      *// 같은 트랜잭션// 하나라도 실패하면 전체 롤백*
}
```

### 패턴 2: 독립적인 부가 작업 (REQUIRES_NEW)

```java
@Transactional
public void 주문처리(Order order) {
    주문저장(order);
    
    try {
        알림발송(order);  *// 실패해도 주문은 성공*
    } catch (Exception e) {
        log.error("알림 발송 실패", e);
    }
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void 알림발송(Order order) {
    *// 독립적인 트랜잭션*
}
```

### 패턴 3: 조회 성능 최적화 (readOnly)

```java
@Transactional(readOnly = true)
public List<User> 사용자목록조회() {
    return userRepository.findAll();
    *// Dirty Checking 안 함 → 성능 향상// DB에 따라 읽기 전용 최적화*
}
```

## 핵심 요약

### 기억해야 할 3가지

1. **REQUIRED**: 기본값, 하나의 트랜잭션 공유
2. **REQUIRES_NEW**: 완전히 독립된 새 트랜잭션
3. **Self-Invocation**: 같은 클래스 내부 호출은 전파 속성 무시됨!

### 실무 체크리스트

- [ ]  트랜잭션 경계를 명확히 설정했는가?
- [ ]  Self-Invocation 발생하지 않는가?
- [ ]  Checked Exception 처리는 적절한가?
- [ ]  readOnly는 조회에만 사용했는가?
- [ ]  독립적인 작업은 REQUIRES_NEW 사용했는가?