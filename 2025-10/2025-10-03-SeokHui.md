### 석희

# Feature Flag


 새로운 기능을 프로덕션에 배포할 때 이런 고민 해보신 적 있나?

*"혹시 버그 있으면 어쩌지? 롤백하려면 또 시간 걸리는데...""일부 사용자에게만 먼저 테스트해볼 수 없을까?""문제 생기면 즉시 끌 수 있으면 좋겠는데..."*

Feature Flag가 바로 이런 고민들을 해결해주는 기술.


## 📌 1. Feature Flag란?

### 1-1. 정의

Feature Flag는 한마디로 코드를 재배포하지 않고도 특정 기능을 켜고 끌 수 있는 소프트웨어 스위치.

일상의 비유로 설명드리면, 전등 스위치를 생각하면 됨.

- 전등은 이미 천장에 설치되어 있다
- 스위치로 언제든 켜고 끌 수 있다
- 전등을 교체할 필요가 없다

Feature Flag도 마찬가지입니다. 기능은 이미 코드에 존재하고, 설정만 바꿔서 on/off를 제어.

### 1-2. 간단한 예시

```java
public void processPayment(Order order) {
    
    if (featureFlag.isEnabled("new-payment")) {
        newPaymentService.process(order);  *// 새 기능*
    } else {
        oldPaymentService.process(order);  *// 기존 기능*
    }
}
```

이 코드에는 새 결제 로직과 기존 결제 로직이 **둘 다 존재함**.
플래그 설정에 따라 **어느 쪽을 실행할지만 결정**.

여기서 중요한 건, **코드 변경이나 재배포 없이** 플래그 설정만 바꾸면 즉시 기능을 켜고 끌 수 있다는 점이다.


## 📌 2. 왜 사용할까?

### 2-1. 실제 현장의 문제

### 문제 1: 배포가 두렵다

상황을 하나 가정해보자.

새로운 추천 알고리즘을 개발했는데 이걸 바로 전체 사용자에게 배포하기엔 불안함. 혹시 버그가 있을 수도 있고, 성능 문제가 있을 수도 있으니까.

그렇다고 테스트 서버에서만 돌리자니, 실제 사용자 반응도 필요.

### 문제 2: 롤백이 느리다

실제 시나리오를 하나 봐보자.

`23:00 - 새 결제 시스템 배포
23:30 - 버그 발견! 결제 실패율 급증
23:35 - 긴급 회의, 롤백 결정
23:40 - 이전 버전 재배포 시작
23:50 - 배포 완료, 정상화`

20분간 서비스 장애가 발생. 그 사이에 고객 이탈, 매출 손실이 발생.

재배포에는 빌드 시간, 배포 시간, 서버 재시작 시간이 모두 필요. 급한 상황에서 20분은 너무 길다.

### 2-2. Feature Flag의 해결책

### 해결 1: 점진적으로 기능 활성화

Feature Flag를 쓰면 이렇게 할 수 있다.

1단계: 10% 사용자에게만 새 기능 노출 24시간 모니터링 → 에러율, 성능 체크

2단계: 문제 없으면 50%로 확대 24시간 모니터링

3단계: 최종 100% 적용

만약 1단계에서 문제가 발견되면? 플래그만 끄면 됨. 10%의 사용자만 영향받고, 재배포도 필요 없다.

여기서 중요한 건, 서버나 트래픽을 건드리는 게 아니라 **사용자별로 다른 기능을 보여주는 것**. 

모든 서버는 같은 코드를 실행하고 있고, 단지 사용자 ID에 따라 실행 경로만 달라진다.

### 해결 2: 초고속 롤백

아까 그 시나리오를 Feature Flag로 다시 보자.

`23:00 - 새 결제 시스템 배포 (플래그 OFF 상태)
23:10 - 플래그 10% 활성화, 모니터링
23:30 - 버그 발견!
23:31 - 관리자 대시보드에서 플래그 OFF 클릭
23:32 - 모든 서버에 즉시 반영, 정상화`

2분 만에 복구됨. 재배포가 없으니까.

### 해결 3: A/B 테스트

Feature Flag를 쓰면 간단.

```java
*// 사용자를 자동으로 두 그룹으로 분리*
int bucket = userId.hashCode() % 100;

if (bucket < 50) {
    return newUI.render();  *// A그룹*
} else {
    return oldUI.render();  *// B그룹*
}
```

사용자 ID를 해싱해서 0~99 사이 숫자로 만들고, 50 미만이면 A그룹, 이상이면 B그룹으로 자동 분류됨.

중요한 건 **같은 사용자는 항상 같은 그룹**에 속한다는 점입니다. 오늘 A그룹이었던 사람이 내일 B그룹으로 바뀌지 않습니다. 해시 함수의 특성 덕분.

7일간 데이터를 모아서 전환율을 비교하고, 성과가 좋은 쪽을 선택하면 됨.


## 📌 3. Feature Flag의 두 가지 유형

Feature Flag는 사용 목적에 따라 크게 두 가지로 나뉜다.

### 3-1. Release Flag (릴리스 플래그)

### 목적

새로운 기능을 **안전하게** 배포하기 위한 플래그.

### 특징

- 실시간성이 덜 중요. 몇 초에서 몇 분 정도 지연은 괜찮다.
- 점진적으로 배포 범위를 확대. 10% → 50% → 100% 이런 식.
- 생명주기가 있다. 며칠에서 몇 주 정도 유지하다가, 배포 완료되면 제거.

### 사용 사례 1: 새 기능 출시

소셜 로그인 기능을 개발했다고 가정.

`1주차: 10% 사용자에게만 노출
       버그 없는지 확인, 전환율 체크

2주차: 50%로 확대
       서버 부하 체크, 성능 모니터링

3주차: 100% 배포
       안정화 확인 후 플래그 제거`

### 사용 사례 2: A/B 테스트

상품 추천 알고리즘을 두 가지 개발.

- A그룹: 협업 필터링 알고리즘
- B그룹: 딥러닝 알고리즘

일주일간 클릭률, 구매 전환율, 체류 시간을 측정.
결과적으로 B그룹이 전환율이 15% 높게 나왔다면, 딥러닝 알고리즘을 전체에 적용하면 된다.

---

### 3-2. Kill Switch (킬 스위치)

### 목적

긴급 상황에서 **지금 당장** 기능을 꺼야 할 때 사용하는 플래그.

### 특징

- 실시간성이 매우 중요. 1초 이내 반영이 필요.
- 긴급 대응용. 평소엔 대기하고 있다가, 위기 상황에서만 사용.
- 생명주기가 영구적. 안전장치로 항상 유지.

### 사용 사례 1: 외부 시스템 장애 대응

실제 시나리오를 보자.

`17:00 - 메인 결제 PG사 장애 발생
17:01 - Kill Switch 활성화
17:02 - 모든 서버가 서브 PG로 자동 전환
        결제가 계속 처리됨

20:00 - 메인 PG 복구 확인
20:01 - Kill Switch 비활성화
20:02 - 메인 PG로 복귀`

만약 재배포 방식이었다면 최소 10~20분은 걸렸을 듯.. 그 사이 얼마나 많은 결제가 실패했을까?

### 사용 사례 2: 트래픽 폭주 대응

TV 광고가 나간 후 갑자기 트래픽이 몰렸다.

서버가 버티기 힘들 것 같으면, Kill Switch로 무거운 추천 엔진을 비활성화하고 캐시된 인기 상품만 보여줌.

핵심 기능인 주문과 결제는 보호하면서, 부가 기능은 일시적으로 끔.

