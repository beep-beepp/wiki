### 석희 
- 해당 회차 개인 사정으로 준비를 못해 발표했던 내용이라도 첨부하겠습니다.

## 다형성(Polymorphism)
- 하나의 인터페이스나 부모 클래스 타입으로 여러 다른 구현체들을 동일하게 다룰 수 있는 능력

## SOLID 원칙

### Single Responsibility Principle (단일 책임 원칙)
**개념**: 한 클래스는 하나의 책임만 가져야 한다.

### Open/Closed Principle (개방-폐쇄 원칙)
**개념**: 확장에는 열려있고 수정에는 닫혀있어야 한다.

### Liskov Substitution Principle (리스코프 치환 원칙)
**개념**: 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체해도 프로그램의 동작이 변하지 않아야 한다.
즉 부모 클래스로 작성된 코드가 자식 클래스 객체로도 정상 동작해야 함.

### Interface Segregation Principle (인터페이스 분리 원칙)
**개념**: 클라이언트는 사용하지 않는 메서드에 의존하면 안 된다.

### Dependency Inversion Principle (의존성 역전 원칙)

**개념**:

1. 상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.
2. 추상화는 구체화에 의존해서는 안 되며, 구체화는 추상화에 의존해야 한다.

**→ 변경에 대한 안정성** 때문


# Spring Boot 자동 구성 (Auto Configuration)

## Spring 없이 또는 Spring Boot 없이의 문제점과 개선사항

### 기존 Spring Framework의 한계

**Spring Framework만 사용할 때의 번거로운 작업들:**

- **수동 빈 등록의 복잡성**: 데이터베이스 연결을 위해서는 `DataSource`, `JdbcTemplate`, `TransactionManager`를 매번 수동으로 설정해야 했음
- **반복적인 설정 코드**: 프로젝트마다 동일한 인프라 빈들을 반복적으로 등록하는 boilerplate 코드 작성 필요
- **의존성 관리의 어려움**: 라이브러리 간 버전 호환성을 개발자가 직접 관리해야 함
- 톰캣도 별도로 설치하고 구성했어야함

이렇듯 Spring 프로젝트는 초기에 라이브러리나 의존성들에 대해 세팅하는데, 시간이 오래 걸리게 됨.

### Spring Boot 자동 구성의 개선점

**자동 구성의 핵심 가치:**

- **Convention over Configuration**: 일반적인 설정을 자동으로 제공하여 개발자는 비즈니스 로직에 집중
- **빠른 개발 시작**: 복잡한 설정 없이 `@SpringBootApplication` 하나로 애플리케이션 실행 가능
- **조건부 자동 설정**: 클래스패스에 특정 라이브러리가 있을 때만 관련 빈을 자동 등록
- 의존성만 추가하면 해당 스프링부트 프로젝트 버전에 맞는 라이브러리들을 모두 받아옴


# Feature Flag

 새로운 기능을 프로덕션에 배포할 때 이런 고민 해보신 적 있나?

*"혹시 버그 있으면 어쩌지? 롤백하려면 또 시간 걸리는데...""일부 사용자에게만 먼저 테스트해볼 수 없을까?""문제 생기면 즉시 끌 수 있으면 좋겠는데..."*

Feature Flag가 바로 이런 고민들을 해결해주는 기술.

## Feature Flag의 두 가지 유형

Feature Flag는 사용 목적에 따라 크게 두 가지로 나뉜다.

### 3-1. Release Flag (릴리스 플래그)

### 목적

새로운 기능을 **안전하게** 배포하기 위한 플래그.

### 특징

- 실시간성이 덜 중요. 몇 초에서 몇 분 정도 지연은 괜찮다.
- 점진적으로 배포 범위를 확대. 10% → 50% → 100% 이런 식.
- 생명주기가 있다. 며칠에서 몇 주 정도 유지하다가, 배포 완료되면 제거.

### 사용 사례 1: 새 기능 출시

소셜 로그인 기능을 개발했다고 가정.
`1주차: 10% 사용자에게만 노출
       버그 없는지 확인, 전환율 체크

2주차: 50%로 확대
       서버 부하 체크, 성능 모니터링

3주차: 100% 배포
       안정화 확인 후 플래그 제거`

### 사용 사례 2: A/B 테스트

상품 추천 알고리즘을 두 가지 개발.

- A그룹: 협업 필터링 알고리즘
- B그룹: 딥러닝 알고리즘

일주일간 클릭률, 구매 전환율, 체류 시간을 측정.
결과적으로 B그룹이 전환율이 15% 높게 나왔다면, 딥러닝 알고리즘을 전체에 적용하면 된다.

---

### 3-2. Kill Switch (킬 스위치)

### 목적

긴급 상황에서 **지금 당장** 기능을 꺼야 할 때 사용하는 플래그.

### 특징

- 실시간성이 매우 중요. 1초 이내 반영이 필요.
- 긴급 대응용. 평소엔 대기하고 있다가, 위기 상황에서만 사용.
- 생명주기가 영구적. 안전장치로 항상 유지.

### 사용 사례 1: 외부 시스템 장애 대응

실제 시나리오를 보자.

`17:00 - 메인 결제 PG사 장애 발생
17:01 - Kill Switch 활성화
17:02 - 모든 서버가 서브 PG로 자동 전환
        결제가 계속 처리됨

20:00 - 메인 PG 복구 확인
20:01 - Kill Switch 비활성화
20:02 - 메인 PG로 복귀`

만약 재배포 방식이었다면 최소 10~20분은 걸렸을 듯.. 그 사이 얼마나 많은 결제가 실패했을까?

### 사용 사례 2: 트래픽 폭주 대응

TV 광고가 나간 후 갑자기 트래픽이 몰렸다.

서버가 버티기 힘들 것 같으면, Kill Switch로 무거운 추천 엔진을 비활성화하고 캐시된 인기 상품만 보여줌.

핵심 기능인 주문과 결제는 보호하면서, 부가 기능은 일시적으로 끔.