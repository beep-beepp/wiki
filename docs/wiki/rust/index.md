---
title: "Rust"
permalink: /rust/
has_children: true
nav_order: 4
---

rust 공식문서: https://doc.rust-lang.org/book/title-page.html

<details>
<summary>rust 게임 개발자 회고 블로그(회의적 시각): https://loglog.games/blog/leaving-rust-gamedev/</summary>

<b>"Rust에 익숙해지면 이 문제들은 다 사라진다"</b><br>
<br>
Rust를 배우는 과정은 흥미롭다.<br>
처음에는 "이건 나만 겪는 특수한 문제 아닌가?"라고 느끼는 일들이 많지만, 시간이 지나면 몇 가지 <b>보편적인 패턴</b>이 있다는 걸 깨닫게 된다. 그리고 Rust를 배우는 모든 사람이 결국 다시 발견하고 체화해야 하는 것들이다.<br>
<br>
예를 들면:<br>
<br>
* `&str` vs `String`<br>
* `.iter()` vs `.into_iter()`<br>
* 부분 차용(partial borrow)이 추상화와 충돌하는 문제<br>
<br>
이런 것들은 분명 <b>학습 비용</b>에 가깝다.<br>
충분한 경험이 쌓이면, 이런 문제들을 거의 생각하지 않고도 예측하며 생산적으로 코드를 작성할 수 있다.<br>
<br>
실제로 나는 Rust로 유틸리티나 CLI 도구를 만들 때는 매우 즐거웠다.<br>
짧은 코드가 아닌 이상, Python보다 더 생산적이라고 느낀 순간도 많았다.<br>
<br>
<b>커뮤니티의 지배적인 태도</b><br>
<br>
하지만 Rust 커뮤니티에는 매우 강한 흐름이 있다.<br>
<br>
누군가 Rust의 <b>언어 차원에서의 근본적인 문제</b>를 이야기하면, 돌아오는 답은 거의 항상 같다.<br>
<br>
> "아직 Rust를 충분히 이해하지 못해서 그래요.<br>
> 익숙해지면 다 해결됩니다."<br>
<br>
이건 Rust만의 문제가 아니다.<br>
<br>
* ECS를 쓰면 → "ECS를 아직 제대로 이해 못해서 그래"<br>
* Bevy를 쓰면 → "Bevy 철학을 아직 체득 못해서 그래"<br>
* GUI 프레임워크를 쓰면 → "올바른 패턴을 아직 몰라서 그래"<br>
<br>
문제는 도구가 아니라 <b>사용자가 충분히 노력하지 않았다는 결론</b>으로 귀결된다.<br>
<br>
<b>나 역시 그렇게 믿었다</b><br>
<br>
나도 수년간 이 말을 믿었다.<br>
<br>
* 정말 열심히 했다<br>
* 여러 해 동안 노력했다<br>
* Rust 언어 자체에는 꽤 숙련되었다<br>
* 생산적으로 코드를 작성할 수 있게 되었다<br>
<br>
그럼에도 불구하고,<br>
<b>게임 개발이라는 영역에서의 문제는 사라지지 않았다.</b><br>
<br>
<b>핵심 문제: 끊임없는 리팩터링 강제</b><br>
<br>
Rust에서 가장 근본적인 문제는 <b>차용 검사기(borrow checker)</b>가<br>
가장 불편한 타이밍에 <b>리팩터링을 강제</b>한다는 점이다.<br>
<br>
Rust 사용자들은 이를 장점으로 본다.<br>
<br>
> "이건 좋은 코드를 쓰게 만들어준다."<br>
<br>
하지만 나는 점점 이 주장에 회의적이 되었다.<br>
<br>
좋은 코드는:<br>
<br>
* 아이디어를 빠르게 시도해보고<br>
* 실패하고<br>
* 버리고<br>
* 다시 만드는 과정에서 나온다<br>
<br>
차용 검사기가 더 많은 반복을 강제할 수는 있지만,<br>
그게 <b>바람직한 개발 방식</b>이라는 뜻은 아니다.<br>
<br>
<b>"일단 만들고 버린다"는 선택지가 사라진다</b><br>
<br>
다른 언어에서는 이렇게 생각하며 코드를 짤 수 있다:<br>
<br>
> "이건 나중에 버릴 코드야.<br>
> 지금은 그냥 돌아가게만 하자."<br>
<br>
예를 들어 플레이어 컨트롤러를 만든다고 해보자.<br>
<br>
* 지금 필요한 건 <b>완벽한 컨트롤러</b>가 아니다<br>
* 그냥 움직이기만 하면 된다<br>
* 그래야 맵을 만들고, 적을 만들 수 있다<br>
* 나중에 얼마든지 갈아엎으면 된다<br>
<br>
하지만 Rust에서는<br>
<b>"일단 되는 코드" 자체가 불가능한 경우가 많다.</b><br>
<br>
지금 이 위치에서는 필요한 동작이 불가능하고,<br>
컴파일러를 만족시키기 위해 구조를 다시 짜야 한다.<br>
<br>
심지어:<br>
<br>
* 그 코드가 곧 버려질 걸 알고 있어도<br>
* 일단 리팩터링을 하지 않으면 앞으로 나아갈 수 없다<br>
<br>
<b>퍼즐을 푸는 언어</b><br>
<br>
이 시점에서 Rust 게임 개발은<br>
"문제를 해결하는 도구"라기보다는<br>
<b>퍼즐을 푸는 과정</b>에 가깝게 느껴지기 시작했다.<br>
<br>
물론 경험이 쌓이면 이런 문제를 예측할 수는 있다.<br>
하지만 그 대가로:<br>
<br>
* 흐름이 자주 끊기고<br>
* 아이디어를 빠르게 실험할 수 없으며<br>
* "지금 이 기능이 재미있는가?"가 아니라<br>
* "이 구조가 차용 검사기를 만족하는가?"를 먼저 생각하게 된다<br>
<br>
그리고 게임 개발에서는<br>
이건 치명적인 문제다.<br>

<br>
<b>'나쁜 코드'를 쓰는 자유</b><br>
C#, C++, JavaScript 같은 언어에서는<br>
나는 이런 자유를 가진다:<br>
- 지금은 나쁜 코드여도 된다<br>
- 지금은 글로벌 상태여도 된다<br>
- 지금은 가정이 틀려도 된다<br>
<br>
그 자유 덕분에:<br>
- 기능을 한 번에 구현하고<br>
- 플레이하면서<br>
- 재미없는 걸 바로 버릴 수 있다<br>
<br>
Rust에서는<br>
이 자유가 거의 허용되지 않는다.<br>
<br>
그리고 그 차이가<br>
게임 개발에서는 결정적이다.<br>

</details>
