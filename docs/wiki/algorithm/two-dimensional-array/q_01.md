---
title: "문제 1"
parent: "Two Dimensional Array"
grand_parent: "Algorithm"
permalink: /algorithm/tda/01
nav_order: 1
---

# 문제

지도 정보가 N*N 격자판에 주어집니다. 각 격자에는 그 지역의 높이가 쓰여있습니다.

각 격자판의 숫자 중 자신의 상하좌우 숫자보다 큰 숫자는 봉우리 지역입니다. 봉우리 지역이 몇 개 있는 지 알아내는 프로그램을 작성하세요.

격자의 가장자리는 0으로 초기화 되었다고 가정한다.

만약 N=5 이고, 격자판의 숫자가 다음과 같다면 봉우리의 개수는 10개입니다.

![img01.png](img/img01.png)

# 입력

첫 줄에 자연수 N이 주어진다.(2<=N<=50)

두 번째 줄부터 N줄에 걸쳐 각 줄에 N개의 자연수가 주어진다. 각 자연수는 100을 넘지 않는다.


# 출력

봉우리의 개수를 출력하세요.

## 예시 입력 

5 <br>
5 3 7 2 3 <br>
3 7 1 6 1 <br>
7 2 5 3 4 <br>
4 3 6 4 1 <br>
8 7 3 5 2 <br>

## 예시 출력
10


## 후기
처음에 이중 loop 내부에서 상, 하, 좌, 우 비교를 위해 또 한번의 loop와 if 조건등을 통해 비교를 하는 방식으로 문제를 풀어냈으나 코드가 너무 복잡해져서 보기가 좋지 않았음.

답안을 보니 해당 문제는 특별한 알고리즘을 통한 풀이라고 할만한 건 없었고 좀 더 가독성 좋고
효율적으로 풀 수 있는 방법이 있었음.

바로 미리 비교가 필요한 x, y 좌표값을 필드에 array로 초기화 해두는 방법.

이렇게 되면 내부에 상, 하, 좌, 우 비교를 위한 조건식들이 간단해지고 코드도 좀 더 간결해지게 된다.


<details>
<summary>📌 정답</summary>

```java
public int solution01(int n, int[][] arr){
    // 상, 우, 하, 좌순 시계방향
    int[] dx = {-1, 0, 1, 0};
    int[] dy = {0, 1, 0, -1};

    int answer = 0;

    for(int i = 0; i < n; i++){
        for(int j = 0; j < n;  j++){
            boolean flag = true; //봉우리 판별 flag 변수
            for(int k = 0; k < 4; k++){
                int nx = i + dx[k];
                int ny = j + dy[k];

                if(nx >= 0 && nx < n &&
                        ny >= 0 && ny < n && // 가장자리 예외처리
                        arr[nx][ny] >= arr[i][j]
                    ){
                    flag = false;
                    // 상,하,좌,우 중 한쪽이라도 크면 비교할 필요 없기 때문
                    break; 
                }
            }
            if(flag){
                answer++;
            }
        }
    }

    return answer;
}
```
</details>
