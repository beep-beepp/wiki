---
title: "사용자 수에 따른 규모 확장성"
parent: System Design
grand_parent: Architecture
permalink: /architecture/system-design/1-1
---

# 사용자 수에 따른 규모 확장성

## 1. 기본 아키텍처 진화

### 단일 서버에서 분리 구조로

```mermaid
flowchart LR
    subgraph "초기"
        A[클라이언트] --> B[단일 서버<br/>Web + DB]
    end
    
    subgraph "발전"
        C[클라이언트] --> D[웹 서버]
        D --> E[(데이터베이스)]
    end
    
    A -.->|진화| C
```

**분리 이유**: 웹 서버는 저렴하고 수평 확장이 쉬운 반면, DB는 비용이 높아 수직 확장에 집중

---

## 2. 확장 방식 비교

```mermaid
flowchart TB
    subgraph UP["스케일 업 (수직)"]
        direction TB
        S1[서버] -->|CPU/RAM 추가| S2[고사양 서버]
    end
    
    subgraph OUT["스케일 아웃 (수평)"]
        direction TB
        T1[서버 1]
        T2[서버 2]
        T3[서버 N]
    end
    
    UP -->|"한계: 물리적 제약, 단일 장애점"| X[제한적]
    OUT -->|"장점: 무한 확장, 고가용성"| Y[유연함]
```

| 구분 | 스케일 업 | 스케일 아웃 |
|------|----------|------------|
| 방식 | 서버 성능 강화 | 서버 수량 증가 |
| 장점 | 구현 단순 | 무제한 확장, HA 가능 |
| 단점 | 물리적 한계, 장애 대응 불가 | 복잡도 증가 |

---

## 3. 로드밸런서 구조

```mermaid
flowchart TB
    Client[사용자] --> LB[로드밸런서]
    LB --> WS1[웹서버 1]
    LB --> WS2[웹서버 2]
    LB --> WS3[웹서버 N]
    
    WS1 & WS2 & WS3 --> DB[(DB)]
    
    style LB fill:#4a90d9,color:#fff
```

**핵심 역할**
- 트래픽 분산으로 서버 부하 균등화
- 장애 서버 자동 감지 및 우회
- L4/L7 등 다양한 레이어에서 동작

---

## 4. DB 다중화 (Source-Replica)

```mermaid
flowchart TB
    APP[애플리케이션] -->|Write| SRC[(Source DB)]
    APP -->|Read| R1[(Replica 1)]
    APP -->|Read| R2[(Replica 2)]
    
    SRC -->|복제| R1
    SRC -->|복제| R2
    
    style SRC fill:#e74c3c,color:#fff
    style R1 fill:#3498db,color:#fff
    style R2 fill:#3498db,color:#fff
```

**이점**
- 읽기 트래픽 분산 (대부분 Read 연산)
- Source 장애 시 Replica 승격으로 빠른 복구
- 지리적 분산으로 재해 대비

---

## 5. 캐시 계층

```mermaid
flowchart LR
    Client[요청] --> Server[서버]
    Server -->|1. 캐시 확인| Cache[(캐시<br/>Redis/Memcached)]
    Cache -->|Hit| Server
    Server -->|2. Miss 시| DB[(DB)]
    DB -->|3. 저장| Cache
    
    style Cache fill:#27ae60,color:#fff
```

**주의사항**
- 데이터 변경 시 캐시 무효화 필수
- 만료 정책 설정 (LRU, LFU, FIFO)
- 원본 갱신과 캐시 갱신의 트랜잭션 일관성

---

## 6. CDN (정적 콘텐츠 전송)

```mermaid
flowchart TB
    User1[한국 사용자] --> CDN_KR[CDN 엣지<br/>서울]
    User2[미국 사용자] --> CDN_US[CDN 엣지<br/>버지니아]
    
    CDN_KR & CDN_US -->|Miss 시| Origin[원본 서버]
    
    style CDN_KR fill:#9b59b6,color:#fff
    style CDN_US fill:#9b59b6,color:#fff
```

**특징**
- 사용자와 가장 가까운 서버에서 정적 파일 제공
- 이미지, JS, CSS, 비디오 등 캐싱
- 콘텐츠 갱신: API 무효화 또는 버전 관리

---

## 7. 전체 아키텍처 조감도

```mermaid
flowchart TB
    Users[사용자들] --> CDN[CDN]
    CDN --> LB[로드밸런서]
    
    LB --> WS1[웹서버 1]
    LB --> WS2[웹서버 2]
    
    WS1 & WS2 --> Cache[(캐시)]
    Cache --> Source[(Source DB)]
    Source --> Rep1[(Replica 1)]
    Source --> Rep2[(Replica 2)]
    
    WS1 & WS2 -.->|Read| Rep1 & Rep2
    
    style LB fill:#3498db,color:#fff
    style Cache fill:#27ae60,color:#fff
    style CDN fill:#9b59b6,color:#fff
    style Source fill:#e74c3c,color:#fff
```

---

## 핵심 정리

| 구성요소 | 목적 | 핵심 이점 |
|---------|------|----------|
| 로드밸런서 | 트래픽 분산 | 고가용성, 수평 확장 |
| DB 다중화 | 읽기 성능 + 안정성 | 장애 복구, 부하 분산 |
| 캐시 | 응답 속도 향상 | DB 부하 감소 |
| CDN | 정적 콘텐츠 배포 | 지연시간 최소화 |