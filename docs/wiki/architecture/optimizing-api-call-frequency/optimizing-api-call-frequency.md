---
title: "Optimizing API Call Frequency"
permalink: /optimizing-api-call-frequency/
has_children: false
---

# API 호출 횟수 최적화
- 캐시
  - In-Memory
  - Memcached
  - Redis
  - HTTP (ETag / If-None-Match)
    - 외부 API가 지원하면 필수
- Batch & Aggregation (여러 요청을 한번에 모아서 호출)
- Request Coalescing
- 비동기 호출 + 결과 저장 (Write once, Read many)
- API 호출 자체를 제거 
- fallback 데이터 준비

## In-Memory Cache (L1 Cache)

### 특징
- 파드 내부에 위치 
  - 파드마다 개별 캐시
- 제일 빠름
  - 네트워크 없기 때문
- 제일 휘발적
  - 파드 재시작하면 캐시를 전부 소실함

### 장점
- 빠름
- 구현이 간단함
- CPU, 네트워크 비용 최소

### 단점
- 파드간 공유 X
- 스케일 아웃 시 효율 급격히 떨어짐

### 언제 쓸까?
- 짧은 TTL (ms ~ 수초)
- L2 Cache 앞단
- 같은 요청이 같은 파드에서 반복할 때

### 대표 기술
- Caffeine
- Guava Cache

## Memcached (L2 Cache)

### 방식
파드 -> Memcached Cluster 

### 특징
- 모든 파드가 공유
- Key-Value only
- 휘발성 (날아가도 OK)

### 장점
- 운영이 간단함
- 메모리 효율 좋음

### 단점
- 데이터 구조 불가
- 영속성 X

### 언제 쓸까?
- 외부 API 응답 캐시할 때
- 가격, 환율, 추천 등에서 좋음
- 캐시는 캐시일 뿐인 데이터

## Redis (L2/L3 Cache)

### 방식
파드 -> Redis Cluster

### 특징
- 메모리 기반
- Key-Value + 자료구조(Hash, Set, ZSet 등)
- Atomic 연산 지원
- TTL 관리
- 단일 스레드 이벤트 루프 기반
- 선택적 영속성(RDB, AOF)
- Replication 및 Failover 지원

### 장점
- 강한 정합성(원자성)
  - INCR, DECR, SET, NX 같은 연산이 완전 Atomic함
  - 동시 요청에서도 값이 틀어지지 않음
- 다양한 자료구조 지원
  - 단순 값 저장이 아니라 의미 있는 상태 모델링 가능
  - DB 없이도 많은 문제를 해결할 수 있음
- 분산 환경에 친화적임
  - 여러 파드/서버에서 공유 상태 관리 가능
  - 세션, 락, 카운터에 적합
- 빠른 응답 속도
  - 네트워크 홉은 있지만, 대부분의 DB보다 훨씬 빠름

### 단점
- 메모리 비용이 큼
  - 모든 데이터가 메모리에 있음
  - 자료구조 오버헤드로 같은 데이터라도 메모리 사용량이 큼
- 운영 복잡도
  - Replication, Failover, 영속성 설정 필요
  - "캐시처럼만 쓰기엔" 관리 포인트가 많음
- 캐시로 쓰기엔 과한 경우가 많음
  - 단순 외부 API 응답 캐시를 하기에는 기능이 과잉
  - 비용 대비 효율이 떨어질 수 있음
- 잘못 쓰면 장애 반경이 큼
  - Redis 장애 = 세션/락/카운터 전부 영향
  - 캐시와 상태를 섞어 쓰면 리스크 증가

### 어디에 쓸까?
- 분산 락
  - 중복 처리 방지
  - 쿠폰 발급, 결제, 재고 처리
- 카운터
  - 재고 수량
  - Rate Limiting
  - 좋아요 / 조회수
- 세션 저장소
  - 로그인 상태
  - 토큰 관리
  - 파드 간 세션 공유
- 랭킹 / 순위
  - 실시간 인기 상품
  - 점수 기반 정렬 (ZSET)
- 작업 상태 관리
  - 처리 중 / 완료 / 실패 상태
  - 간단한 워크플로우 제어

## HTTP Cache (CDN / Client Cache)
애플리케이션 서버에 요청이 도달하기 전에, 네트워크 경계에서 이미 만들어진 HTTP 응답을 재사용하는 방법이다.

### 방식
Browser -> CDN -> (Optional) -> API Gateway

### 대표 기술
- CDN
- Browser Cache

### 특징
- 서버 부하 X
- 네트워크 단에서 요청을 차단
- HTTP 표준을 그대로 사용
  - HTTP Cache는 별도 라이브러리나 인프라 종속 기술이 아닌, HTTP 프로토콜 자체의 기능임
  - ETag / Cache-Control

### 장점
- 비용이 가장 낮음
  - CPU / 메모리 / DB 커넥션 전부 X
  - 서버 증설보다 훨씬 저렴함
  - 트래픽 증가에도 비용 예측 가능
- 트래픽 절감 효과가 가장 큼
  - 트래픽이 많을수록 가장 먼저 고려해야 할 캐시임

### 단점
- 개인화 어려움
  - HTTP Cache는 모든 사용자에게 같은 응답을 내려줌
- 제어 난이도 높음
  - HTTP Cache는 Browser, CDN, 중간 proxy 여러 레이어에 퍼져있다.
  - 그래서 TTL, 캐시 키, 무효화 전략을 신중히 설계해야 함
    - 잘못된 캐시 설정 -> 오래된 데이터 노출
    - 강제 무효화 -> 전체 트래픽이 서버로 몰림

### 언제 쓸까?
- 공개 API
  - 로그인 없이 호출
  - 모든 사용자에게 동일 응답
- 정적 데이터
  - 설정 값
  - 코드 목록
  - 변하지 않는 메타 정보
- 공통 응답
  - 상품 리스트
  - 배너 정보
  - 카테고리 구조

## 서버 디스크 캐시(Application-level Disk Cache)
애플리케이션이 외부 API 호출 결과를 서버의 로컬 디스크에 저장하고 재사용하는 방식
<br>서버가 외부 API를 다시 호출하지 않기 위해 로컬 파일을 중간 저장소로 쓰는 것

### 장점
- 메모리 사용량이 적음
  - 대용량 응답도 부담 없이 저장 가능
  - 메모리 캐시 대비 비용이 효율적임
- 구현 난이도가 낮음
  - 파일 read/write만 하면 됨
  - 별도 인프라가 불필요
  - Redis/Memcached처럼 운영 부담 없음
- 외부 API 호출 비용 감소
  - 캐시 히드시 외부 네트워크 호출 X
  - 특히 배치 / 백오피스 / 리포트 작업에 효율적임
- 장애시 마지막 결과 활용 가능
  - 최신이 아니어도 되는 경우 유용함
  - 외부 API 장애시 fallback 역할 가능

### 단점
- 파드 간 공유 불가
  - 파드마다 캐시가 분리됨
  - 스케일 아웃 시 중복 호출 발생
- 디스크 I/O 병목 가능성 있음
  - 동시 접근 많으면 성능 저하됨
  - 파일 lock, race condition 발생 가능
- 컨테이너 환경과 궁합이 좋지 않음
  - 파드 재시작시 캐시 소실
  - 노드 이동 시 데이터 유실
  - PV(Persistent Volume) 사용 시 운영 복잡도 증가
- 정합성 관리가 어려움
  - TTL 직접 구현해야 함
  - 갱신 중 race condition 위험
  - 파일 부분적으로 손상 가능성 있음

### 언제 쓸까?
- 공유가 필요없고, 최신이 아니어도 되는 경우
- 단일 서버 / 단일 파드
  - cron job
  - batch worker
  - 내부 관리 도구
- 외부 API 응답이 클 때
  - 수백 KB ~ MB 단위 데이터
  - 메모리에 오래 두기 부담스러움
- 호출 빈도는 낮지만 비용이 클 때
  - 통계 API
  - 리포트 생성
  - 분석용 데이터 수집
- Stale 데이터 허용
  - "마지막 결과면 충분한" 경우
  - 실시간 정합성 필요 없을 때

### 부적합한 경우
- 여러 파드가 동시에 처리하는 경우
  - 캐시는 한 번 만든 걸 여러 요청이 재사용해야 의미 있기 때문에
- 트래픽이 많은 API
- 사용자 요청 경로 (hot path)
- 정합성이 중요한 상태 데이터
- 실시간 응답이 중요한 서비스



