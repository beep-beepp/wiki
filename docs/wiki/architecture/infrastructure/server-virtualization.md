---
title: "가상화"
parent: Infrastructure
grand_parent: Architecture
permalink: /architecture/infrastructure/server-virtualization
nav_order: 4
---

# 가상화
*Server Virtualization & Container Technology*

---

## 1. 서버 가상화란?

서버 가상화(Server Virtualization)는 하나의 물리적 서버를 소프트웨어를 이용해 여러 개의 독립적인 가상 서버로 나누는 기술입니다. 물리 서버 위에 **하이퍼바이저(Hypervisor)**라는 소프트웨어를 올리고, 그 위에 여러 개의 **가상 머신(VM, Virtual Machine)**을 실행합니다. 각 VM은 독립된 운영체제와 애플리케이션을 갖추고, 서로 완전히 격리된 환경에서 동작합니다.

---

## 2. 에뮬레이션(Emulation)이란?

에뮬레이션이란 실제로 존재하지 않는 하드웨어를 소프트웨어로 흉내내는 것입니다. VM 안에서 OS를 실행하면, VM 입장에서는 자신이 진짜 컴퓨터 위에서 돌아간다고 '착각'합니다. 하이퍼바이저가 소프트웨어로 가짜 CPU, 가짜 메모리, 가짜 하드디스크를 만들어서 VM에게 제공합니다.

순수 에뮬레이션은 모든 것을 소프트웨어로 흉내내서 느리지만, 가상화는 가능한 부분은 실제 하드웨어를 직접 사용하고 필요한 부분만 흉내내기 때문에 훨씬 빠릅니다. 즉, **가상화는 에뮬레이션의 최적화된 방식**이라 볼 수 있습니다.

---

## 3. 가상 머신(VM) 방식의 종류

### 3-1. 호스트 OS형 (Type 2 하이퍼바이저)

기존 OS(Windows, Linux 등) 위에 하이퍼바이저 소프트웨어를 설치하여 VM을 실행하는 방식입니다. 설치와 사용이 쉬워 개발·테스트 환경에 적합합니다.

- **대표 제품:** VirtualBox, VMware Workstation
- **장점:** 기존 OS 환경에서 쉽게 사용 가능
- **단점:** 호스트 OS를 거치기 때문에 성능이 상대적으로 낮음

### 3-2. 하이퍼바이저형 (Type 1 베어메탈 하이퍼바이저)

OS 없이 하이퍼바이저가 하드웨어 위에 직접 설치되어 하드웨어를 직접 제어하는 방식입니다. 성능이 뛰어나고 기업 서버 환경에서 주로 사용됩니다.

- **대표 제품:** VMware ESXi, Microsoft Hyper-V, Xen
- **장점:** 하드웨어 직접 제어로 높은 성능
- **단점:** 설정이 복잡하고 전문 지식 필요

---

## 4. 완전 가상화 vs 준 가상화

하이퍼바이저형(Type 1) 내에서도 게스트 OS와 하이퍼바이저가 통신하는 방식에 따라 완전 가상화와 준 가상화로 나뉩니다.

### 4-1. 완전 가상화 (Full Virtualization)

게스트 OS가 자신이 가상 환경에 있다는 것을 전혀 모릅니다. 하이퍼바이저가 하드웨어를 완전히 에뮬레이션하여 게스트 OS를 수정 없이 그대로 사용할 수 있습니다.

- **대표 제품:** VMware, VirtualBox
- **장점:** 게스트 OS 수정 불필요, 다양한 OS 지원
- **단점:** 에뮬레이션 과정이 있어 상대적으로 성능 저하

### 4-2. 준 가상화 (Para-Virtualization)

게스트 OS가 자신이 가상 환경에 있다는 것을 알고 있습니다. 하이퍼바이저와 직접 통신(**하이퍼콜, Hypercall**)하도록 게스트 OS 자체를 수정하여 사용합니다.

- **대표 제품:** Xen
- **장점:** 하이퍼콜을 통한 직접 통신으로 성능이 우수
- **단점:** 게스트 OS를 수정해야 하므로 번거로움

### 완전 가상화 vs 준 가상화 비교

| 구분 | 완전 가상화 | 준 가상화 |
|------|------------|----------|
| 게스트 OS 인식 | 가상 환경임을 모름 | 가상 환경임을 알고 있음 |
| OS 수정 여부 | 불필요 | 필요 (하이퍼콜 지원) |
| 성능 | 상대적으로 낮음 | 상대적으로 높음 |
| 호환성 | 다양한 OS 지원 | 수정된 OS만 지원 |
| 대표 제품 | VMware, VirtualBox | Xen |

---

## 5. 컨테이너(Container)란?

컨테이너는 애플리케이션과 그 실행에 필요한 라이브러리, 설정 파일 등을 하나로 묶어 격리된 환경에서 실행하는 기술입니다. VM처럼 OS 전체를 가상화하지 않고, 호스트 OS의 커널을 공유하면서 프로세스 수준에서 격리합니다.

컨테이너 기술의 핵심은 리눅스 커널의 두 가지 기능에 있습니다.

- **네임스페이스(Namespace):** 프로세스, 네트워크, 파일시스템, 사용자 등을 격리합니다. 각 컨테이너는 자신만의 독립된 공간이 있는 것처럼 동작하지만, 실제로는 같은 커널 위에서 실행됩니다.
- **cgroups(Control Groups):** CPU, 메모리, 디스크 I/O 등 시스템 자원의 사용량을 컨테이너별로 제한하고 관리합니다.

대표적인 컨테이너 기술로는 **Docker**가 있으며, 다수의 컨테이너를 대규모로 관리하는 오케스트레이션 도구로는 **Kubernetes(쿠버네티스)**가 있습니다.

---

## 6. VM vs 컨테이너: 커널 관점에서의 차이

### 6-1. VM의 커널 구조

VM은 각자 독립된 커널을 가집니다. 하이퍼바이저가 하드웨어를 에뮬레이션하면, 그 위에 올라간 게스트 OS가 자신만의 커널을 갖고 실행됩니다. VM 3개를 띄우면 커널도 3개가 동작합니다.

이 구조 덕분에 VM 간의 격리가 매우 강력합니다. 게스트 OS의 커널이 충돌하더라도 다른 VM이나 호스트에 영향을 주지 않습니다. 또한 Linux 호스트 위에서 Windows 게스트를 실행하는 것처럼, 서로 다른 OS도 실행 가능합니다.

### 6-2. 컨테이너의 커널 구조

컨테이너는 호스트 OS의 커널을 공유합니다. 별도의 커널 없이 호스트 커널 위에서 프로세스로 실행되며, 네임스페이스와 cgroups로 격리와 자원 제한만 수행합니다. 컨테이너 10개를 띄워도 커널은 호스트의 것 하나뿐입니다.

이 구조 때문에 컨테이너는 훨씬 가볍고 빠르게 실행되지만, 모든 컨테이너가 같은 커널을 공유하므로 커널 취약점이 발생하면 전체 컨테이너에 영향을 줄 수 있습니다. 또한 Linux 호스트에서는 Linux 커널 기반 컨테이너만 실행 가능합니다.

### 6-3. 핵심 차이 요약

| 구분 | VM (가상 머신) | 컨테이너 |
|------|--------------|---------|
| 커널 | 게스트 OS 별 독립 커널 보유 | 호스트 OS 커널 공유 |
| 격리 방식 | 하이퍼바이저가 하드웨어 에뮬레이션 | 네임스페이스 + cgroups |
| OS 호환 | 서로 다른 OS 실행 가능 | 호스트와 동일 커널만 가능 |
| 무게 | 무거움 (OS 전체 포함, GB 단위) | 가벼움 (앱+라이브러리만, MB 단위) |
| 부팅 속도 | 분 단위 (커널 부팅 필요) | 초 단위 (커널 공유, 프로세스 시작) |
| 보안 격리 | 강함 (커널 완전 분리) | 상대적으로 약함 (커널 공유) |
| 자원 효율 | 상대적으로 낮음 | 높음 |
| 대표 기술 | VMware, Hyper-V, KVM | Docker, Podman |

---
