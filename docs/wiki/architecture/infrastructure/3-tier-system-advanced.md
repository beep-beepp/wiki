---
title: "3계층형 시스템"
parent: Infrastructure
grand_parent: Architecture
permalink: /architecture/infrastructure/3-tier-system-advanced
nav_order: 3
---
# 3계층 시스템 아키텍처 완벽 가이드
*3-Tier System Architecture Study Guide*

---

## 목차

1. [3계층 시스템 개요](#1-3계층-시스템-개요) — 웹 서버, AP 서버, DB 서버의 역할
2. [프로세스와 스레드](#2-프로세스와-스레드) — 핵심 개념과 차이점
3. [OS 커널의 역할](#3-os-커널의-역할) — 6가지 핵심 기능
4. [웹 데이터 흐름](#4-웹-데이터-흐름) — 요청부터 응답까지
5. [DB 서버 아키텍처](#5-db-서버-아키텍처) — 메모리 구조와 프로세스
6. [핵심 정리](#6-핵심-정리-시험-대비) — 시험 대비 요약

---

## 1. 3계층 시스템 개요

3계층 시스템(3-Tier Architecture)은 현대 웹 서비스의 가장 기본적인 아키텍처입니다. 사용자의 요청을 처리하기 위해 세 개의 논리적 계층으로 분리하여 각각의 역할을 명확히 합니다.

### 1.1 웹 서버 (Web Server)

웹 서버는 클라이언트(웹 브라우저)로부터 HTTP 요청을 가장 먼저 받는 계층입니다. 대표적인 웹 서버로는 Apache HTTP Server(httpd), Nginx 등이 있습니다.

주요 역할:
- 클라이언트의 HTTP 요청 수신 및 응답 반환
- 정적 콘텐츠(HTML, CSS, 이미지 등) 직접 제공
- 동적 콘텐츠 요청 시 AP 서버로 전달
- SSL/TLS 암호화 처리
- 로드 밸런싱 (여러 AP 서버로 부하 분산)

> **참고:** httpd 프로세스는 부모-자식 프로세스 구조로 동작합니다. 부모 프로세스가 요청을 받으면 자식 프로세스가 실제 처리를 담당하여 병렬 처리가 가능합니다.

### 1.2 AP 서버 (Application Server)

AP 서버는 비즈니스 로직을 처리하는 핵심 계층입니다. 웹 서버로부터 동적 콘텐츠 요청을 받아 실제 연산을 수행하고, 필요시 DB 서버에 데이터를 질의합니다.

주요 특징:
- Java 기반 서버의 경우 JVM(Java Virtual Machine) 위에서 동작
- JVM은 하나의 거대한 프로세스이며, 내부에서 여러 스레드가 요청을 처리
- 스레드 풀(Thread Pool)을 이용해 스레드 생성 비용 최소화
- 연결 풀(Connection Pool)을 이용해 DB 연결 재사용

> **왜 스레드를 사용할까요?** 프로세스를 새로 생성하는 것보다 스레드를 생성하는 것이 훨씬 가볍고 빠릅니다. 또한 같은 JVM 내의 스레드들은 메모리를 공유하므로 데이터 교환이 효율적입니다.

### 1.3 DB 서버 (Database Server)

DB 서버는 데이터의 영속성(Persistence)을 담당하는 계층입니다. AP 서버로부터 SQL 질의를 받아 데이터를 저장, 조회, 수정, 삭제(CRUD)합니다.

대표적인 DBMS:
- **웹 서비스:** MySQL, PostgreSQL
- **기업 시스템:** Oracle Database, Microsoft SQL Server
- **NoSQL:** MongoDB, Redis (Key-Value Store)

> **참고:** Oracle DB처럼 공유 메모리를 사용하는 DBMS에서는 여러 프로세스가 SGA(System Global Area)라는 공유 메모리 영역을 통해 데이터를 공유합니다. 이를 통해 디스크 I/O를 최소화하고 성능을 높입니다.

---

## 2. 프로세스와 스레드

운영체제(OS)를 이해하는 데 있어 프로세스와 스레드는 가장 핵심적인 개념입니다. 이 두 개념을 정확히 이해해야 3계층 시스템의 동작 방식을 파악할 수 있습니다.

### 2.1 프로세스 (Process)란?

프로세스는 실행 중인 프로그램의 인스턴스입니다. 프로그램을 더블클릭해서 실행하면 OS가 해당 프로그램을 메모리에 로드하고 실행을 시작하는데, 이 실행 단위가 프로세스입니다.

프로세스의 특징:
- 각 프로세스는 독립적인 메모리 공간을 가짐 (코드, 데이터, 힙, 스택 영역)
- 한 프로세스의 문제가 다른 프로세스에 영향을 주지 않음 (격리성)
- 프로세스 간 통신(IPC)이 필요하면 별도의 메커니즘 사용
- 생성 시 메모리 할당, 자원 복사 등으로 인해 비용이 높음

### 2.2 스레드 (Thread)란?

스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 하나의 프로세스는 최소 하나의 스레드(메인 스레드)를 가지며, 필요에 따라 여러 스레드를 생성할 수 있습니다.

스레드의 특징:
- 같은 프로세스 내의 스레드들은 메모리 공간을 공유
- 코드, 데이터, 힙 영역은 공유하고, 스택만 별도로 가짐
- 생성 비용이 프로세스보다 훨씬 낮음 (경량 프로세스라고도 불림)
- 메모리 공유로 인해 데이터 동기화 문제(Race Condition) 발생 가능

### 2.3 프로세스 vs 스레드 비교

| 구분 | 프로세스 | 스레드 |
|------|---------|--------|
| 메모리 | 독립적인 공간 | 프로세스 내 공유 |
| 생성 비용 | 높음 (무거움) | 낮음 (가벼움) |
| 통신 방식 | IPC 필요 | 공유 메모리 직접 접근 |
| 안정성 | 높음 (격리됨) | 낮음 (하나가 죽으면 전체 영향) |
| 사용 예 | 웹 서버 (httpd) | AP 서버 (JVM 내부) |

> **실제 사용 예시:** 웹 서버(Apache)는 요청마다 새 프로세스를 생성하는 방식(prefork)과 스레드를 사용하는 방식(worker)을 선택할 수 있습니다. AP 서버(Tomcat, JBoss 등)는 JVM 내에서 스레드 풀을 사용해 요청을 처리합니다.

---

## 3. OS 커널의 역할

커널(Kernel)은 운영체제의 핵심이자 심장입니다. 하드웨어와 소프트웨어 사이에서 중재자 역할을 하며, 애플리케이션이 하드웨어 자원을 안전하고 효율적으로 사용할 수 있게 해줍니다.

### 3.1 시스템 콜 인터페이스

애플리케이션이 OS의 기능을 사용하려면 시스템 콜(System Call)을 통해 커널에 요청해야 합니다. 마치 은행 창구에서 서비스를 요청하는 것과 같습니다.

예: 파일 읽기(`read`), 파일 쓰기(`write`), 프로세스 생성(`fork`), 네트워크 통신(`socket`) 등

### 3.2 프로세스 관리

OS에서는 수십~수천 개의 프로세스가 동시에 실행될 수 있습니다. 하지만 CPU 코어 수는 제한되어 있으므로, 커널은 어떤 프로세스가 언제 CPU를 사용할지 결정합니다(스케줄링).

### 3.3 메모리 관리

각 프로세스가 독립적인 메모리 공간을 사용할 수 있도록 관리합니다. 물리 메모리를 일정 크기(보통 4KB)의 블록으로 나누어 프로세스에 할당하고, 다른 프로세스의 메모리 영역에 접근하지 못하도록 보호합니다.

### 3.4 네트워크 스택

TCP/IP 프로토콜 처리, 소켓 통신 등 네트워크 관련 기능을 제공합니다. 애플리케이션은 복잡한 네트워크 프로토콜을 직접 구현할 필요 없이, 커널이 제공하는 추상화된 인터페이스를 사용합니다.

### 3.5 파일 시스템 관리

물리 디스크에 저장된 데이터를 '파일'이라는 단위로 다룰 수 있게 해주는 것이 파일 시스템입니다. 디렉터리 구조 제공, 접근 권한 관리, 캐싱 등의 기능을 수행합니다.

### 3.6 장치 드라이버

디스크, NIC(네트워크 카드), GPU 등 다양한 하드웨어 장치와 통신하기 위한 인터페이스입니다. 장치 제조사가 제공하는 드라이버를 통해 커널은 다양한 하드웨어를 동일한 방식으로 제어할 수 있습니다.

> **커널 설계 방식:** 모놀리식(Monolithic) 커널은 모든 기능을 하나의 메모리 공간에서 제공하고(Linux, Unix), 마이크로(Micro) 커널은 최소한의 기능만 커널에 두고 나머지는 외부에서 제공합니다(Mac OS X). 현재 대부분의 OS는 양쪽의 장점을 취한 하이브리드 방식을 사용합니다.

---

## 4. 웹 데이터 흐름

사용자가 웹 브라우저에서 URL을 입력하고 엔터를 누르면 어떤 일이 일어날까요? 이 과정을 단계별로 상세히 살펴보겠습니다.

### 4.1 클라이언트 PC → 웹 서버

**Step 1: 웹 브라우저가 요청 발행**  
사용자가 `http://example.com`을 입력하고 엔터를 누릅니다. 이때 URL의 의미는 'HTTP 프로토콜을 이용해서 example.com 서버에 접속하겠다'입니다.

**Step 2: DNS 이름 해석**  
브라우저는 'example.com'이 어디에 있는지 모릅니다. 인터넷에서는 숫자로 된 IP 주소를 사용하기 때문입니다. DNS 서버에 질의하여 `example.com = 93.184.216.34`라는 정보를 얻습니다.

**Step 3: 웹 서버가 요청 접수**  
IP 주소를 얻은 브라우저는 해당 서버의 80번(HTTP) 또는 443번(HTTPS) 포트로 연결합니다. 웹 서버의 httpd 프로세스가 이 요청을 접수합니다.

**Step 4: 콘텐츠 유형 판단**  
웹 서버는 요청된 콘텐츠가 정적인지 동적인지 판단합니다.
- **정적 콘텐츠:** HTML, CSS, 이미지 파일 등 → 디스크에서 바로 읽어서 반환
- **동적 콘텐츠:** 로그인, 검색 결과 등 → AP 서버로 요청 전달

### 4.2 웹 서버 → AP 서버

동적 콘텐츠 요청이 AP 서버에 도착하면 다음과 같은 처리가 이루어집니다:

① **스레드가 요청 접수** — JVM 내의 스레드 풀에서 대기 중인 스레드가 요청을 받습니다.  
② **처리 방식 결정** — 요청 내용을 분석하여 자체 처리 가능한지, DB 접속이 필요한지 판단합니다.  
③ **연결 풀 활용** — DB 접속이 필요하면 미리 생성해둔 연결 풀(Connection Pool)에서 연결을 가져옵니다. 매번 새로 연결을 생성하면 시간이 오래 걸리기 때문에 미리 만들어둔 연결을 재사용합니다.  
④ **캐시 활용** — 자주 사용되는 데이터(예: 지역 코드, 카테고리 목록 등)는 JVM 내부에 캐시해두고 DB에 매번 질의하지 않습니다.

### 4.3 AP 서버 → DB 서버

DB 서버에서는 SQL 요청을 받아 다음과 같이 처리합니다:

① **요청 수신:** DB 프로세스(서버 프로세스)가 SQL 요청을 접수  
② **캐시 확인:** 공유 메모리(SGA)에 해당 데이터가 있는지 확인  
③ **디스크 접근:** 캐시에 없으면 디스크에서 데이터 읽기 (시스템 콜 사용)  
④ **결과 반환:** 데이터를 정리하여 AP 서버로 반환  
⑤ **캐시 저장:** 읽어온 데이터를 공유 메모리에 캐시 (다음 요청 시 재사용)

> **캐시의 중요성:** 디스크 접근은 메모리 접근보다 수만 배 느립니다. 따라서 자주 사용되는 데이터를 메모리에 캐시해두면 성능이 크게 향상됩니다. DB 서버의 SGA, AP 서버의 JVM 내부 캐시, 웹 서버의 페이지 캐시 등 각 계층에서 캐시를 활용합니다.

---

## 5. DB 서버 아키텍처

DB 서버는 데이터의 영속성을 보장하면서도 빠른 처리 성능을 제공해야 합니다. 이를 위해 복잡한 메모리 구조와 다양한 백그라운드 프로세스를 활용합니다. Oracle DB를 예로 살펴보겠습니다.

### 5.1 메모리 구조

**SGA (System Global Area) - 공유 메모리**  
모든 DB 프로세스가 공유하는 메모리 영역입니다.
- **데이터 캐시 (Buffer Cache):** 디스크에서 읽어온 데이터 블록을 캐시
- **SQL 캐시 (Library Cache):** 파싱이 완료된 SQL 문장 저장
- **리두 로그 버퍼:** 변경 정보를 임시 저장 (장애 복구용)

**PGA (Program Global Area) - 프로세스별 메모리**  
각 서버 프로세스가 독점적으로 사용하는 메모리 영역입니다.
- **소트 영역:** ORDER BY, GROUP BY 등 정렬 작업에 사용
- **해시 영역:** 테이블 조인(JOIN) 시 해시 테이블 생성에 사용
- **세션 정보:** 클라이언트 연결 정보, 변수 값 등 저장

### 5.2 백그라운드 프로세스

Oracle DB에서는 여러 프로세스가 역할을 분담하여 효율성과 안정성을 높입니다:

| 프로세스 | 역할 | 설명 |
|---------|------|------|
| 서버 프로세스 | SQL 처리 | 클라이언트 요청을 받아 SQL 실행, 결과 반환 |
| LGWR | 로그 기록 | 변경 정보(REDO)를 로그 파일에 기록 (장애 복구용) |
| DBWR | 데이터 기록 | 변경된 데이터를 디스크에 반영 (지연 쓰기) |
| CKPT | 체크포인트 | 주기적으로 동기화 지점 생성 |
| PMON | 프로세스 모니터 | 비정상 종료된 프로세스 정리 |

> **왜 작업을 분담할까요?** 서버 프로세스가 디스크 쓰기까지 직접 하면 응답이 느려집니다. 대신 변경 사항만 메모리에 기록하고, DBWR가 나중에 일괄 처리합니다(비동기 처리). LGWR가 로그를 먼저 기록하므로 장애 발생 시에도 데이터 복구가 가능합니다.

---

## 6. 핵심 정리 (시험 대비)

### ✅ 3계층 시스템 구조

- **웹 서버:** 정적 콘텐츠 제공, 동적 요청은 AP 서버로 전달
- **AP 서버:** 비즈니스 로직 처리, JVM 기반 스레드 방식
- **DB 서버:** 데이터 영속성, 캐시를 통한 성능 최적화

### ✅ 프로세스 vs 스레드

- **프로세스:** 독립 메모리 공간, 안정적이지만 무거움
- **스레드:** 메모리 공유, 가볍지만 동기화 주의 필요
- 웹 서버는 프로세스, AP 서버는 스레드 방식이 일반적

### ✅ OS 커널의 6가지 역할

① 시스템 콜 인터페이스 — 애플리케이션과 커널 연결  
② 프로세스 관리 — CPU 스케줄링  
③ 메모리 관리 — 독립 공간 보장  
④ 네트워크 스택 — TCP/IP 처리  
⑤ 파일 시스템 관리 — 파일 추상화  
⑥ 장치 드라이버 — 하드웨어 인터페이스

### ✅ 데이터 흐름

```
DNS 해석 → 웹 서버(정적/동적 판단) → AP 서버(비즈니스 로직) → DB 서버(데이터 조회)
```

각 단계에서 캐시 활용으로 성능 최적화

### ✅ DB 서버 메모리 구조

- **SGA (공유 메모리):** 데이터 캐시, SQL 캐시, 리두 로그 버퍼
- **PGA (프로세스별):** 소트 영역, 해시 영역, 세션 정보
- **백그라운드 프로세스:** LGWR(로그), DBWR(데이터), CKPT(체크포인트)
