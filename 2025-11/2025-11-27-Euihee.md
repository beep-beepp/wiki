# Virtual Threads

- Java의 새로운 동시성 모델인 Virtual Thread는 기존의 Platform Thread처럼 OS 스레드를 점유하지 않는다.
- 대신, JVM이 관리하는 경량 컨텍스트 단위인 Continuation을 수백만 개 생성해 스케줄링하는 방식으로 동작한다. 
- async/non-blocking 패턴 없이도 기존 동기 코드 스타일을 유지하면서 고도의 동시성을 제공한다.
---

## 1. 사용 방법 및 효과
### 1-1 ) 사용 방법

yaml: 설정 예시
```yaml
spring:
  threads:
    virtual:
      enabled: true   # 이거 하나만 추가하면 끝
```

- Spring Boot 3.2.5 이상 부터는 default로 활성화 되어 있어서 위 설정 안해도 된다. 
- 구형 JDBC는 sycronized로 커넥션 락을 하는경우가 있어서 버전 봐야한다. (pinning 문제 발생 가능 있음)

### 1-2) 효과

- 수백만 개의 동시 연결을 효율적으로 처리 가능
- 기존의 Thread Pool 관리 오버헤드 감소
- 코드 복잡성 증가 없이 동시성 향상
- 블로킹 I/O 작업도 쉽게 처리 가능
- 기존 동기 코드 스타일 유지 가능 (async/await 불필요)
- 기존 라이브러리 호환성 유지
- JVM이 스케줄링 최적화 가능

---

## 2. Platform Thread와 비교 및 예시

Kafka Producer는 메시지 전송 성공 여부를 `acks` 설정값으로 제어한다.

### Platform Thread 방식

- 하나의 요청당 하나의 Thread가 할당된다.
- 하나의 Thread 생성시 stack에 기본 1MB 메모리 할당이 필요하다.
- 하나의 Thread가 작업하는 동안은 **점유**하기 때문에 blocking 된다.  
- 그래서 Thread Pool로 관리하며, 한번 늘어난 stack 메모리는 Native Memory 영역이라 GC가 회수하지 않는다. 
- 그래서 수만 개 이상의 Thread 생성은 현실적으로 불가능하다.

### Virtual Thread 방식

- 요청당 Virtual Thread가 할당된다.
- Virtual Thread는 stack 메모리가 Heap 영역에 존재하며, 필요시 확장/축소가 가능하다.
- 작업 중 Thread가 죽거나 blocking 되더라도 OS Thread를 점유하지 않기 때문에, 다른 Virtual Thread가 실행될 수 있다.
- JVM이 Virtual Thread 스케줄링을 최적화하기 때문에, 수백만 개의 Virtual Thread 생성도 가능하다.
- 오히려 Thread Pool로 관리하는게 성능 저하를 일으킬 수 있다.

#### ⚠ 진짜 스레드 200개로 100만 명을 동시에 일 시키는 마법 같은 책갈피 기술

| 용어                | 쉽게 말하면 | 비유 |
|-------------------| --- | --- |
| Carrier Thread = Platform Thread | 진짜 책 읽어주는 사람 (OS 스레드) | 도서관 사서 |
| Virtual Thread    | 책갈피 (실행 중이던 코드의 위치 정보) | 책갈피 100만 개 |
| Mount             | 사서가 책갈피 꽂은 책을 다시 펼침 | 책 다시 펴서 읽기 시작 |
| Unmount / Parking | 사서가 책 덮고 책갈피만 서랍에 보관 | 책 덮고 잠깐 치워두기 |
| Continuation      | 책갈피 + 지금까지 읽은 내용 기억 | “여기까지 읽었음” 정보 |
| ForkJoinPool      | 사서들이 서로 일 도와주는 시스템 | 도서관 운영 체계 |

### 1. Platform Thread

- 책 읽어주는 사람 **한 명**뿐이다 → 이 사람이 바로 **OS 스레드**
- 이 사람이 화장실 가고 싶으면?
    - 책을 덮고 화장실을 갔다 와야 함
    - 그 동안 **아무도 책을 못 읽음** → 전체 처리 완전히 멈춤
- 동시에 화장실 가고 싶어하는 사람(요청)이 **200명을 넘으면**
    - 줄이 너무 길어져서 서버 터짐 (OOM 또는 Thread limit)
    - ex) 카리나 이벤트일 때, thread 개수 300개로 터짐

### 2. Virtual Thread
- 책 읽어주는 사람은 여전히 **한 명** → 이 사람이 바로 **Carrier Thread**
- 그런데 **책갈피가 100만 개** 있다
- 누군가 “잠깐 화장실 좀!” 하면
    1. 지금 읽던 페이지를 책갈피 꽂고 책 덮음
    2. 책갈피는 책상 서랍에 넣어둠 → 메모리 **몇 KB**만 차지
    3. 바로 다른 사람 책(다른 Virtual Thread)을 꺼내서 읽어줌
    4. 화장실 다녀오면 서랍에서 책갈피 꺼내서 정확히 그 페이지부터 다시 읽어줌
- 사서가 갑자기 쓰러지면, 책갈피 꽂힌 책들은 모두 서랍에 안전하게 보관되어 있으므로, 다른 사서가 와서 이어서 읽어주면 됨



|                     | 책 읽는 사람 (실제 스레드) | 책갈피 (Virtual Thread) | 동시에 처리 가능 수량 |
|---------------------|-----------------------------|--------------------------|------------------------|
| Platform Thread     | 200~400명                  | 없음                     | 200~400개 → 터짐       |
| Virtual Thread      | 8~256명 (CPU 코어 기준)     | 100만 개도 OK            | 100만 개 이상도 문제없음 |

> **실제 Thread는 적어도 되고**  
> **Virtual Thread는 거의 공짜로 무한정 만들 수 있다고 한다!**

### Virtual Thread의 mount / unmount 내부 동작 원리
**Virtual Thread는 Continuation 객체로 표현되고,  
Carrier Thread(= Platform Thread) 위에 mount → blocking 시 unmount →  
ForkJoinPool 기반 Work-Stealing Scheduler가 Continuation을 관리한다.**
---


