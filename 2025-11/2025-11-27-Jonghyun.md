# modulith

## 1. **모놀리스의 구조적 부패 방지**

**현실적인 문제:**

```java
*// 시간이 지나면서 이런 코드가 생김*
com.example.order.OrderService
→ import com.example.inventory.internal.InventoryRepository;
→ import com.example.payment.db.PaymentEntity;
→ import com.example.user.util.UserValidator;

*// 모든 게 다 섞임// "order만 수정했는데 왜 inventory 테스트가 깨지지?"// "이 클래스 고치면 뭐가 영향받는지 모르겠어..."*
```

**Spring Modulith 도입 시:**

```java
*// 테스트에서 자동으로 검증*
@Test
void verifyModularity() {
    ApplicationModules.of(Application.class)
        .verify(); *// ❌ 실패: order가 inventory 내부에 접근함*
}
```

**실질적 효과:**

- 코드 리뷰 때 "이거 모듈 경계 위반이에요" 자동 감지
- 신입이 잘못 짠 코드도 CI에서 걸러짐
- 리팩토링 영향 범위 명확함

### 2. **"나중에 분리하기 쉽게" → 실제로 가능하게**

**일반적인 모놀리스:**

```java
*// "나중에 마이크로서비스로 분리하면 되지~"*
class OrderService {
    @Autowired InventoryService inventory;
    @Autowired PaymentService payment;
    @Autowired UserService user;
    @Autowired NotificationService notification;
    *// ... 20개 의존성*
}
```

**Spring Modulith 사용 시:**

```java
com.example
├── order/          *// 명확한 경계*
│   ├── api/       *// 공개 인터페이스만*
│   └── internal/  *// 구현 숨김*
├── inventory/
└── payment/

*// 테스트가 강제함*
ApplicationModules.of(App.class)
    .verify(); *// 순환 참조 있으면 실패*
```

**실질적 효과:**

- 처음부터 분리 가능한 구조로 강제됨
- 나중에 트래픽 늘면 실제로 분리 가능
- "이론적으로 가능"이 아니라 "테스트로 검증된 가능"

### 3. **이벤트 인프라를 공짜로**

**직접 구현한다면:**

```java
* 이벤트 발행
eventPublisher.publishEvent(new OrderCreatedEvent());

* 문제:
1. 리스너 실패하면? → 직접 에러 핸들링
2. 재시도는? → 직접 구현
3. 이벤트 추적은? → 직접 로깅
4. 순서 보장은? → 직접 구현
5. 트랜잭션 경계는? → 직접 관리
```

**Spring Modulith가 제공:**

```java
*// 그냥 발행*
eventPublisher.publishEvent(new OrderCreatedEvent());

*// 자동으로:
✅ 이벤트를 DB에 저장 (Event Publication Registry)
✅ 실패 시 자동 재시도
✅ 처리 완료된 이벤트 마킹
✅ 미처리 이벤트 추적 가능
✅ 트랜잭션과 자동 연동*

**실질적 효과:**
- 복잡한 이벤트 인프라를 직접 만들 필요 없음
- 운영 중 이벤트 유실 걱정 없음
- 장애 상황에서도 안전

### 4. **아키텍처 문서 자동 생성**

**일반적인 상황:**

PM: "지금 시스템 구조가 어떻게 되나요?"
개발자: "음... 문서는 오래됐고..."
PM: "order 수정하면 뭐가 영향받나요?"
개발자: "코드 봐야 알 것 같은데요..."
```

**Spring Modulith:**

```java
@Test
void documentModules() {
    var modules = ApplicationModules.of(Application.class);
    
    new Documenter(modules)
        .writeDocumentation()      *// PlantUML 다이어그램*
        .writeIndividualModulesAsPlantUml();
}

**생성되는 것:**
- 모듈 간 의존성 다이어그램
- 각 모듈의 공개 API 목록
- 이벤트 발행/구독 관계도

**실질적 효과:**
- 코드가 곧 문서
- 신입 온보딩이 쉬워짐
- 아키텍처 리뷰가 명확해짐

### 5. **점진적 도입 가능**

**마이크로서비스는:**
```
"전체 시스템을 다 뜯어고쳐야 함"
→ 몇 달씩 걸림
→ 리스크 큼
→ 실패하면 롤백도 어려움
```

**Spring Modulith는:**

```java
*// 1단계: 기존 코드 그대로, 테스트만 추가*
@Test
void verifyModules() {
    ApplicationModules.of(App.class).verify();
}
*// → 어디가 문제인지 파악

// 2단계: 조금씩 리팩토링 → 한 모듈씩 정리
// 3단계: 이벤트 도입 → 필요한 부분만
// 4단계: 준비되면 마이크로서비스로 → 이미 경계가 명확하니 분리 쉬움*
```

**실질적 효과:**

- 기존 시스템에 낮은 리스크로 도입
- 효과를 보면서 확대
- 실패해도 롤백 쉬움

## 라이브쇼핑때 적용하면 특히 유용한 이유

### 라이브 쇼핑 플랫폼 특성상:

```java
- 16,500 동시 접속
- 트래픽 스파이크
- 다양한 기능 모듈 (방송, 주문, 재고, 채팅, 알림...)

// Spring Modulith 도입 시*
com.livecommerce
├── broadcast/      // 방송 관리
├── order/          // 주문
├── inventory/      // 재고
├── chat/           // 채팅
├── notification/   // 알림
└── analytics/      // 분석

// 이벤트로 연결
eventPublisher.publishEvent(new LiveStartedEvent());
→ inventory: 재고 동기화 시작
→ notification: 팔로워 알림
→ analytics: 시청자 추적
→ chat: 채팅방 활성화

// 장점
✅ 트래픽 많은 모듈만 스케일 아웃 준비
✅ 장애 격리 (채팅 죽어도 주문은 됨)
✅ 신기능 추가가 기존 코드 안 건드림
```
