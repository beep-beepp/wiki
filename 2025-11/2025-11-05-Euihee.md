# Kafka란 무엇인가?

-   Kafka는 LinkedIn이 개발하고 Apache Software Foundation이 관리하는
    **분산형 이벤트 스트리밍 플랫폼**이다. 주의: Kafka를 "메시징
    플랫폼"이라고 제한하면 안 되고, **데이터 플랫폼**이라고 해야 한다.

-   이유는 Kafka가 단순 메시지 브로커가 아니라\
    **데이터를 생산(Producer) → 저장(Store) → 소비(Consume) →
    재처리(Offset 기반)**\
    까지 모두 제공하는 **엔드투엔드 데이터 플랫폼**이기 때문이다.

-   Kafka는 **Client + Server(Cluster)** 구조로 이루어져 있으며,\
    다양한 외부 시스템과 쉽게 연결되고, Kafka 내부에서 스트림 기반
    데이터 가공도 가능하다.

# Kafka의 주요 기능 8가지

## 1. Topic

-   저장할 데이터의 "주제(성격)"
-   SQS의 subject와 유사 개념
-   Topic 단위로 메시지를 **생성/저장/소비**
-   Topic은 **논리적 단위**이며, 실제 데이터는 Partition에 저장된다.

## 2. Partition

-   하나의 Topic은 여러 Partition으로 구성된다.
-   Partition 단위로 **병렬 처리**가 가능하다.
-   Key가 지정되면 **동일 Key는 항상 같은 Partition**으로 들어간다.
-   Key가 없으면 **round-robin 방식으로 분배**된다.
-   Partition은 **늘릴 수는 있지만 줄일 수는 없다.**

## 3. Cluster

-   Kafka Cluster는 **여러 Broker 서버로 구성된 하나의 논리적 Kafka
    시스템**이다.

## 4. Broker

-   Kafka Cluster 내 개별 서버\
-   여러 Topic의 여러 Partition 데이터를 **저장하고 전달**하는 역할
-   Broker를 여러 개 두는 이유\
    → **확장성(부하 분산)** + **복제(내결함성)**

## 5. Consumer Group

-   여러 Consumer 인스턴스를 하나의 "그룹"으로 묶는 기능
-   그룹 내 Consumer는 **Partition을 나누어 병렬 처리**
-   서로 다른 Consumer Group은\
    **동일 데이터를 독립적으로 여러 번 소비 가능**

## 6. Offset

-   Kafka 재처리 기능의 핵심
-   **Consumer Group이 '어디까지 읽었는가'를 저장하는 커서**
-   Offset을 되돌리면 과거 데이터 재처리(replay) 가능

## 7. Replication

-   하나의 Partition은 하나의 **Leader**와 여러 개의 **Follower**로 구성
-   Kafka는 **ISR(In-Sync Replica)** 구조를 사용\
    Leader 쓰기 → Follower 복제\
    Leader 장애 시 Follower가 자동 승격

## 8. Commit Log

-   Kafka는 데이터를 **append-only**로 디스크에 순차 저장한다.
-   Kafka는 `retention.ms`, `retention.bytes` 정책에 따라\
    **오래된 메시지를 자동 삭제**한다.

# Kafka의 주요 특징 7가지

## 1.고가용성(High Availability)

- Partition + Replication 구조
- KRaft (ZooKeeper사라짐)기반의 자동 Leader 선출, 메타데이터 관리

  → 장애가 발생해도 자동으로 복구되는 구조


## 2.확장성(Scalability)

- Topic의 Partition 수를 늘려 **병렬 처리량 확장**
- Cluster에 Broker를 추가하면 자동으로 Partition들이 분산되어 처리 가능

  → 완전한 **수평 확장 구조**


## 3.고성능 (High Throughput)

Kafka가 초당 수백만 건을 처리 가능한 이유:

### ✔ Sequential Write

- 일반 저장방식(랜덤 I/O)과 달리

  Kafka는 **디스크에 순차적으로 Append**만 한다.


### ✔ Zero-Copy (sendfile)

일반 전송 방식:

```
[Disk → Kernel → User → Kernel → NIC]

디스크에서 읽어서 → 커널 공간으로 가져오기

커널 공간 → 애플리케이션 메모리로 복사

애플리케이션이 다시
애플리케이션 메모리 → 소켓 버퍼로 복사

마지막으로
소켓 버퍼 → NIC(네트워크 카드) 로 전송

[창고 → 사무실 → 다시 창고 → 트럭]
```

- 중간에 User space에 두 번 왔다 갔다 해야 함
- CPU가 복사 작업을 두 번이나 해야 함
- 커널→유저 전환(Context switching)도 발생

Zero-copy 방식:

```
[Disk → Kernel(page cache) -> Kernel 내부 포인터 이동→ 소켓 버퍼 → NIC]

애플리케이션 메모리에 복사하지 않고,
OS 커널 내부에서 파일을 네트워크로 직접 보내버림.

1) “복사”가 아니라 “포인터 이동”

데이터는 안 움직여.
커널 안에서 주소만 옮겨서 “이 덩어리를 소켓으로 보내줘”라고 지시함.

2) NIC로는 DMA(Direct Memory Access)로 바로 전송

CPU가 데이터 복사 안 해도 됨.
NIC가 직접 커널 메모리에서 데이터를 가져감.

[창고에서 바로 트럭에 상자를 싣는 것]
```
- **CPU 부하 감소**
- **메모리 복사 오버헤드 제거**
- **context switching 없음**
- **I/O 비용 대폭 감소**
- **전송 속도 증가** → Kafka 초당 수백만 레코드 처리의 핵심 요인

→ 데이터가 **User space로 복사되지 않기 때문에**

CPU 부하, context switching, I/O 비용이 크게 줄어든다.



## 4. 내구성 & 안정성

- Replication으로 장애에도 데이터 보존 (partition이 죽어 다른 팔로워가 승격)
- Producer `acks=all` 옵션으로
  **모든 ISR Replica 저장 완료 후 OK** 응답 가능
- 매우 강한 내구성 보장


## 5. 재처리 (Replay)

- Offset 기반으로 언제든 **과거 데이터 재처리 가능**


## 6. 실시간 스트림 처리

Kafka 자체가 **데이터 스트림 저장소 + 처리 파이프라인**

- **Kafka Streams API**: 실시간 변환/집계/조인
- **ksqlDB**: SQL 기반 실시간 스트림 처리
- **Connect API**: DB, elasticsearch 등 외부 시스템과 실시간 연동

👉 Kafka는 **데이터 파이프라인 + 실시간 분석 엔진**까지 통합한 플랫폼


## 7. 통합성

- Kafka는 “데이터 허브” 역할
- 다양한 시스템과 쉽게 연결: DB, Elasticsearch, S3, Spark, Flink 등

-----------------------------------------------------------------

# Kafka의 동작 원리

### 1. 데이터 저장

- Producer는 메시지를 Topic에 전송
- Kafka는 메시지를 **해당 Topic의 Partition**에 저장
- Key가 없으면 round-robin, key가 있으면 동일 Partition

### 2. 소비 방식

- Kafka는 SQS와 다르게

  **HTTP 요청 + 핸드셰이크 오버헤드가 없다.**

- Consumer는 Kafka Broker와 **TCP 연결을 장기간 유지**한다.
- Consumer는 `poll()`을 반복 호출하며 데이터를 가져간다.

  → 이게 Kafka가 “준실시간 스트리밍”이 가능한 이유


### 3. Pub/Sub 성격 + MQ와 다른 점

- Kafka도 Publish/Subscribe 모델이지만

  **여러 Consumer Group이 독립적으로 동일 데이터를 읽을 수 있다.**

- MQ처럼 “한 번 소비하면 끝”이 아님

  → Kafka는 **로그 기반 스트리밍 플랫폼**

# 택배 비유 

| 시스템 | 비유 | 실제 동작 |
| --- | --- | --- |
| **SQS** | 편의점 가서 “택배 있나요?” 물어보고 없으면 다시 나가는 구조 | HTTP Polling |
| **RabbitMQ** | 택배아저씨가 직접 집으로 배달해주는 구조 | Broker → Consumer Push |
| **Kafka** | 편의점에서 계속 기다리고 있다가 택배 오면 바로 받는 구조 | Persistent TCP + 지속적 poll |
| 일반 Pub/Sub (SNS, Redis Pub/Sub, GCP Pub/Sub) | 택배가 오면 우리 집, 회사, 친구 집에 동시에 동일 택배를 복사해서 뿌려주는 구조 | Fan-out PushPublisher → Subscriber들에게 즉시 Push |
