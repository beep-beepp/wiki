## 1. @Async란?

**@Async는 메서드를 별도의 스레드에서 비동기적으로 실행하게 해주는 Spring 어노테이션**이다.

### 동기 vs 비동기

**동기 방식 (Synchronous):**

- 작업을 순차적으로 실행하고, 각 작업이 완료될 때까지 기다린다

```java
public void 회원가입(User user) {
    userRepository.save(user);           *// 1초*
    emailService.sendWelcomeEmail(user); *// 3초 (외부 API 호출)*
    smsService.sendWelcomeSms(user);     *// 2초 (외부 API 호출)// 총 6초 소요 → 사용자는 6초 기다림*
}
```

**비동기 방식 (Asynchronous)**

- 작업을 시작하고, 완료를 기다리지 않고 바로 다음 작업을 실행한다

```java
public void 회원가입(User user) {
    userRepository.save(user);           *// 1초*
    emailService.sendWelcomeEmail(user); *// 비동기 (백그라운드)*
    smsService.sendWelcomeSms(user);     *// 비동기 (백그라운드)// 총 1초 소요 → 사용자는 1초만 기다림*
}
```


## 2. @Async 기본 사용법

### (1) 설정 활성화

```java
@Configuration
@EnableAsync  *// 외부 Bean이나 main 클래스에 필수*
public class AsyncConfig {
    
}
```

### (2) 메서드에 @Async 적용

```java
@Service
public class EmailService {
    
    @Async
    public void sendWelcomeEmail(User user) {
        *// 이 메서드는 별도 스레드에서 실행됨*
        log.info("Thread: {}", Thread.currentThread().getName());
        *// 외부 이메일 API 호출 (3초)*
        emailClient.send(user.getEmail(), "환영합니다!");
    }
}
```

### (3) 호출

```java
@Service
public class UserService {
    
    @Autowired
    private EmailService emailService;
    
    public void 회원가입(User user) {
        userRepository.save(user);
        emailService.sendWelcomeEmail(user);  *// 비동기 실행// 바로 다음 줄 실행 (이메일 전송 기다리지 않음)*
    }
}
```


## 3. 반환 타입별 사용법

### (1) void - 결과 필요 없는 경우

```java
@Async
public void 알림전송(String message) {
    *// Fire and Forget*
    notificationClient.send(message);
}
```

**특징:**

- 가장 간단한 형태
- 결과를 받을 수 없음
- 예외가 발생해도 호출자는 알 수 없음

---

### (2) CompletableFuture - 현대적인 방식

```java
@Async
public CompletableFuture<String> 외부API호출() {
    String result = externalApi.call();
    return CompletableFuture.completedFuture(result);
}

*// 사용 1: 블로킹*
CompletableFuture<String> future = service.외부API호출();
String result = future.get();  *// 블로킹

// 사용 2: 논블로킹 (추천)*
service.외부API호출()
    .thenAccept(result -> {
        *// 결과 받은 후 처리*
        log.info("결과: {}", result);
    })
    .exceptionally(ex -> {
        *// 예외 처리*
        log.error("에러 발생", ex);
        return null;
    });
```

**특징:**

- 가장 현대적이고 강력함
- 논블로킹 처리 가능
- 체이닝, 조합 등 다양한 기능


## 4. ThreadPool 설정 (가장 중요!)

### (1) 기본 설정 (사용 금지!)

```java
@EnableAsync
public class AsyncConfig {
    *// 설정 없으면 SimpleAsyncTaskExecutor 사용// → 스레드를 매번 새로 생성! (위험)*
}
```

**문제점:**

- 요청마다 새 스레드 생성
- 스레드 제한 없음 → 메모리 부족 가능
- 실무에서 절대 사용 금지!

---

### (2) ThreadPoolTaskExecutor 설정 (필수!)

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        
        executor.setCorePoolSize(5);        *// 기본 스레드 수*
        executor.setMaxPoolSize(10);        *// 최대 스레드 수*
        executor.setQueueCapacity(100);     *// 큐 사이즈*
        executor.setThreadNamePrefix("async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        
        return executor;
    }
}

`**각 설정의 의미:**
#### CorePoolSize (기본 스레드 수)
요청이 들어오면:
- 현재 스레드 수 < CorePoolSize → 새 스레드 생성
- 현재 스레드 수 >= CorePoolSize → 큐에 대기

#### MaxPoolSize (최대 스레드 수)
큐가 가득 찼을 때:
- 현재 스레드 수 < MaxPoolSize → 새 스레드 생성
- 현재 스레드 수 >= MaxPoolSize → RejectedExecutionHandler 실행

#### QueueCapacity (큐 사이즈)
CorePoolSize만큼 스레드가 동작 중일 때:
- 추가 요청은 큐에 대기
- 큐가 가득 차면 MaxPoolSize까지 스레드 증가`
```

---

### (3) 동작 흐름 예시

**설정:**

```java
CorePoolSize = 2
MaxPoolSize = 5
QueueCapacity = 10
```

**시나리오:**
```
1. 요청 1 → 스레드 1 생성 (현재 스레드: 1)
2. 요청 2 → 스레드 2 생성 (현재 스레드: 2) ← CorePoolSize 도달
3. 요청 3 → 큐에 대기 (큐: 1)
4. 요청 4 → 큐에 대기 (큐: 2)
...
13. 요청 13 → 큐에 대기 (큐: 11) ← 큐 가득 참
14. 요청 14 → 스레드 3 생성 (현재 스레드: 3)
15. 요청 15 → 스레드 4 생성 (현재 스레드: 4)
16. 요청 16 → 스레드 5 생성 (현재 스레드: 5) ← MaxPoolSize 도달
17. 요청 17 → RejectedExecutionHandler 실행!
```

---

### (4) RejectedExecutionHandler 정책

```java
*// 1. AbortPolicy (기본값)// → 예외 발생 (RejectedExecutionException)*
new ThreadPoolExecutor.AbortPolicy()

*// 2. CallerRunsPolicy // → 호출한 스레드에서 직접 실행 (속도 저하로 자연스러운 배압)
// 한마디로 호출자(메인쓰레드)에게 위임(쓰레드풀 워커 쓰레드가 가득 찼다면)
// 만약 메인쓰레드 작업이 수행되는 도중에 워커 쓰레드 작업이 끝나면 대기큐에 있던게 독립적으로 바로 배정*
new ThreadPoolExecutor.CallerRunsPolicy()

*// 3. DiscardPolicy// → 조용히 무시 (위험!)*
new ThreadPoolExecutor.DiscardPolicy()

*// 4. DiscardOldestPolicy// → 가장 오래된 작업 버리고 새 작업 실행*
new ThreadPoolExecutor.DiscardOldestPolicy()
```

---

## 5. 가장 자주 하는 실수

### 실수 1: 예외 처리 안 함

```java
@Async
public void sendEmail(User user) {
    throw new RuntimeException("메일 전송 실패");
    *// 예외가 어디로? → 사라짐!*
}
```

- **void 반환 시 예외는 사라진다!**

**해결 방법 1: AsyncUncaughtExceptionHandler 등록**

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {
    
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new AsyncUncaughtExceptionHandler() {
            @Override
            public void handleUncaughtException(Throwable ex, Method method, Object... params) {
                log.error("비동기 메서드 예외 발생: {}, 파라미터: {}", 
                    method.getName(), Arrays.toString(params), ex);
                *// 알림 발송, 모니터링 등*
            }
        };
    }
}
```

**해결 방법 2: CompletableFuture 사용**

```java
@Async
public CompletableFuture<Void> sendEmail(User user) {
    try {
        emailClient.send(user);
        return CompletableFuture.completedFuture(null);
    } catch (Exception e) {
        return CompletableFuture.failedFuture(e);
    }
}

*// 사용*
service.sendEmail(user)
    .exceptionally(ex -> {
        log.error("메일 전송 실패", ex);
        return null;
    });
```

---

### 실수 2: 트랜잭션과 함께 사용

```java
@Service
public class UserService {
    
    @Transactional
    public void 회원가입(User user) {
        userRepository.save(user);
        emailService.sendEmail(user);  *// 비동기 실행*
    }
}

@Service
public class EmailService {
    @Async
    public void sendEmail(User user) {
        *// 여기서 user.getName() 호출하면?// → LazyInitializationException 발생 가능!
        // 트랜잭션이 이미 종료되어서 Entity가 영속성 컨텍스트에서 분리됨 (detached)*
    }
}
```

**문제:**

- 비동기 메서드는 별도 스레드에서 실행
- 트랜잭션이 이미 종료된 상태
- 지연 로딩된 Entity 접근 시 예외

**해결 방법 1: DTO 전달**

```java
@Service
public class UserService {
    
    @Transactional
    public void 회원가입(User user) {
        userRepository.save(user);
        
        *// Entity → DTO 변환 후 전달*
        UserDto dto = new UserDto(user.getId(), user.getName(), user.getEmail());
        emailService.sendEmail(dto);  *// ✅ DTO 전달*
    }
}

@Service
public class EmailService {
    @Async
    public void sendEmail(UserDto dto) {
        *// 안전하게 사용 가능*
    }
}
```

**해결 방법 2: Eager Fetch (추천 X)**

```java
@Transactional
public void 회원가입(User user) {
    userRepository.save(user);
    user.getOrders().size();  *// 강제 초기화*
    emailService.sendEmail(user);
}
```

---

### 실수 3: ThreadPool 설정 안 함

```java
@EnableAsync  *// ThreadPool 설정 없음!*
public class AsyncConfig {
}
```

**문제:**

- SimpleAsyncTaskExecutor 사용
- 요청마다 새 스레드 생성
- 스레드 제한 없음 → OOM 가능

**반드시 ThreadPool 설정 필수!**