# ZGC
ZGC는 Z Garbage Collector로, scalable한 low latency garbage collector이다.

## 개요
ZGC는 JDK 11에서 experimental feature로 처음 도입되었으며,
<br>JDK 15에서 production ready 단계로 선언되었다.
<br>그리고 JDK 21에서는 generation을 지원하도록 reimplemented(재구현)되었다.

## 한눈에 보는 특징
- Concurrent
  - GC의 거의 모든 작업을 애플리케이션 스레드와 동시에 처리한다.
  - STW 구간은 수백 μs 수준으로 매우 짧다.
- Region-based
  - 힙을 동일 크기의 Region 단위로 나누어 관리한다.
  - 각 Region은 개별적으로 Mark, Relocate, Free 가능하다.
- Compacting
  - 객체를 새로운 Region으로 옮겨(복사) 단편화를 해소한다.
  - ZGC는 Compaction조차 Concurrent하게 처리한다.
- NUMA-aware
  - CPU가 여러 메모리 노드를 가진 시스템(NUMAness)에서 메모리 접근 비용 차이를 고려해 객체를 적절한 메모리 노드에 배치
- Using colored pointers
  - 64비트 포인터의 상위 비트를 색깔(color) 비트로 사용해
  - Mark 여부, Remapped 여부, Forwarding 여부를 나타낸다.
  - 즉, 객체 Header를 건드리지 않고 GC 정보를 표현 가능하다.
- Using load barriers
  - 객체를 읽을 때(load) 실행되는 소프트웨어 barrier
  - 객체가 이동되었는지 확인하고, 필요하면 pointer를 새 주소로 수정(remap)한다.
  - 즉, 애플리케이션이 실행되는 동안에도 안전하게 Relocation이 가능하다. 
- Using store barriers (JDK 21 Generational ZGC에서 활성화)
  - 객체 참조를 저장(store)할 때 실행되는 barrier
  - Young/Old 간 참조 변화를 추적하기 위해 사용한다.
  - Generational ZGC에서 기존 CMS, G1에서 사용하던 card table의 역할을 대체한다.
  - 기존 non-generational ZGC는 store barrier가 필요없다.

ZGC의 핵심은 concurrent garbage collector라는 점이다.
<br>즉, 모든 무거운 작업이 Java 스레드가 계속 실행되는 동안 수행된다는 뜻이다.
<br>이로 인해 garbage collection이 애플리케이션의 response time에 미치는 영향을 크게 제한한다.

## 특징
ZGC는 모든 비용이 큰 작업을 Concurrent로 수행하며, 애플리케이션 스레드의 실행을 1ms 이상 멈추지 않는다.
<br>따라서 low latency가 요구되는 애플리케이션에 적합하다.
<br>ZGC의 pause time은 사용중인 힙 크기와 무관하며, 수백 MB에서 최대 16TB의 힙 크기까지 안정적으로 동작한다.

ZGC는 자동으로 적응(adaptive) 하도록 설계되었으며, 수동 설정이 거의 필요하지 않도록 만들어졌다.
<br>Java 프로그램이 실행되는 동안, ZGC는 workload에 따라 동적으로 적응(dynamically adapts)하며 다음을 수행한다.
- Resizing Generation
- GC 스레드 수 확장
- 객체 승격(tenuring) 임계값 조정 (adjusting tenuring thresholds)

## 장점
1. latency 요구사항이 있는 throughput에서도 처리량이 높다.
   ![img_1.png](img_1.png)
2. Pause time이 짧다.
    ![img.png](img.png)

## 동작 과정
크게 Marking -> Relocation -> Remapping 이다.

1. Pause Mark Start
   - 루트가 가리키는 객체들을 Marking
   - 이 pause는 매우 짧다 (수백 µs)
2. Concurrent Mark/Remap
   - 객체 그래프를 순회하며 살아있는 객체들을 Marking
   - Colored pointer를 이용해 load barrier가 remapping 작업을 수행
3. Pause Mark End 
   - Synchronization point (Weak roots cleaning)
     - Weak roots(WeakReference, SoftReference 등) cleaning
   - Marking 결과를 정리하는 짧은 pause
4. Concurrent Prepare for Relocation
   - 참조 처리
   - Weak 루트 정리
   - relocation set 선택
     - 어떤 region을 이동시킬지 relocation set 결정 (live ratio 낮은 region 선정)
5. Pause Relocate Start
   - relocation set을 가리키는 루트를 처리
     - root가 old location을 바라보는 것을 new location으로 바꿀 준비를 하는 pause.
   - relocation 과정 중 루트 참조가 깨지지 않도록 미리 대응
   - 매우 짧은 pause
6. Concurrent Relocate
   - relocation set의 객체들을 relocate
   - 선택된 region의 객체를 새로운 region으로 이동 (compaction)
   - load barrier가 old-to-new pointer 업데이트

![img_2.png](img_2.png)

## Colored Pointers
- ZGC의 핵심 설계 개념
- Metadata가 64비트 포인터의 사용되지 않는 비트들에 저장된다.
  - 32bit 플랫폼에서는 지원되지 않음
  - CompressedOops도 지원되지 않음
- Virtual Address-masking은 하드웨어, OS 또는 소프트웨어 중 하나에서 수행됨
  - Linux/x86_64에서는 Heap multi-mapping 방식으로 사용
  - Solaris/SPARC에서는 하드웨어 차원에서 지원됨

![img_3.png](img_3.png)

### 무슨 말이냐?
ZGC는 64비트 참조 포인터의 상위 비트 일부를 color 비트로 사용한다.
<br>JVM이 객체 참조를 단순한 "메모리 주소"로만 쓰지 않고, GC 메타데이터(tag)를 담아둔다.
<br>즉, 객체 포인터 = [메모리 주소 + GC 상태 비트] 이고, 이 GC 상태 비트가 바로 color이다.

Color Bits 용도
1. Marked0, Marked1 : Marking 색상 정보
   - 이번 GC 사이클에서 방문(mark)했는지 여부
2. Remapped : Remapping 판단 정보
   - Load barrier가 객체를 load할 때, 그 참조가 "이미 새 주소로 이동된 객체인지?", "아직 relocation set 안에 있는 오래된 주소인지?" 판단하는 데 사용한다.
3. Finalizable : Finalizable를 통해서만 reachable한 상태인지
   - (Generational ZGC에서 store barrier 사용 시)

### ❓ 왜 Marked bit가 0/1 두 개일까?
ZGC는 Concurrent Marking을 하기 때문에, 
<br>"이번 cycle에서 방문한(marked) 객체인지", "이전 cycle에서 방문한(marked) 객체인지" 를 구분해야 한다.
Marked0/Marked1은 그냥 두가지 색의 이름이다.

예를 들어,

GC cycle 1

- 이번 사이클의 mark 색 = Marked 0
- 이전 사이클의 mark 색 = Marked 1

GC cycle 2

- 이번 사이클의 mark 색 = Marked 1
- 이전 사이클의 mark 색 = Marked 0

-> GC cycle이 실행될 때마다 "이번 cycle에서 사용할 색"을 Marked0 <-> Marked1로 flip한다.
 
- 이번 cycle에서 MarkedX의 bit가 1이 아니면 dead 객체로 판단 가능
- 별도의 보조 bitmap을 사용할 필요 없음
- mark bitmap을 clear/reset 할 필요 없음
- 즉, reset 비용 없이 계속 marking cycle을 이어가기 위한 장치다.

만약 mark bit가 1개뿐이라면?

- GC cycle이 시작될 때, 전체 힙의 mark bit를 전부 0으로 리셋해야 한다.
- 이 작업은 힙이 작으면 괜찮지만, TB급에서는 수백 ms ~ 수 s 걸릴 수 있다.
- ZGC는 ultra-low pause time이 목표이므로 대량 reset 작업 자체를 없애야 한다.

그래서:
- 이전 cycle bit = 예전 mark 결과
- 이번 cycle bit = 새로운 mark 결과

이렇게 bit를 flip하면서 reset 없이 marking을 할 수 있게 된다.

## 튜닝

주요 튜닝 요소는 최대 힙 크기를 늘리는 것이다.

ZGC에는 두 가지 버전이 존재한다:
1. 새로운 Generational 버전
2. 이전에 Non-generational 버전

Non-generational ZGC는 Generation을 활용하지 않는 구버전의 ZGC로, 런타임 특성을 최적화하는 데 한계가 있다.
<br>따라서 사용자들은 새로운 Generational ZGC로 전환하는 것을 권장한다.

## Setting the Heap Size
ZGC에서 가장 중요한 튜닝 옵션은 최대 힙 크기를 설정하는 것이다.
이 값은 cli 옵션 `-Xmx` 로 지정할 수 있다.

ZGC는 Concurrent garbage collector이므로, 힙이 애플리케이션의 live-set(현재 살아있는 객체 집합)을 수용할 수 있어야 하며,
<br>동시에 GC가 실행되는 동안에도 새로운 객체 할당을 처리할 수 있을 만큼의 headroom(여유 공간)이 있어야 한다.

필요한 headroom의 크기는 애플리케이션의 allocation rate(객체 할당 속도)와 live-set의 크기에 크게 의존한다.
<br>일반적으로, ZGC에 메모리를 더 많이 할당할수록 성능은 더 좋아진다.
<br>하지만 동시에 불필요한 메모리 낭비는 바람직하지 않으므로, 메모리 사용량과 GC 실행 빈도 간의 균형을 찾는 것이 중요하다.

ZGC에는 힙 크기와 관련된 또 다른 cli 옵션인 `-XX:SoftMaxHeapSize`가 있다.
<br>이 옵션은 Java 힙이 얼마나 크게 성장할 수 있는지를 제한하는 "soft limit(소프트 한계)"를 설정하는데 사용된다.

ZGC는 이 한계를 넘지 않으려고 노력하지만, 필요할 경우 최대 힙 크기(`-Xmx`) 까지는 한시적으로 초과하여 성장할 수 있다.
<br>ZGC는 GC가 메모리를 회수하기를 기다리느라 Java 애플리케이션이 멈추는(stalling) 상황을 방지할 필요가 있을떄만, soft limit을 초과하려 메모리를 사용한다.

예를 들어, cli 옵션이 다음과 같을 경우:
```text
-Xmx5g -XX:SoftMaxHeapSize=4g
```
ZGC는 자신의 휴리스틱(heuristics)을 적용할 때 4GB를 한계로 사용하지만, 
<br>힙 크기를 4GB 이하로 유지할 수 없는 경우에는 일시적으로 최대 5GB까지 사용할 수 있다.

## Returning Unused Memory to the Operating System

기본적으로 ZGC는 사용되지 않는 메모리를 uncommit(해제)하여 운영체제에 반환한다.
<br>이 기능은 memory footprint(메모리 사용량) 이 중요한 애플리케이션이나 환경에서 유용하지만,
<br>Java 스레드의 latency에 부정적인 영향을 줄 수 있다.

이 기능은 cli 옵션 `-XX:-ZUncommit`으로 disable(비활성화)할 수 있다.

또한, 힙 크기가 최소 힙 크기(-Xms)보다 작아지지 않도록 메모리를 uncommit하지 않는다.
<br>즉, 최소 힙 크기(-Xms)가 최대 힙 크기(-Xmx)와 동일하게 설정된 경우,
<br>이 기능은 암묵적으로 disable된다.

cli 옵션 `-XX:ZUncommitDelay=<seconds>` 를 사용하여 uncommit delay(메모리 해제 지연 시간)를 설정할 수 있다.
<br>기본값은 300초(5분)이다.
<br>이 delay는 메모리가 사용되지 않은 상태로 얼마나 오래 있었을 때 해제되어 운영체제로 반환될 수 있는지를 지정한다.

## 참고
### [Oracle](https://docs.oracle.com/en/java/javase/21/gctuning/z-garbage-collector.html#GUID-FD855EE7-9ED3-46BF-8EA5-A73EB5096DDB)
### [Open JDK wiki](https://wiki.openjdk.org/display/zgc/Main)
### [FOSDEM 2018](https://cr.openjdk.org/~pliden/slides/ZGC-FOSDEM-2018.pdf)

