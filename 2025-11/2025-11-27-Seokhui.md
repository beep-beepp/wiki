## 1.1 검색 시스템의 이해

### 1.1.1 검색 시스템이란?

**용어 구분**

- **검색엔진 (search engine)**
    - 웹에서 정보를 수집하고, 사용자의 질의에 맞는 검색 결과를 돌려주는 **프로그램 자체**.
    - 예전 야후처럼 디렉터리 기반, 뉴스/블로그/카페 등 카테고리별 검색 결과를 제공하는 형태도 포함.
- **검색 시스템 (search system)**
    - **수집기 + 색인기 + 검색기 + UI + 정책** 등 전체를 아우르는 **검색 인프라**.
    - 방대한 데이터를 수집하고, 여러 검색엔진에 색인한 후, 관련도/가중치 정책에 따라 결과를 정렬해 UI로 제공.
- **검색 서비스 (search service)**
    - 최종 사용자에게 제공되는 **사이트/서비스 레벨**.
    - “검색 서비스 > 검색 시스템 > 검색엔진” 관계.

---

### 1.1.2 검색 시스템의 구성 요소

**검색 시스템 기본 구조**

1. **수집기 (Crawler/Spider/Worm/Web Robot)**
    - 웹사이트, 블로그, 카페, 파일, DB, 웹페이지 등에서 정보를 모으는 프로그램.
    - 파일의 경우 파일명/내용/경로 등을 수집해서 저장 → 이후 검색엔진이 이 정보를 검색.
2. **스토리지 (Storage)**
    - 수집한/색인된 데이터를 저장하는 물리 저장소.
    - 검색엔진은 색인된 데이터를 여기 저장해 놓고 검색 시 사용.
3. **색인기 (Indexer)**
    - 수집된 데이터를 **검색 가능 구조**로 변환해 저장.
    - 형태소 분석기를 조합해 의미 있는 용어를 추출하고, **역색인 구조**로 저장.
4. **검색기 (Searcher)**
    - 사용자 질의를 받아서 역색인을 검색하고, **유사도 기반 순위 알고리즘**으로 문서를 찾는다.
    - 검색 시에도 형태소 분석기를 사용하므로, **어떤 분석기를 쓰느냐에 따라 검색 품질이 달라진다.**

![image.png](attachment:5f7cdcc1-422d-4846-b6ae-9f5df923cb73:image.png)

---

### 1.1.3 관계형 데이터베이스와의 차이점

**1) 데이터 구조 & 검색 방식 차이**

- **관계형 DB**
    - 정형 데이터를 행/열 구조 테이블에 저장, 중복 제거, 스키마 기반.
    - SQL로 검색하며, 기본적으로는 **단순 텍스트 매칭** 수준.
    - 단어 변형, 동의어/유의어를 이용한 자연어 검색은 어렵다.
- **검색엔진/엘라스틱서치**
    - **비정형 데이터**도 색인 가능.
        - 비정형 → 구조가 전혀 없는 데이터 (이메일 본문, 블로그 글, 이미지, 동영상)
        - 반대로 정형 데이터는 rdb 처럼 명확한 스키마가 있고 데이터 타입이 명확함
        - 반정형 → 구조는 있지만 유연함 (json, xml)
    - 형태소 분석 + 역색인으로 **자연어 처리 + 고속 검색**.
        - **형태소 분석** (자연어 처리의 일부)
            - 원문: "나는 어제 맛있는 피자를 먹었다”
            
            ```java
            ↓ 형태소 분석
            
            나/NP + 는/JX
            어제/MAG
            맛있/VA + 는/ETM
            피자/NNG + 를/JKO
            먹/VV + 었/EP + 다/EF
            
            ↓ 검색용 토큰 추출 (색인할 단어들)
            
            ["나", "어제", "맛있다", "피자", "먹다"]
            ```
            
        - **역색인**
            - 순방향 색인 (일반 DB) → “피자”를 찾으려면 모든 테이블을 다 뒤져야함
            
            ```
            **순방향 색인 (RDB LIKE 검색)**:
            검색 시간 = 문서 수 × 각 문서를 읽는 시간
            
            1. 문서 1번 열어서 확인 → "피자" 있나?
            2. 문서 2번 열어서 확인 → "피자" 있나?
            3. 문서 3번 열어서 확인 → "피자" 있나?
            ...
            1,000,000. 문서 100만번 열어서 확인 → "피자" 있나?
            
            → O(N) 시간 복잡도 (N = 전체 문서 수)
            → 100만 개 문서를 모두 스캔해야 함
            
            ```
            
            - 역색인 → "피자"를 찾으면 **즉시** 해당 문서 목록을 알 수 있음. (이미 색인할 때부터 미리 역색인 구조를 만들어둠)
            
            ```
            **역색인 (Elasticsearch)**:
            
            원본 문서 저장소 (DocValues):
            문서1: {id: 1, content: "나는 어제 피자를 먹었다"}
            문서2: {id: 2, content: "오늘 치킨을 시켰다"}
            문서3: {id: 3, content: "내일 피자 먹으러 가자"}
            ...
            
            역색인 (Inverted Index):
            ┌─────────┬──────────────┐
            │  단어   │   문서 ID     │
            ├─────────┼──────────────┤
            │  나     │  [1]         │
            │  어제   │  [1]         │
            │  피자   │  [1, 3, 5]   │  ← 이미 정리되어 있음!
            │  먹다   │  [1, 3]      │
            │  오늘   │  [2]         │
            │  치킨   │  [2]         │
            └─────────┴──────────────┘
            ```
            
            검색 시간 = 단어 사전에서 찾는 시간 (매우 빠름)
            
            1. 단어 사전에서 "피자" 검색 (Binary Search)
               → O(log M) 시간 복잡도 (M = 고유 단어 수)
            
            2. "피자": [1, 3, 5, 125, 467, ... 총 1,523개 문서]
               → 즉시 반환
            
            → 100만 개 문서가 있어도 단어 사전만 찾으면 됨!
            ```
            
        - 왜 고속인가?**
            - 책에서 특정 단어를 찾을 때:
                - **순차 검색**: 첫 페이지부터 끝까지 읽으며 찾기 (느림)
                - **색인 활용**:  역색인으로 "피자 → 12, 45, 78페이지" 바로 확인 (빠름)
    - 구조화되지 않은 문서를 자동 분석해서 필드를 만들어 저장할 수도 있다.

**2) 개념 매핑**

| 엘라스틱서치 | RDB |
| --- | --- |
| 인덱스 Index | 데이터베이스 Database |
| 샤드 Shard | 파티션 Partition |
| 타입 Type | 테이블 Table |
| 문서 Document | 행 Row |
| 필드 Field | 열 Column |
| 매핑 Mapping | 스키마 Schema |
| Query DSL | SQL |
- **주의**: RDB의 “인덱스”는 WHERE/JOIN 성능 향상을 위한 **보조 구조**이고, ES의 인덱스는 **문서 모음(논리 DB)**.

**3) 쿼리/프로토콜 차이**

- ES는 **HTTP + JSON 기반 RESTful API** 사용.
    - `GET/POST/PUT/DELETE/HEAD`를 메서드로 사용.
    - Java로 개발됐지만, HTTP/JSON이므로 언어 무관하게 사용 가능.
- RDB는 전통적인 **SQL**을 사용.

**4) 예시: “홍길동” 사용자 검색**

- 가상의 USER 테이블 (ID/Name/Location/Gender/Date).
- **RDB SQL**
    - `SELECT * FROM USER WHERE Name LIKE '%홍길동%';`
    - 결과를 **행(Row)** 단위로 반환.
- **엘라스틱서치 Search API**
    - `GET /user/_search?q=Name:홍길동`
    - 결과를 **JSON 문서**로 반환.
- 영문 이름 `HongGilDong`으로 저장된 경우:
    - DB: 대소문자/문자열 조건을 SQL에서 직접 맞춰줘야 함.
    - ES: 색인/검색 시 분석 정책(소문자화 등)을 일치시키면, `HONGGILDONG`, `honggildong`, `HongGilDong` 모두 검색 가능.

---

## 1.2 검색 시스템과 엘라스틱서치

### 1.2.1 엘라스틱서치가 강력한 이유 ES의 대표적인 장점들

1. **오픈소스 + 루씬 기반**
    - Apache Lucene 기반 오픈소스 검색엔진.
    - 전 세계에서 광범위하게 사용되고, 다운로드도 수억 단위로 매우 많음 → 프로젝트 활성도/버그 대응력 높음.
2. **전문 검색(Full-text Search)**
    - 대부분의 DB는 기본 색인 구조로 인해 단순 텍스트 검색만 지원.
    - ES는 다양한 언어/기능 플러그인을 조합해 **문서 전체를 색인하는 전문 검색**에 최적화.
3. **통계 분석**
    - 비정형 로그를 수집·저장하고 통계 분석 가능.
    - 키바나(Kibana)와 연동하면 실시간 로그 시각화/분석이 가능.
4. **스키마리스 (Schemaless)**
    - 정형 스키마 없이 다양한 형태의 문서를 자동 색인/검색 가능.
5. **RESTful API & JSON**
    - HTTP + JSON 기반 → 언어/OS/플랫폼에 관계없이 사용 가능.
6. **멀티테넌시 (Multi-tenancy)**
    - 서로 다른 인덱스라도 **필드명이 같으면** 여러 인덱스를 한 번에 검색 가능.
7. **Document-Oriented**
    - 복수 계층의 데이터를 **JSON 문서**로 저장.
    - 계층 구조 문서를 한 번의 쿼리로 조회.
8. **역색인 (Inverted Index)**
    - 단어 → 문서 목록 구조.
    
    ![image.png](attachment:e1fa3764-568f-45a4-abd0-98bb2841d750:image.png)
    
    - 특정 단어가 어떤 문서에 있는지 **즉시 알 수 있어 고속 검색** 가능.
9. **확장성과 가용성**
    - 대량 문서를 분산 처리하기 위해 데이터를 **샤드(Shard)** 단위로 나눔.
    - 인덱스 생성 시 샤드 수를 조절해서 데이터 특성에 맞는 분산 처리가 가능.

---

### 1.2.2 엘라스틱서치의 약점

1. **완전한 실시간은 아니다 (Near Real-Time)**
    - 색인 후 약 1초 정도 지나야 검색 가능.
    - 내부적으로 commit/flush 과정을 거치기 때문에 “실시간”이 아니라 **준 실시간**.
2. **트랜잭션/롤백 미지원**
    - 분산 시스템 특성상, 성능을 위해 트랜잭션/롤백을 제공하지 않는다.
    - 최악의 경우 일부 데이터 손실 가능성 존재.
3. **업데이트 방식**
    - “업데이트” 요청 시 실제로는 **기존 문서를 삭제 후 새 문서를 삽입**.
    - 단순 업데이트보다 비용이 들지만, 대신 데이터 구조를 **불변(Immutable)**로 가져가는 이점이 있다.