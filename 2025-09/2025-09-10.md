뇌과학적으로 아웃풋이 중요하다.

### 종현

- flutterflow, 프로젝트 && 창업 공유

### 석희

- 다형성
- solid
- 지원님이 핸드폰 보는거 단호히(?) 거절하심
- 하지만 지키기가 힘들다. 아직도 고민이 많다.

- 지원님 인터페이스 분리가 중요한 느낌을 느꼈다.
    - crud interface를 몰았다 패착을 보았다.
- 최소한으로 지킬건 지키자

### 지원

- JMM (Java Memory Model)
1. 왜 필요?
    1. 자바는 멀티 스레드 프로그래밍
    2. 스레드간 값
        1. cpu연산을 후 메모리와 동기화 하는 과정이 있다. 그 사이에 캐시, 레지스터, 최적화 등등이 있는데 메모리 까지 같이 못하고 read/write 하는 문제가 나온다.
    3. 그래서 스레드간 consistency rule이 JMM이다.
2. 이 모델에서 어떤 개념이 필요?
    1. visibility
        1. 한 스레드에서 수정한것을 다른 스레드에서 볼수 있나?
    2. atomicity
    3. ordering
        1. 프로그램밍 의미가 순서대로 나오는가
3. JMM을 실행하기 위한 주요 키워드
    1. Volatile
        1. 한 변수의 read write를 할때 memory를 참조
    2. synchorized(lock)
        1. 임계영역에서 한번에 한스레드(?)
        2. 다른스레드에서 lock을 획들할때 그 값을 얻음
    3. happens-before(순서 관계 규칙)
        1. a가 연산한값을 b가 무조건 읽을수 있어야한다.
4. 예시

    ```jsx
    class Example {
      private volatile boolean = false;
      private int value = 0;

      public void writer () {
    }
    ```


### 한의희
아파서 늦참. 
할려고 했던거 발표안했으니까 최대한 이쁘게 적어봄


# Java Memory Model (JMM)

### 1. 개념
- JMM은 멀티스레드에서 **원자성(Atomicity), 가시성(Visibility), 순서성(Ordering)**을 정의한 **추상적 명세**이다.
- JMM을 구체적으로 보장하기 위해 **8가지 규칙**이 있으며, 이것을 **happens-before 추상 규칙**이라고 한다.
- happens-before 관계를 실제 코드에서 구현하는 키워드들이 `synchronized`, `volatile` 등이다.
- 이 규칙이 JVM 내부에서 동작하기 때문에 우리가 별다른 순서를 지정하지 않아도 **정상 동작**한다.

---

### 2. 알아야 하는 키워드
- **volatile**
    - 가시성만 보장
    - 순서성은 일부 보장
    - 원자성은 보장하지 않음

- **synchronized**
    - 가시성, 원자성, 순서성을 **전부 보장**

- **Atomic~ (AtomicInteger 등)**
    - 가시성과 원자성 보장
    - 순서성은 일부만 보장

---

### 3. 개발할 때, 언제 씀?
   - volatile은 가시성이 필요한 상태 플래그 변수(스레드 종료, 배치 중단 등)에 자주 쓰인다.
   ```jsx
     class VolatileExample {
        private volatile boolean running = true; // 상태 플래그
    
        public void run() {
            while (running) {
                // do something
            }
        }
    
        public void stop() {
            running = false; // 다른 스레드에서 즉시 반영됨
        }
    }   
  ```
   - synchronized는 공유 자원에 동시에 접근하지 못하게 객체 단위로 모니터 락을 걸어, 
     은행 출금처럼 반드시 하나의 스레드만 안전하게 실행해야 하는 임계 구역을 보호할 때 사용한다.
   
   ```jsx
   class BankAccount {
    private int balance = 1000;

    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount; // 원자적 보장
        }
    }

    public synchronized int getBalance() {
        return balance; // 가시성 + 순서성 보장
    }
}
  ```
   - Atomic~ 클래스는 내부적으로 volatile 변수와 CAS(Compare-And-Swap) 알고리즘을 사용하기 때문에, 
     lock 없이도 가시성과 원자성이 필요한 복합 연산을 안전하게 수행할 수 있다.
```jsx
import java.util.concurrent.atomic.AtomicInteger;

class AtomicExample {
  private AtomicInteger counter = new AtomicInteger(0);

  public void increment() {
    counter.incrementAndGet(); // 원자적 증가
  }

  public int get() {
    return counter.get(); // volatile 기반 가시성 보장
  }
}

  ```

### 4. 헷갈리지 말기
- JMM 보장은 하나의 JVM 안에서만 동작한다. 
- 즉, **멀티 서버** 환경에서는 JMM만으로 동시성을 제어할 수 없다. 
   


