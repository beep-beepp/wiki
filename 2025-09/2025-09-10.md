지원의 주저리 : 뇌과학적으로 아웃풋이 중요하다. 일단 보지 않고 내뱉는 버릇을 들이자.

### 종현

- flutterflow, 프로젝트 && 창업 공유
# 0. 나의 정보

- Nest, Supabase, Google cloud 그리고 flutterflow를 통한 구현
    - 내부 테스트 배포까지 성공하였고 기능들이 버그있게 동작하는 정도로 구현
        - https://www.figma.com/design/pCnhbGGnjv8jWnd1sKs4VF/DearLink%EC%99%80%EC%9D%B4%EC%96%B4%ED%94%84%EB%A0%88%EC%9E%84-%EB%94%94%EC%9E%90%EC%9D%B8?node-id=1-2&t=EZgTZ6P9Et2Yohut-1
- [플루터 플로우](https://www.flutterflow.io/)는 노코드는 아니고 플루터의 로우코드 툴로서 유명함
    - 플루터경험 0, 모바일 앱 경험 0 에서 시작함
    - 비쌈 월에 70달러 주고 썼던것 같음
- 서버는 익숙한 Nest를 사용했고 Supabase, Google cloud는 플루터 플로우에서 지원/연동을 해주어서 사용
- 프로젝트 작업기간 약 3달

# 1.  노코드 툴을 하며 느낀점

결론: 플루터를 배우고 ai agent를 쓰겠다.

1. 너무 재미있게 사용했다. 이렇게 간단하게 이런 퀄리티가 나오다니
2. 문서가 없을때 디버그나 구현이 쉽지않다.
    1. 범용적으로 잘 알려진 flutterflow인데도 이상한 버그가 많다. ex) android clientId 입력하는 곳이 없음
    2. 코드에서는 딸깍으로 고칠수 있는데
    3. 코드를 들여다 보게 됨
3. ai agent를 알기 전: 꾸준히 쓸만 하겠다 생각이 있었음, 그 후: flutter를 살짝배워서 ai agent를 붙이는게 좋겠다.
    1. 진짜 간단한 프로젝트면 재사용 의사 있음 페이지 한 10장까지? 로직 안복잡한 정도

# 2. 이번 프로젝트를 하며 느낀점

1. 단계를 잘게 쪼개자.
    
    예를 들면
    
    1. 우선 배포
    2. 로컬 로그인 구현
    3. Oauth로그인 구현
2. 디자이너 있어도 문제 없어도 문제
    - 빠른 반응을 살펴보고 싶었는데 디자인이 형편없었고 사람구하기가 힘들었다. 힘겹게 찾아서 했지만 그에 맞는 요구를 맞춰 구현하는게 힘들었다.
        - 개발자와 디자이너의 의견차이 (왜 이 디자인이 필요하지 구현 어려운데)
    - 다음에는 디자인 퀄리티를 포기할듯

# 3. 창업을 하며 느낀점

1. 같이 창업 할사람의 장점보다는 문제가 될수 있는 점을 살피자.
    1. 다음에 다시 한다면 개발을 아는 사람이나 개발자랑 같이 일해봤던 사람이랑 할듯
2. 각자 잘하는거하자.


### 석희 
어디서 들어봤지만  애매하게 알고있는 내용들 정리

## 다형성(Polymorphism)
- 하나의 인터페이스나 부모 클래스 타입으로 여러 다른 구현체들을 동일하게 다룰 수 있는 능력

### 장점
1. **확장성**: 새로운 결제 방식 추가 시 기존 코드 수정 없이 새 구현체만 추가하면 됨
2. **유지보수성**: 각 결제 방식의 로직이 분리되어 있어 수정이 용이
3. **테스트 용이성**: Mock 객체로 쉽게 테스트 가능

### 주의사항
1. **런타임 에러 가능성**: 컴파일 타임에 잡히지 않는 오류가 런타임에 발생할 수 있음
2. **성능 오버헤드**: 가상 메서드 테이블 참조로 인한 미세한 성능 저하
      ## 가상 메서드 테이블(Virtual Method Table, VMT)
      - 가상 메서드 테이블은 **다형성을 구현하기 위해 JVM이 런타임에 어떤 메서드를 호출할지 결정하는 메커니즘**.
      ### 동작 방식
      
      ```jsx
      PaymentService service = new KakaoPaymentService(); *// 실제 객체는 KakaoPaymentService*
      service.process(request); *// 어떤 process() 메서드를 호출할까?*
      ```
      
      1. **컴파일 타임**: `PaymentService.process()` 호출이라고만 결정
      2. **런타임**: 실제 객체(KakaoPaymentService)의 VMT를 참조해서 `KakaoPaymentService.process()` 호출
      
      ### 성능 오버헤드가 발생하는 이유
      
      ```jsx
      *// 직접 호출 (빠름)*
      KakaoPaymentService service = new KakaoPaymentService();
      service.process(request); *// 바로 KakaoPaymentService.process() 호출// 다형성 호출 (약간 느림)*  
      
      PaymentService service = new KakaoPaymentService();
      service.process(request); *// VMT 참조 -> 실제 메서드 찾기 -> 호출*
      ```
      
      **하지만 실무에서는 이 성능 차이는 거의 무시할 수 있는 수준.**
3. **복잡성 증가**: 상속 구조가 깊어질수록 이해하기 어려워짐

## SOLID
### Single Responsibility Principle (단일 책임 원칙)
- **개념**: 한 클래스는 하나의 책임만 가져야 한다.
### Open/Closed Principle (개방-폐쇄 원칙)
- **개념**: 확장에는 열려있고 수정에는 닫혀있어야 한다.
### Liskov Substitution Principle (리스코프 치환 원칙)
- **개념**: 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체해도 프로그램의 동작이 변하지 않아야 한다.
즉 부모 클래스로 작성된 코드가 자식 클래스 객체로도 정상 동작해야 함.
### Interface Segregation Principle (인터페이스 분리 원칙)
- **개념**: 클라이언트는 사용하지 않는 메서드에 의존하면 안 된다.
### Dependency Inversion Principle (의존성 역전 원칙)
- **개념**:
1. 상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.
2. 추상화는 구체화에 의존해서는 안 되며, 구체화는 추상화에 의존해야 한다.
**→ 변경에 대한 안정성** 때문

### Spring Boot에서 SOLID 적용 시 장점

1. **테스트 용이성**: Mock 객체로 쉽게 단위 테스트 가능
2. **확장성**: 새로운 기능 추가 시 기존 코드 수정 최소화
3. **유지보수성**: 각 클래스의 책임이 명확해 디버깅과 수정이 용이
4. **Spring의 DI 컨테이너와 완벽 호환**: @Autowired, @Service 등과 자연스럽게 연동

### 실무에 적용시 가이드라인

1. **소프트웨어 개발 3원칙 준수**        
      ### **KISS (Keep It Simple, Stupid)**
      
      - **의미**: 코드는 **단순하고 이해하기 쉽게 작성**해야 함.
      - **목표**: 불필요한 복잡성을 제거하여 코드의 **가독성, 유지보수성**을 높이는 것.
      - **이유**: 복잡한 코드는 버그를 유발하기 쉽고, 유지보수가 어렵다.
      
      ### **YAGNI (You Aren't Gonna Need It)**
      
      - **의미**: 지금 당장 필요하지 않은 기능은 **구현하지 말라**는 원칙.
      - **목표**: 불필요한 기능 추가를 방지하고 개발 **시간과 비용**을 절약하는 것.
      - **이유**: "나중에 필요할 수도 있다"라는 이유로 기능을 미리 추가하면 대부분 필요하지 않고 코드만 복잡해짐.
      
      ### **DRY (Don't Repeat Yourself)**
      
      - **의미**: **중복된 코드를 작성하지 말고 재사용 가능하도록 만들라**는 원칙.
      - **목표**: 중복을 제거해 코드의 **유지보수성**과 **일관성**을 높이는 것.
      - **이유**: 같은 코드를 여러 번 작성하면 수정할 때 모든 부분을 변경해야 하기 때문에 오류 발생 가능성이 높아짐.
2. 도메인간 응집도를 파악하여 적당히 트레이드 오프
3. **Rule of Three**: 같은 코드가 3번 반복되면 추상화 고려
4. **팀의 이해도**: 팀 전체가 이해할 수 있는 수준에서 추상화
5. **비즈니스 가치 우선**: 추상화보다 기능 구현이 더 중요할 때가 많음
6. **점진적 개선**: 처음부터 완벽하게 하려 하지 말고 필요에 따라 개선

## 느낀점
취업 준비 시절에는 SOLID 같은 개발 원칙들을 절대적인 진리처럼 여겼다. 
'이 원칙들을 완벽하게 지켜야만 좋은 코드를 작성할 수 있다'는 강박이 있었고, 
이를 어기는 것은 곧 좋은 개발자가 될 수 없다고 생각했다.  

하지만 실무에 투입되어 실제 프로젝트를 진행하면서 생각이 완전히 바뀌었다. 원칙을 적용하다 보니 오히려 역효과가 발생하는 경우를 자주 목격했다. 당장 필요하지도 않은 확장성을 위해 불필요한 인터페이스를 만들고, 단순한 로직을 여러 클래스로 분산시켜 코드 추적을 어렵게 만드는 일이 반복됐다. 결과적으로 가독성은 떨어지고 복잡도만 높아진 프로젝트가 되어버렸었다.  

지금은 실무 경험을 통해 균형감을 찾아가고 있다. 프로젝트 일정과 현실적 제약, 기존 코드베이스의 구조 등을 종합적으로 고려한다. 중복 코드가 있더라도 당장 큰 문제가 되지 않고, 향후 확장 계획이 불분명하다면 굳이 무리해서 추상화하지 않는다. 대신 기술 부채로 인식하고 적절한 시점에 리팩토링을 계획하게 되는 것 같다.  

결국 좋은 코드란 원칙을 맹목적으로 따르는 것이 아니라, 상황에 맞는 적절한 트레이드오프를 찾는 것이라고 생각한다. 기능만 돌아가면 된다는 식의 무책임한 개발도 문제지만, 과도한 원칙주의 역시 프로젝트를 복잡하게 만들 수 있다는 것을 깨달았다.

### 지원

- JMM (Java Memory Model)
1. 왜 필요한가?
    1. 자바는 멀티 스레드 프로그래밍을 많이 한다.
    2. 하지만 실제로 CPU와 메모리 사이에는 캐시, 레지스터, 최적화가 존재해서 스레드마다 다른 값을 볼 수 있다.
    3. 그래서 스레드간 consistency 를 보장하는 규칙이 필요하다. 이것이 JMM이다.
2. 주요 개념
    1. visibility
        - 한 스레드가 변경한 값이 다른 스레드에서 보이는 성질
        - ex. 캐시에만 쓰고 메모리에 반영하지 않으면 다른 스레드에서 변경한 값을 못 본다.
    2. atomicity
        - 연산이 쪼개지지 않고 한 번에 실행되는 성질
        - ex. count++는 내부적으로 읽기-더하기-쓰기 3단계라 원자성이 보장되지 않는다.
    3. ordering
        - 컴파일러나 CPU가 최적화를 위해 코드 순서를 바꿔도, 프로그램의 의미가 깨지지 않게 보장하는 성질
        - ex. flag = true; data = 1; 이 실제 실행에서는 순서가 바뀔 수 있다.
3. 주요 키워드
    1. volatile
        - 해당 변수는 항상 메모리에서 읽고 쓴다.
        - 가시성 + 순서성 보장
        - 하지만 i++ 같은 복합 연산의 원자성은 보장하지 않는다.
        - 순서성이 보장된다는 뜻이 정확히 뭘까?
          - JMM에서 volatile 변수애 대한 읽기/쓰기 앞뒤 명령어 재배치를 금지한다.
          - volatile write 앞에 있는 모든 연산은 실제로도 먼저 실행되로 flush된 다음 volatile 쓰기가 일어난다.
          - volatile read 뒤에 있는 모든 연산은 실제로도 그 이후에 실행된다. 
          - 즉, volatile이 메모리 장벽 역할을 해서 코드 순서를 의도한대로 유지시켜준다.
    2. synchronized, Lock
       - 임계영역을 한 번에 한 스레드만 실행할 수 있다.
       - 락 해제시 메모리에 즉시 반영하고, 다른 스레드가 락 획득시 최신 값을 읽는다.
       - 가시성, 원자성, 순서성 모두 보장한다.
    3. happens-before  
       - "한 작업의 결과가 다른 작업에서 반드시 보인다."는 순서보장 관계를 말한다.
       - A happens-before B : A가 끝난 후에 모든 결과가 B에서 반드시 관측된다.
       - 두 작업의 실행 순서를 보장하는 JMM의 핵심 규칙
         - ex. 같은 스레드 안의 코드 순서 -> happens-before
         - unlock -> 그 다음 lock은 happens-before
         - volatile write -> 그 다음 read는 happens-before
4. 예시
```jsx
   class Example {
     private volatile boolean ready = false;
     private int data = 0;
     
     public void writer() {
       data = 42;
       ready = true;
     }
     
     public void reader() {
       if (ready) {
         System.out.println(data);
       }
     }
   }
```

5. 정리
JMM이란 멀티 스레드 환경에서 스레드가 메모리를 어떻게 읽고 쓰는지 정의하는 규칙으로, 
Visibility, Atomicity, Ordering 을 보장하기 위해 volatile, synchronized, happens-before 관계를 제공한다.


### 한의희
아파서 늦참. 
할려고 했던거 발표안했으니까 최대한 이쁘게 적어봄


# Java Memory Model (JMM)

### 1. 개념
- JMM은 멀티스레드에서 **원자성(Atomicity), 가시성(Visibility), 순서성(Ordering)**을 정의한 **추상적 명세**이다.
- JMM을 구체적으로 보장하기 위해 **8가지 규칙**이 있으며, 이것을 **happens-before 추상 규칙**이라고 한다.
- happens-before 관계를 실제 코드에서 구현하는 키워드들이 `synchronized`, `volatile` 등이다.
- 이 규칙이 JVM 내부에서 동작하기 때문에 우리가 별다른 순서를 지정하지 않아도 **정상 동작**한다.

---

### 2. 알아야 하는 키워드
- **volatile**
    - 가시성만 보장
    - 순서성은 일부 보장
    - 원자성은 보장하지 않음

- **synchronized**
    - 가시성, 원자성, 순서성을 **전부 보장**

- **Atomic~ (AtomicInteger 등)**
    - 가시성과 원자성 보장
    - 순서성은 일부만 보장

---

### 3. 개발할 때, 언제 씀?
   - volatile은 가시성이 필요한 상태 플래그 변수(스레드 종료, 배치 중단 등)에 자주 쓰인다.
   ```jsx
     class VolatileExample {
        private volatile boolean running = true; // 상태 플래그
    
        public void run() {
            while (running) {
                // do something
            }
        }
    
        public void stop() {
            running = false; // 다른 스레드에서 즉시 반영됨
        }
    }   
  ```
   - synchronized는 공유 자원에 동시에 접근하지 못하게 객체 단위로 모니터 락을 걸어, 
     은행 출금처럼 반드시 하나의 스레드만 안전하게 실행해야 하는 임계 구역을 보호할 때 사용한다.
   
   ```jsx
   class BankAccount {
    private int balance = 1000;

    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount; // 원자적 보장
        }
    }

    public synchronized int getBalance() {
        return balance; // 가시성 + 순서성 보장
    }
}
  ```
   - Atomic~ 클래스는 내부적으로 volatile 변수와 CAS(Compare-And-Swap) 알고리즘을 사용하기 때문에, 
     lock 없이도 가시성과 원자성이 필요한 복합 연산을 안전하게 수행할 수 있다.
```jsx
import java.util.concurrent.atomic.AtomicInteger;

class AtomicExample {
  private AtomicInteger counter = new AtomicInteger(0);

  public void increment() {
    counter.incrementAndGet(); // 원자적 증가
  }

  public int get() {
    return counter.get(); // volatile 기반 가시성 보장
  }
}

  ```

### 4. 헷갈리지 말기
- JMM 보장은 하나의 JVM 안에서만 동작한다. 
- 즉, **멀티 서버** 환경에서는 JMM만으로 동시성을 제어할 수 없다. 
   


