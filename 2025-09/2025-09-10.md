지원의 주저리 : 뇌과학적으로 아웃풋이 중요하다. 일단 보지 않고 내뱉는 버릇을 들이자.

### 종현

- flutterflow, 프로젝트 && 창업 공유

### 석희

- 다형성
- solid
- 지원님이 핸드폰 보는거 단호히(?) 거절하심
- 하지만 지키기가 힘들다. 아직도 고민이 많다.

- 지원님 인터페이스 분리가 중요한 느낌을 느꼈다.
    - crud interface를 몰았다 패착을 보았다.
- 최소한으로 지킬건 지키자

### 지원

- JMM (Java Memory Model)
1. 왜 필요한가?
    1. 자바는 멀티 스레드 프로그래밍을 많이 한다.
    2. 하지만 실제로 CPU와 메모리 사이에는 캐시, 레지스터, 최적화가 존재해서 스레드마다 다른 값을 볼 수 있다.
    3. 그래서 스레드간 consistency 를 보장하는 규칙이 필요하다. 이것이 JMM이다.
2. 주요 개념
    1. visibility
        - 한 스레드가 변경한 값이 다른 스레드에서 보이는 성질
        - ex. 캐시에만 쓰고 메모리에 반영하지 않으면 다른 스레드에서 변경한 값을 못 본다.
    2. atomicity
        - 연산이 쪼개지지 않고 한 번에 실행되는 성질
        - ex. count++는 내부적으로 읽기-더하기-쓰기 3단계라 원자성이 보장되지 않는다.
    3. ordering
        - 컴파일러나 CPU가 최적화를 위해 코드 순서를 바꿔도, 프로그램의 의미가 깨지지 않게 보장하는 성질
        - ex. flag = true; data = 1; 이 실제 실행에서는 순서가 바뀔 수 있다.
3. 주요 키워드
    1. volatile
        - 해당 변수는 항상 메모리에서 읽고 쓴다.
        - 가시성 + 순서성 보장
        - 하지만 i++ 같은 복합 연산의 원자성은 보장하지 않는다.
        - 순서성이 보장된다는 뜻이 정확히 뭘까?
          - JMM에서 volatile 변수애 대한 읽기/쓰기 앞뒤 명령어 재배치를 금지한다.
          - volatile write 앞에 있는 모든 연산은 실제로도 먼저 실행되로 flush된 다음 volatile 쓰기가 일어난다.
          - volatile read 뒤에 있는 모든 연산은 실제로도 그 이후에 실행된다. 
          - 즉, volatile이 메모리 장벽 역할을 해서 코드 순서를 의도한대로 유지시켜준다.
    2. synchronized, Lock
       - 임계영역을 한 번에 한 스레드만 실행할 수 있다.
       - 락 해제시 메모리에 즉시 반영하고, 다른 스레드가 락 획득시 최신 값을 읽는다.
       - 가시성, 원자성, 순서성 모두 보장한다.
    3. happens-before  
       - "한 작업의 결과가 다른 작업에서 반드시 보인다."는 순서보장 관계를 말한다.
       - A happens-before B : A가 끝난 후에 모든 결과가 B에서 반드시 관측된다.
       - 두 작업의 실행 순서를 보장하는 JMM의 핵심 규칙
         - ex. 같은 스레드 안의 코드 순서 -> happens-before
         - unlock -> 그 다음 lock은 happens-before
         - volatile write -> 그 다음 read는 happens-before
4. 예시
```jsx
   class Example {
     private volatile boolean ready = false;
     private int data = 0;
     
     public void writer() {
       data = 42;
       ready = true;
     }
     
     public void reader() {
       if (ready) {
         System.out.println(data);
       }
     }
   }
```

5. 정리
JMM이란 멀티 스레드 환경에서 스레드가 메모리를 어떻게 읽고 쓰는지 정의하는 규칙으로, 
Visibility, Atomicity, Ordering 을 보장하기 위해 volatile, synchronized, happens-before 관계를 제공한다.


### 한의희
아파서 늦참. 
할려고 했던거 발표안했으니까 최대한 이쁘게 적어봄


# Java Memory Model (JMM)

### 1. 개념
- JMM은 멀티스레드에서 **원자성(Atomicity), 가시성(Visibility), 순서성(Ordering)**을 정의한 **추상적 명세**이다.
- JMM을 구체적으로 보장하기 위해 **8가지 규칙**이 있으며, 이것을 **happens-before 추상 규칙**이라고 한다.
- happens-before 관계를 실제 코드에서 구현하는 키워드들이 `synchronized`, `volatile` 등이다.
- 이 규칙이 JVM 내부에서 동작하기 때문에 우리가 별다른 순서를 지정하지 않아도 **정상 동작**한다.

---

### 2. 알아야 하는 키워드
- **volatile**
    - 가시성만 보장
    - 순서성은 일부 보장
    - 원자성은 보장하지 않음

- **synchronized**
    - 가시성, 원자성, 순서성을 **전부 보장**

- **Atomic~ (AtomicInteger 등)**
    - 가시성과 원자성 보장
    - 순서성은 일부만 보장

---

### 3. 개발할 때, 언제 씀?
   - volatile은 가시성이 필요한 상태 플래그 변수(스레드 종료, 배치 중단 등)에 자주 쓰인다.
   ```jsx
     class VolatileExample {
        private volatile boolean running = true; // 상태 플래그
    
        public void run() {
            while (running) {
                // do something
            }
        }
    
        public void stop() {
            running = false; // 다른 스레드에서 즉시 반영됨
        }
    }   
  ```
   - synchronized는 공유 자원에 동시에 접근하지 못하게 객체 단위로 모니터 락을 걸어, 
     은행 출금처럼 반드시 하나의 스레드만 안전하게 실행해야 하는 임계 구역을 보호할 때 사용한다.
   
   ```jsx
   class BankAccount {
    private int balance = 1000;

    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount; // 원자적 보장
        }
    }

    public synchronized int getBalance() {
        return balance; // 가시성 + 순서성 보장
    }
}
  ```
   - Atomic~ 클래스는 내부적으로 volatile 변수와 CAS(Compare-And-Swap) 알고리즘을 사용하기 때문에, 
     lock 없이도 가시성과 원자성이 필요한 복합 연산을 안전하게 수행할 수 있다.
```jsx
import java.util.concurrent.atomic.AtomicInteger;

class AtomicExample {
  private AtomicInteger counter = new AtomicInteger(0);

  public void increment() {
    counter.incrementAndGet(); // 원자적 증가
  }

  public int get() {
    return counter.get(); // volatile 기반 가시성 보장
  }
}

  ```

### 4. 헷갈리지 말기
- JMM 보장은 하나의 JVM 안에서만 동작한다. 
- 즉, **멀티 서버** 환경에서는 JMM만으로 동시성을 제어할 수 없다. 
   


