### 석희
# Spring Boot 자동구성
### 기존 Spring Framework의 한계

**Spring Framework만 사용할 때의 번거로운 작업들:**

- **수동 빈 등록의 복잡성**: 데이터베이스 연결을 위해서는 `DataSource`, `JdbcTemplate`, `TransactionManager`를 매번 수동으로 설정해야 했음
- **반복적인 설정 코드**: 프로젝트마다 동일한 인프라 빈들을 반복적으로 등록하는 boilerplate 코드 작성 필요
- **의존성 관리의 어려움**: 라이브러리 간 버전 호환성을 개발자가 직접 관리해야 함
- 톰캣도 별도로 설치하고 구성했어야함

이렇듯 Spring 프로젝트는 초기에 라이브러리나 의존성들에 대해 세팅하는데, 시간이 오래 걸리게 됨.

### Spring Boot 자동 구성의 개선점
**자동 구성의 핵심 가치:**
- **Convention over Configuration**: 일반적인 설정을 자동으로 제공하여 개발자는 비즈니스 로직에 집중
- **빠른 개발 시작**: 복잡한 설정 없이 `@SpringBootApplication` 하나로 애플리케이션 실행 가능
- **조건부 자동 설정**: 클래스패스에 특정 라이브러리가 있을 때만 관련 빈을 자동 등록
- 의존성만 추가하면 해당 스프링부트 프로젝트 버전에 맞는 라이브러리들을 모두 받아옴

### 자동 구성 동작 과정

1. **시작점**: `@SpringBootApplication` → `@EnableAutoConfiguration`
2. **동적 선택**: `AutoConfigurationImportSelector`가 `ImportSelector` 인터페이스를 구현하여 설정을 동적으로 선택
3. **설정 파일 읽기**: `METAINF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일에서 자동 구성 클래스 목록 로드
4. **조건부 등록**: `@Conditional` 계열 애노테이션을 통한 조건 검사 후 빈 등록

## 자동 구성의 장점과 단점

### 장점
**개발 효율성:**
- 복잡한 설정 없이 빠른 프로젝트 시작
- 일관된 설정으로 팀 간 개발 표준화

**유연성:**
- 조건부 구성으로 환경별 다른 설정 가능
- 개발자 정의 빈이 항상 우선권을 가짐
- 외부 설정을 통한 기능 제어

### 단점
**복잡성 증가:**
- 내부 동작 방식을 이해하기 어려움
- 디버깅 시 자동 구성된 빈들의 등록 과정 추적 필요
- 과도한 자동화로 인한 블랙박스 효과

# Spring Boot 외부설정과 프로필 (Environment, @Value, @ConfigurationProperties)
**기존 Java 애플리케이션의 문제:**

```java
* 모든 설정이 코드에 하드코딩*
public class DatabaseConnection {
    private static final String DB_URL = "jdbc:mysql://localhost:3306/mydb";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "password123";
    
    public Connection getConnection() {
        return DriverManager.getConnection(DB_URL, USERNAME, PASSWORD);
    }
}
```

**문제점들:**
- 개발/스테이징/운영 환경마다 다른 jar 파일을 빌드해야 함
- 설정 변경시 코드 수정 → 컴파일 → 배포 필요
- 민감한 정보(비밀번호)가 소스코드에 노출
- 환경별로 다른 코드 브랜치 유지 필요

## Spring의 Environment 추상화 - 첫 번째 개선

### Environment의 등장 배경
- Spring Framework는 다양한 외부 설정을 통합적으로 관리하기 위해 Environment 추상화를 도입.

### Environment의 장점
- **다양한 소스 통합**: 프로퍼티 파일, 환경변수, JVM 시스템 속성 등을 하나의 API로 접근
- **타입 변환 지원**: `getProperty(key, Type.class)`로 자동 타입 변환
- **우선순위 관리**: 여러 설정 소스 간의 우선순위 자동 관리

### Environment의 한계
```java
*// 여전히 반복적인 코드*
String url = env.getProperty("my.datasource.url");
String username = env.getProperty("my.datasource.username");
String password = env.getProperty("my.datasource.password");
*// ... 설정이 많아질수록 반복 코드 증가*
```

## @Value - 두 번째 개선 단계
### @Value의 등장
- 반복적인 `env.getProperty()` 호출을 줄이기 위해 등장한 애노테이션 기반 주입 방식입니다. (내부는 Environment로 구현되어 있음)

### @Value의 장점
- **간결한 코드**: Environment 직접 호출 대비 코드량 감소
- **자동 타입 변환**: SpEL 표현식 지원으로 복잡한 변환 가능
- **기본값 지원**: `@Value("${key:defaultValue}")` 형태로 기본값 설정

### @Value의 한계점
**1. 설정이 흩어짐:**

```java
@Component
public class PaymentService {
    @Value("${payment.api.url}")
    private String apiUrl;
    
    @Value("${payment.api.key}")
    private String apiKey;
    
    @Value("${payment.timeout}")
    private Duration timeout;
    
    *// 결제 관련 설정이 클래스 곳곳에 흩어짐*
}
```

**2. 그룹화의 어려움:**
- 관련된 설정들을 논리적으로 묶기 어려움
- 설정 검증 로직 추가하기 복잡

## 4. @ConfigurationProperties - 최종 개선 단계
### 등장 배경
- @Value의 한계점들을 해결하기 위해 Spring Boot에서 도입된 타입 안전한 설정 바인딩 방식.

**예시 @ConfigurationProperties:**

```java
@Data
@ConfigurationProperties("my.datasource")
public class MyDataSourcePropertiesV1 {
    private String url;
    private String username;
    private String password;
    private Etc etc = new Etc();
    
    @Data
    public static class Etc {
        private int maxConnection;
        private Duration timeout;
        private List<String> options = new ArrayList<>();
    }
}
```

**타입 오류 진단 개선**

```java
*// @Value 에러
Could not resolve placeholder 'my.datasource.etc.max-connection' in value "${my.datasource.etc.max-connection}"

// @*ConfigurationProperties 에러
*// application.properties*
my.datasource.etc.max-connection=abc

*// 실행 시 타입 검증 에러 발생*
Failed to bind properties under 'my.datasource.etc.max-connection' to int:
Property: my.datasource.etc.max-connection
Value: "abc"
Reason: failed to convert java.lang.String to int
```

**계층적 구조 표현 및 불변 객체 지원(생성자 바인딩)**

```java
my:
  datasource:
    url: local.db.com
    username: local_user
    etc:
      max-connection: 1
      timeout: 60s
      options: [CACHE, ADMIN]
      
@Getter
@ConfigurationProperties("my.datasource")
public class MyDataSourcePropertiesV2 {
    private final String url;
    private final String username;
    private final Etc etc;
    
    *// 생성자를 통한 불변 객체 생성*
    public MyDataSourcePropertiesV2(String url, String username, Etc etc) {
        this.url = url;
        this.username = username;
        this.etc = etc;
    }
}
```


# Spring Boot Actuator - 프로덕션 준비 기능

### 1. 전통적인 애플리케이션 운영의 어려움
### 개발 완료 != 운영 준비
**과거 Java 애플리케이션 운영의 현실:**

```java
*// 전통적인 애플리케이션 - 내부 상태를 알 방법이 없음*
@RestController
public class UserController {
    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.findAll();
    }
}
```

**운영팀이 마주한 문제들:**
- 애플리케이션이 살아있는지 어떻게 확인하지?
- 메모리 사용량이 얼마나 되지?
- 데이터베이스 연결은 정상인가?
- 어떤 빈들이 등록되어 있지?
- 로그 레벨을 운영 중에 바꿀 수 있나?

### 전통적인 해결 방법의 한계

**1. 커스텀 헬스체크(서버가 정상 구동중인지) 엔드포인트:**

```java
*// 개발자가 직접 만들어야 했던 헬스체크*
@RestController
public class HealthController {
    @Autowired
    private DataSource dataSource;
    
    @GetMapping("/health")
    public String health() {
        try {
            dataSource.getConnection(); *// DB 연결 테스트*
            return "OK";
        } catch (Exception e) {
            return "FAIL";
        }
    }
}
```

**문제점:**
- 프로젝트마다 직접 구현 필요
- 표준화 부족 (팀마다 다른 형태)
- 복합적인 헬스체크 로직 구현 복잡
- 메트릭 수집 기능 없음

## 2. Spring Boot Actuator의 등장과 해결책

### "프로덕션 준비 기능" 개념의 도입

**문서에서 제시하는 정의:**

> 개발자가 애플리케이션을 개발할 때 기능 요구사항만 개발하는 것이 아니다. 서비스를 실제 운영 단계에 올리게 되면 개발자들이 해야하는 또 다른 중요한 업무가 있다. 바로 서비스에 문제가 없는지 모니터링하고 지표들을 심어서 감시하는 활동들이다.
>

### Actuator가 제공하는 통합 솔루션

**기본 설정만으로 즉시 사용 가능:**

gradle

`dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
}`

**즉시 얻을 수 있는 기능들:**
- HTTP 기반 모니터링 엔드포인트
- 표준화된 응답 형식 (JSON)
- 다양한 시스템 메트릭 수집
- 보안 설정 지원

## 장점과 한계

### 장점
**1. 즉시 사용 가능한 운영 기능:**
- 설정 추가만으로 풍부한 모니터링 기능 제공
- 표준화된 형태로 팀 간 일관성 확보
  **2. 확장성:**
- 커스텀 헬스 인디케이터, 메트릭 추가 가능
- 외부 모니터링 시스템과 쉬운 연동
  **3. 실시간 관리:**
- 서버 재시작 없이 설정 변경 가능
- 즉각적인 문제 대응 가능

### 한계
**1. 성능 오버헤드:**
- 메트릭 수집으로 인한 추가 메모리 사용
- HTTP 요청 기록 등으로 인한 성능 영향

**2. 보안 위험:**
- 과도한 정보 노출 가능성
- 적절한 접근 제어 필요
  **3. 단순한 기능:**
- 고급 APM 도구 대비 기능 제한
- 복잡한 분산 시스템 모니터링에는 부족

