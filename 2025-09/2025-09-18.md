2025-09-18 스터디에 발표했던 주제들 정리

### 종현


### 석희 
# Spring Boot 자동구성
### 기존 Spring Framework의 한계

**Spring Framework만 사용할 때의 번거로운 작업들:**

- **수동 빈 등록의 복잡성**: 데이터베이스 연결을 위해서는 `DataSource`, `JdbcTemplate`, `TransactionManager`를 매번 수동으로 설정해야 했음
- **반복적인 설정 코드**: 프로젝트마다 동일한 인프라 빈들을 반복적으로 등록하는 boilerplate 코드 작성 필요
- **의존성 관리의 어려움**: 라이브러리 간 버전 호환성을 개발자가 직접 관리해야 함
- 톰캣도 별도로 설치하고 구성했어야함

이렇듯 Spring 프로젝트는 초기에 라이브러리나 의존성들에 대해 세팅하는데, 시간이 오래 걸리게 됨.

### Spring Boot 자동 구성의 개선점
**자동 구성의 핵심 가치:**
- **Convention over Configuration**: 일반적인 설정을 자동으로 제공하여 개발자는 비즈니스 로직에 집중
- **빠른 개발 시작**: 복잡한 설정 없이 `@SpringBootApplication` 하나로 애플리케이션 실행 가능
- **조건부 자동 설정**: 클래스패스에 특정 라이브러리가 있을 때만 관련 빈을 자동 등록
- 의존성만 추가하면 해당 스프링부트 프로젝트 버전에 맞는 라이브러리들을 모두 받아옴

### 자동 구성 동작 과정

1. **시작점**: `@SpringBootApplication` → `@EnableAutoConfiguration`
2. **동적 선택**: `AutoConfigurationImportSelector`가 `ImportSelector` 인터페이스를 구현하여 설정을 동적으로 선택
3. **설정 파일 읽기**: `METAINF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 파일에서 자동 구성 클래스 목록 로드
4. **조건부 등록**: `@Conditional` 계열 애노테이션을 통한 조건 검사 후 빈 등록

## 자동 구성의 장점과 단점

### 장점
**개발 효율성:**
- 복잡한 설정 없이 빠른 프로젝트 시작
- 일관된 설정으로 팀 간 개발 표준화

**유연성:**
- 조건부 구성으로 환경별 다른 설정 가능
- 개발자 정의 빈이 항상 우선권을 가짐
- 외부 설정을 통한 기능 제어

### 단점
**복잡성 증가:**
- 내부 동작 방식을 이해하기 어려움
- 디버깅 시 자동 구성된 빈들의 등록 과정 추적 필요
- 과도한 자동화로 인한 블랙박스 효과

# Spring Boot 외부설정과 프로필 (Environment, @Value, @ConfigurationProperties)
**기존 Java 애플리케이션의 문제:**

```java
* 모든 설정이 코드에 하드코딩*
public class DatabaseConnection {
    private static final String DB_URL = "jdbc:mysql://localhost:3306/mydb";
    private static final String USERNAME = "root";
    private static final String PASSWORD = "password123";
    
    public Connection getConnection() {
        return DriverManager.getConnection(DB_URL, USERNAME, PASSWORD);
    }
}
```

**문제점들:**
- 개발/스테이징/운영 환경마다 다른 jar 파일을 빌드해야 함
- 설정 변경시 코드 수정 → 컴파일 → 배포 필요
- 민감한 정보(비밀번호)가 소스코드에 노출
- 환경별로 다른 코드 브랜치 유지 필요

## Spring의 Environment 추상화 - 첫 번째 개선

### Environment의 등장 배경
- Spring Framework는 다양한 외부 설정을 통합적으로 관리하기 위해 Environment 추상화를 도입.

### Environment의 장점
- **다양한 소스 통합**: 프로퍼티 파일, 환경변수, JVM 시스템 속성 등을 하나의 API로 접근
- **타입 변환 지원**: `getProperty(key, Type.class)`로 자동 타입 변환
- **우선순위 관리**: 여러 설정 소스 간의 우선순위 자동 관리

### Environment의 한계
```java
*// 여전히 반복적인 코드*
String url = env.getProperty("my.datasource.url");
String username = env.getProperty("my.datasource.username");
String password = env.getProperty("my.datasource.password");
*// ... 설정이 많아질수록 반복 코드 증가*
```

## @Value - 두 번째 개선 단계
### @Value의 등장
- 반복적인 `env.getProperty()` 호출을 줄이기 위해 등장한 애노테이션 기반 주입 방식입니다. (내부는 Environment로 구현되어 있음)

### @Value의 장점
- **간결한 코드**: Environment 직접 호출 대비 코드량 감소
- **자동 타입 변환**: SpEL 표현식 지원으로 복잡한 변환 가능
- **기본값 지원**: `@Value("${key:defaultValue}")` 형태로 기본값 설정

### @Value의 한계점
**1. 설정이 흩어짐:**

```java
@Component
public class PaymentService {
    @Value("${payment.api.url}")
    private String apiUrl;
    
    @Value("${payment.api.key}")
    private String apiKey;
    
    @Value("${payment.timeout}")
    private Duration timeout;
    
    *// 결제 관련 설정이 클래스 곳곳에 흩어짐*
}
```

**2. 그룹화의 어려움:**
- 관련된 설정들을 논리적으로 묶기 어려움
- 설정 검증 로직 추가하기 복잡

## 4. @ConfigurationProperties - 최종 개선 단계
### 등장 배경
- @Value의 한계점들을 해결하기 위해 Spring Boot에서 도입된 타입 안전한 설정 바인딩 방식.

**예시 @ConfigurationProperties:**

```java
@Data
@ConfigurationProperties("my.datasource")
public class MyDataSourcePropertiesV1 {
    private String url;
    private String username;
    private String password;
    private Etc etc = new Etc();
    
    @Data
    public static class Etc {
        private int maxConnection;
        private Duration timeout;
        private List<String> options = new ArrayList<>();
    }
}
```

**타입 오류 진단 개선**

```java
*// @Value 에러
Could not resolve placeholder 'my.datasource.etc.max-connection' in value "${my.datasource.etc.max-connection}"

// @*ConfigurationProperties 에러
*// application.properties*
my.datasource.etc.max-connection=abc

*// 실행 시 타입 검증 에러 발생*
Failed to bind properties under 'my.datasource.etc.max-connection' to int:
Property: my.datasource.etc.max-connection
Value: "abc"
Reason: failed to convert java.lang.String to int
```

**계층적 구조 표현 및 불변 객체 지원(생성자 바인딩)**

```java
my:
  datasource:
    url: local.db.com
    username: local_user
    etc:
      max-connection: 1
      timeout: 60s
      options: [CACHE, ADMIN]
      
@Getter
@ConfigurationProperties("my.datasource")
public class MyDataSourcePropertiesV2 {
    private final String url;
    private final String username;
    private final Etc etc;
    
    *// 생성자를 통한 불변 객체 생성*
    public MyDataSourcePropertiesV2(String url, String username, Etc etc) {
        this.url = url;
        this.username = username;
        this.etc = etc;
    }
}
```


# Spring Boot Actuator - 프로덕션 준비 기능

### 1. 전통적인 애플리케이션 운영의 어려움
### 개발 완료 != 운영 준비
**과거 Java 애플리케이션 운영의 현실:**

```java
*// 전통적인 애플리케이션 - 내부 상태를 알 방법이 없음*
@RestController
public class UserController {
    @GetMapping("/users")
    public List<User> getUsers() {
        return userService.findAll();
    }
}
```

**운영팀이 마주한 문제들:**
- 애플리케이션이 살아있는지 어떻게 확인하지?
- 메모리 사용량이 얼마나 되지?
- 데이터베이스 연결은 정상인가?
- 어떤 빈들이 등록되어 있지?
- 로그 레벨을 운영 중에 바꿀 수 있나?

### 전통적인 해결 방법의 한계

**1. 커스텀 헬스체크(서버가 정상 구동중인지) 엔드포인트:**

```java
*// 개발자가 직접 만들어야 했던 헬스체크*
@RestController
public class HealthController {
    @Autowired
    private DataSource dataSource;
    
    @GetMapping("/health")
    public String health() {
        try {
            dataSource.getConnection(); *// DB 연결 테스트*
            return "OK";
        } catch (Exception e) {
            return "FAIL";
        }
    }
}
```

**문제점:**
- 프로젝트마다 직접 구현 필요
- 표준화 부족 (팀마다 다른 형태)
- 복합적인 헬스체크 로직 구현 복잡
- 메트릭 수집 기능 없음

## 2. Spring Boot Actuator의 등장과 해결책

### "프로덕션 준비 기능" 개념의 도입

**문서에서 제시하는 정의:**

> 개발자가 애플리케이션을 개발할 때 기능 요구사항만 개발하는 것이 아니다. 서비스를 실제 운영 단계에 올리게 되면 개발자들이 해야하는 또 다른 중요한 업무가 있다. 바로 서비스에 문제가 없는지 모니터링하고 지표들을 심어서 감시하는 활동들이다.
> 

### Actuator가 제공하는 통합 솔루션

**기본 설정만으로 즉시 사용 가능:**

gradle

`dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
}`

**즉시 얻을 수 있는 기능들:**
- HTTP 기반 모니터링 엔드포인트
- 표준화된 응답 형식 (JSON)
- 다양한 시스템 메트릭 수집
- 보안 설정 지원

## 장점과 한계

### 장점
**1. 즉시 사용 가능한 운영 기능:**
- 설정 추가만으로 풍부한 모니터링 기능 제공
- 표준화된 형태로 팀 간 일관성 확보
**2. 확장성:**
- 커스텀 헬스 인디케이터, 메트릭 추가 가능
- 외부 모니터링 시스템과 쉬운 연동
**3. 실시간 관리:**
- 서버 재시작 없이 설정 변경 가능
- 즉각적인 문제 대응 가능

### 한계
**1. 성능 오버헤드:**
- 메트릭 수집으로 인한 추가 메모리 사용
- HTTP 요청 기록 등으로 인한 성능 영향

**2. 보안 위험:**
- 과도한 정보 노출 가능성
- 적절한 접근 제어 필요
**3. 단순한 기능:**
- 고급 APM 도구 대비 기능 제한
- 복잡한 분산 시스템 모니터링에는 부족




### 지원
# Generic
**클래스나  메서드를 정의할 때 타입을 일반화해서 작성할 수 있게 해주는 기능이다.**
<br>예를 들어 `List<String>`을 선언하면 컴파일러가 문자열만 추가되도록 보장해 런타임 오류를 예방할 수 있다.

## 왜 나왔을까?
Generic이 없던 시절에는 List 같은 컬렉션이 모든 요소를 Object로 다뤘다. 
<br>따라서 값을 꺼낼 때마다 개발자가 직접 원하는 타입으로 캐스팅해야 했고, 잘못된 타입을 넣어도 컴파일 단계에서는 잡히지 않고 런타임에서 ClassCastException이 발생했다.

Generic을 쓰면 List<String>처럼 컴파일러가 타입을 강제하기 때문에, add(123) 같은 잘못된 값의 삽입은 컴파일 에러로 걸러진다. 
<br>그리고 값을 꺼낼 때도 이미 타입이 보장되어 있으므로 별도의 형변환이 필요 없다.
<br>결국 불필요한 캐스팅이 줄고, 런타임 오류가 컴파일 오류로 당겨져 안정성이 높아졌다.

## 특징

- 이점
  - 컴파일 타임에 타입을 검사하기 때문에 타입 안정성을 높일 수 있고, 런타임 오류를 방지해준다.
  - 타입을 일반화해 여러 타입에서 동일한 코드를 재사용 할 수 있게 해준다.
  - 코드가 명확해져 가독성도 향상된다.
  


- 제약
  - 제네릭은 타입 소거법(Type Eraser)으로 동작하기 때문에 런타임에는 제네릭 타입 정보가 사라진다. 
  - 그래서 `new T()` 같은 객체 생성이나 primitive type을 직접 사용할 수 없다.


### `new T()` 같은 객체 생성이나 primitive type을 직접 사용할 수 없다. 왜?
- `new T()` 불가
  - 타입 소거법으로 동작해, 컴파일 이후 타입 매개변수 T는 상위 바운드 타입(없으면 Object)으로 치환된다.
  - 그러나 `new T()`를 작성하면, 컴파일러는 런타임에 어떤 구체 타입의 생성자를 호출해야 하는지 알 수 없다.
  - 단순히 `new Object()`로 치환하면 Generic이 의도한 타입 안정성 보장이 깨져버리기 때문에 아예 금지되어 있다.
- primitive type 불가 
  - 타입 소거 후 Object로 치환되는데, primitive type은 Object의 서브타입이 아니다.

## 타입 소거법(Type Eraser) 과 와일드 카드
Generic은 타입 소거법 기반으로 동작한다. 
<br>즉, 컴파일 시점에는 타입 정보를 이용해 타입 안정성을 보장하지만, 바이트코드로 변환할 때는 타입 정보가 제거되고 상위 바운드 타입으로 치환된다.
<br>예를 들어 `List<String>`과 `List<Integer>`은 런타임에 모두 같은 `List`로 동작한다.

### 와일드 카드
와일드 카드에는 `? extends`와 `? super`이 있다.
- `? extends T` 
  - 상한 제한으로, T나 그 하위 타입을 받을 수 있다.
  - 읽기 전용에 적합하다.
  - ex. `List<? extends Number>`는 `Integer`, `Double`을 읽을 수 있지만, 새 값을 안전하게 추가할 수는 없다.
  ```java
    List<? extends Number> list = new ArrayList<Integer>();
    // Number 또는 그 하위 타입을 담을 수 있고, 안전하게 읽을 수 있다.
    Number n = list.get(0); // O 읽기 가능
    // 하지만 정확히 어떤 하위 타입인지 모르기 때문에 새로운 값을 넣을 수는 없다.
    list.add(123); // X 컴파일 에러
  ```
- `? super T`
  - 하한 제한으로, `T`나 그 상위 타입을 받을 수 있다.
  - 쓰기 전용에 적합하다.
  - ex. `List<? super Integer>`에는 `Integer` 또는 그 상위 타입은 추가할 수 있지만, 꺼낼 때는 Object오만 안전하게 다룰 수 있다.
  ```java
    List<? super Integer> list = new ArrayList<Number>();
    // Integer 또는 그 상위 타입을 담을 수 있고, 안전하게 Integer를 추가할 수 있다.
    list.add(123); // Integer 추가 가능
    // 하자만 꺼낼 때는 구체적인 타입을 알 수 없으므로 Object로만 읽을 수 있다.
    Object obj = list.get(0); // 읽을 순 있지만 타입은 Object
  ```

### 상위 바운드 타입으로 치환된다?
컴파일이 끝나면 T 같은 타입 파라미터는 사라지고 대신 상위 바운드 타입(없으면 Object)으로 치환된다.
- ex. `<T extends Number>` 라면 `T`는 런타임에 Number로 변경된다.
- `<T>` 처럼 바운드가 없으면 그냥 `Object`로 변경된다. 

### 바운드란?
Generic에서 T 같은 타입 파라미터가 어떤 타입을 쓸 수 있는지 제한하는 규칙
<br>즉, 바운드가 없으면 T는 아무 타입이나 들어올 수 있지만, 바운드를 걸면 특정 계층 안에서만 허용된다.

- 상위 바운드
  - T가 반드시 특정 타입이거나 그 하위 타입만 오도록 제한하는 것
  - 문법 : `<T extends SomeType>`
  ```java
    class Box<T extends Number> {
        T value;
    }
  ```
- 하위 바운드
  - 와읻드카드와 같이 사용됨 즉, T 같은 파라미터를 쓰지 않고 `? super Type` 형태로만 사용함
  - Type 타입이거나 그 상위 타입만 허용한다는 뜻
  ```java
    public void addNumber(List<? super Integer> list) {
        list.add(123);
    }
  ```


### 의희

   


