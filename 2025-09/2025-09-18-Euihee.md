# Garbage Collection (GC) 기본 정리

## GC란?
- **GC (Garbage Collector)** 는 런타임 환경에서 애플리케이션이 생성한 객체들의 참조가 끝나면 감지 후 회수하여 재사용하는 **자동 메모리 관리 기능**.
- 저수준 언어(C, C++, Rust 등)는 개발자가 직접 메모리 해제를 해야 하지만,  
  고수준 언어(Java, Python, JavaScript, C# 등)는 각자의 GC 알고리즘을 통해 자동으로 관리.
- 자바는 **JVM의 구현체** 중 하나인 **Oracle HotSpot VM** 에서 GC를 지원.
- 동작 시 애플리케이션 스레드를 모두 중단하고 GC 스레드만 동작 → 참조 해제 후 다시 원복.  
  이 과정에서 애플리케이션은 **일시 정지(STW, Stop-The-World)** 를 경험함.

---

## STW (Stop-The-World)
- **STW**: GC 수행 중 애플리케이션이 멈추는 시간.
- GC의 규모, 종류(minor / major / full)에 따라 지연 시간이 달라짐.
- GC 알고리즘 및 튜닝의 핵심 목표 = **STW 시간을 최소화** 하는 것.

---

## GC 해제 기준

### 1. 영역 기준
- **GC 대상 영역**은 JVM 메모리 중 **Heap 영역**.
- Heap은 런타임 시 애플리케이션이 생성한 객체가 올라가며, 스레드 간 공유 참조가 발생하기 때문.

### 2. 객체 생사 기준
- **GC Root** 에서 도달 가능한 객체만 "살아있는 객체"로 판단.
- GC Root 예시:
    - Stack frame (메서드 지역 변수)
    - static 필드
    - JNI 참조 등

### 3. GC 종류 기준
- **Young Generation (단명 객체)** → **Minor GC** 대상
    - Eden / Survivor 영역에 위치한 단명 객체 정리
- **Old Generation (장수 객체)** → **Major GC** 대상
    - 오랫동안 참조 유지되는 객체 (예: 전역 변수, clear되지 않은 list 등)
- **Full GC** → Heap + Metaspace 전 영역 검사
    - 가장 무겁고 STW 시간이 김

---

## Minor GC
- 대상: `new` 로 생성한 DTO, 임시 문자열, stream 중간 객체 등
- 최적화 포인트:
    - 불필요한 객체 생성 금지
    - stream 과도한 남발 자제
    - 반복문 내 임시 문자열 연산 지양
    - **primitive 타입 활용**
    - `String` 연결 시 `StringBuilder` 사용

---

## Major GC
- 대상: 단명 객체 중 오래 살아남은 것 + 참조가 많이 걸린 객체
- 예시: 전역 변수, 전역 필드에 남은 List/Map
- 최적화 포인트:
    - 꼭 필요한 경우에만 전역 변수/필드 선언
    - 전역 컬렉션 사용 최소화
    - 캐시를 사용할 경우 적절한 정책 적용 (Guava, Caffeine, Redis)

---

## GC 관련 실무 팁
- IntelliJ 등에서 "메모리 부족" 메시지가 뜰 경우:
    - GC가 돌아도 공간 확보 불가 → **Heap 사이즈 확장** 필요
    - 근본적으로는 메모리 관리 개선 필요

### 개선 방법
1. **불필요한 참조 끊기**
    - `list.clear()`, `map.remove()`, `ThreadLocal.remove()`
2. **대용량 데이터 처리**
    - 스트리밍, 청크 단위 처리
3. **전역 컬렉션/캐시 남용 금지**
    - Guava, Caffeine, Redis 같은 캐시 솔루션 활용
4. **적절한 GC 알고리즘 선택**
    - G1, ZGC, Shenandoah 등
5. **메모리 Leak 탐지**
    - IntelliJ Profiler, JVisualVM, DataDog

---
