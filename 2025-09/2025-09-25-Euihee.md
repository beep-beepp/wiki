# @Transactional 내부 동작 정리

## 1. Transaction과 @Transactional

### 개념
- **트랜잭션(Transaction)**: 데이터베이스에서 수행되는 작업의 **논리적 단위**.
- **Spring의 `@Transactional`**: 단순한 어노테이션이 아니라  
  **AOP 기반 프록시 + 트랜잭션 매니저**가 결합된 구조로 동작한다.

---

## 2. @Transactional 동작 원리

### 전체 흐름

1. **프록시 생성**
    - Spring은 `@Transactional`이 붙은 클래스에 대해 **프록시 빈**을 생성한다.
2. **트랜잭션 시작**
    - 프록시가 호출되면 `TransactionInterceptor`가 트랜잭션 매니저를 통해 트랜잭션을 시작한다.
3. **비즈니스 로직 실행**
    - 실제 대상(Target) 메서드 실행.
4. **커밋 / 롤백 결정**
    - 정상 완료 → Commit
    - 예외 발생 → Rollback
5. **결과 반환**
    - 프록시가 결과를 클라이언트에 반환.

### 핵심 구성 요소

| 구성요소 | 역할 |
|----------|------|
| `TransactionInterceptor` | 트랜잭션 시작/커밋/롤백을 담당하는 AOP Advice |
| `PlatformTransactionManager` | 실제 DB 트랜잭션 관리 (`DataSourceTransactionManager`, `JpaTransactionManager` 등) |
| `TransactionSynchronizationManager` | 스레드 단위로 트랜잭션 리소스를 바인딩(ThreadLocal 기반) |
| `Target Service` | 실제 비즈니스 로직 클래스 |

---

## 3. 프록시 생성 방식

### 3.1 JDK Dynamic Proxy
- **조건**: 인터페이스가 존재할 때 기본적으로 사용.
- **특징**
    - `java.lang.reflect.Proxy` 사용
    - **인터페이스 메서드만 프록시 가능**
    - 내부 메서드 호출 시 프록시 미적용 → 트랜잭션 동작하지 않음

### 3.2 CGLIB (Code Generation Library)
- **조건**: 인터페이스가 없거나 `@EnableAspectJAutoProxy(proxyTargetClass = true)` 설정 시 사용.
- **특징**
    - 클래스 상속 기반으로 프록시 생성
    - `final` 클래스/메서드는 상속 불가 → 적용 불가

### 3.3 선택 우선순위

| 상황 | 사용 프록시 |
|------|--------------|
| 인터페이스 있음 | JDK Dynamic Proxy |
| 인터페이스 없음 | CGLIB Proxy |
| `proxyTargetClass=true` 설정 | 인터페이스 있어도 CGLIB 사용 |

> ⚠️ 프록시 방식은 **컨테이너 전역 정책**이며, Bean 단위로 `@Transactional(proxyTargetClass=true)` 같은 강제 지정은 불가능하다.

---

## 4. 프록시와 트랜잭션 적용 범위

| 케이스 | 트랜잭션 적용 여부 | 설명 |
|--------|-------------------|------|
| **자기 자신 내부 호출** | ❌ | 프록시를 거치지 않음 |
| **`private` / `final` 메서드** | ❌ | 오버라이드 불가 |
| **비동기 메서드(`@Async`)** | ❌ | 다른 스레드에서 실행되므로 전파 안 됨 |
| **스케줄러(`@Scheduled`)** | ✅ | 스프링이 프록시로 실행하므로 가능 (단, 내부 self-invocation은 여전히 안 됨) |

---

## 5. 프록시와 호출 구조별 트랜잭션 생성 여부

| 호출 구조 | 트랜잭션 동작 여부 | 설명 |
|------------|------------------|------|
| Controller → `인터페이스 기반 서비스(@Transactional)` | ✅ | 프록시를 통해 트랜잭션 생성 |
| Controller → `인터페이스 없는 클래스(@Transactional)` | ❌ | CGLIB이 없으면 트랜잭션 미적용 |
| 내부 메서드 self-call (`this.methodB()`) | ❌ | 프록시 미통과로 트랜잭션 미적용 |
| Controller → A → B (`A` 비트랜잭션, `B`에 @Transactional) | ✅ | `B` 호출 시점에 새로운 트랜잭션 생성 |

---

## 6. Checked Exception 롤백 여부

- **기본 규칙**
    - `RuntimeException`, `Error` → 자동 롤백
    - `Checked Exception` → 기본적으로 **롤백되지 않음**
    - 단, `@Transactional(rollbackFor = Exception.class)` 명시 시 롤백 가능

- **왜 SQLException이 롤백되는가?**
    - `SQLException`은 Checked Exception이지만,
    - JDBC 드라이버가 내부적으로 `Connection`을 rollback-only 상태로 변경하기 때문.
    - 따라서 커밋 시도 시 `rollback-only` 감지 → 자동 롤백 수행됨.

---
## 7. Spring vs Jakarta @Transactional

| 항목 | Spring `@Transactional` | Jakarta `@Transactional` |
|------|--------------------------|---------------------------|
| **트랜잭션 매니저** | `PlatformTransactionManager` (Spring 전용) | `UserTransaction` / `TransactionManager` (JTA 표준) |
| **AOP 기반** | ✅ Spring AOP (Proxy 기반) | ❌ JTA 표준 (Interceptor 직접 구성 필요) |
| **컨트롤러/서비스 계층** | ✅ 동작 (Spring이 직접 관리) | ✅ 동작 (Spring이 파싱해줌) |
| **내부 self-invocation** | ❌ 프록시 경계 밖이므로 미적용 | ❌ 동일 (AOP 구조 한계 동일) |
| **스케줄러(`@Scheduled`)** | ✅ 프록시 체인 내 실행 시 트랜잭션 가능 | ❌ Spring이 JTA Interceptor를 자동 연결하지 않음 |
| **비동기(`@Async`)** | ❌ 별도 스레드로 트랜잭션 전파 불가 | ❌ 동일 (ThreadLocal 기반 한계) |
| **Checked Exception 롤백** | 기본적으로 롤백 안 됨, `rollbackFor` 지정 가능 | `rollbackOn`, `dontRollbackOn` 속성 사용 가능 |
| **주요 사용처** | Spring Boot 환경 (JPA, DataSource, Hibernate 등) | EE 환경 (JTA 서버, EJB, Quarkus, Micronaut 등) |
| **결론** | ✅ Spring Proxy 체인 내에서 안정적인 트랜잭션 관리 가능 | ⚠️ Spring 환경에서는 스케줄러/비동기 자동 트랜잭션 적용 불가 |

---

## 8. 착각이 생기는 대표 케이스

| 상황 | 실제 동작 | 오해 |
|------|------------|------|
| Controller → `인터페이스 없는 @Service` | 트랜잭션 미적용, Hibernate는 autoCommit으로 수행 | “동작하니까 트랜잭션도 됐다” |
| 내부 self-invocation (`this.methodB()`) | 프록시 미적용, 트랜잭션 미작동 | “같은 클래스니까 된다” |
| Checked Exception | rollback 미적용 | “예외났는데 왜 롤백 안 됨?” |

---

## 9. 요약

1. `@Transactional`은 단순 어노테이션이 아니라 **AOP 프록시 + 트랜잭션 매니저 결합체**
2. **프록시를 반드시 거쳐야 트랜잭션이 적용됨**
3. **self-invocation, private/final 메서드, 비동기 스레드**에서는 트랜잭션이 적용되지 않음
4. **Spring vs Jakarta** 모두 프록시 방식은 동일하며 self-invocation 문제 해결 불가
5. **JDBC 드라이버가 rollback-only 상태로 변경 시 Checked Exception도 실질적으로 롤백됨**
