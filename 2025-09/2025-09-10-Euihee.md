### 한의희
아파서 늦참.
할려고 했던거 발표안했으니까 최대한 이쁘게 적어봄


# Java Memory Model (JMM)

### 1. 개념
- JMM은 멀티스레드에서 **원자성(Atomicity), 가시성(Visibility), 순서성(Ordering)**을 정의한 **추상적 명세**이다.
- JMM을 구체적으로 보장하기 위해 **8가지 규칙**이 있으며, 이것을 **happens-before 추상 규칙**이라고 한다.
- happens-before 관계를 실제 코드에서 구현하는 키워드들이 `synchronized`, `volatile` 등이다.
- 이 규칙이 JVM 내부에서 동작하기 때문에 우리가 별다른 순서를 지정하지 않아도 **정상 동작**한다.

---

### 2. 알아야 하는 키워드
- **volatile**
  - 가시성만 보장
  - 순서성은 일부 보장
  - 원자성은 보장하지 않음

- **synchronized**
  - 가시성, 원자성, 순서성을 **전부 보장**

- **Atomic~ (AtomicInteger 등)**
  - 가시성과 원자성 보장
  - 순서성은 일부만 보장

---

### 3. 개발할 때, 언제 씀?
- volatile은 가시성이 필요한 상태 플래그 변수(스레드 종료, 배치 중단 등)에 자주 쓰인다.
   ```jsx
     class VolatileExample {
        private volatile boolean running = true; // 상태 플래그
    
        public void run() {
            while (running) {
                // do something
            }
        }
    
        public void stop() {
            running = false; // 다른 스레드에서 즉시 반영됨
        }
    }   
  ```
- synchronized는 공유 자원에 동시에 접근하지 못하게 객체 단위로 모니터 락을 걸어,
  은행 출금처럼 반드시 하나의 스레드만 안전하게 실행해야 하는 임계 구역을 보호할 때 사용한다.

   ```jsx
   class BankAccount {
    private int balance = 1000;

    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount; // 원자적 보장
        }
    }

    public synchronized int getBalance() {
        return balance; // 가시성 + 순서성 보장
    }
}
  ```
- Atomic~ 클래스는 내부적으로 volatile 변수와 CAS(Compare-And-Swap) 알고리즘을 사용하기 때문에,
  lock 없이도 가시성과 원자성이 필요한 복합 연산을 안전하게 수행할 수 있다.
```jsx
import java.util.concurrent.atomic.AtomicInteger;

class AtomicExample {
  private AtomicInteger counter = new AtomicInteger(0);

  public void increment() {
    counter.incrementAndGet(); // 원자적 증가
  }

  public int get() {
    return counter.get(); // volatile 기반 가시성 보장
  }
}

  ```

### 4. 헷갈리지 말기
- JMM 보장은 하나의 JVM 안에서만 동작한다.
- 즉, **멀티 서버** 환경에서는 JMM만으로 동시성을 제어할 수 없다. 
   
