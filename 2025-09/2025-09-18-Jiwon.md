### 지원
# Generic
**클래스나  메서드를 정의할 때 타입을 일반화해서 작성할 수 있게 해주는 기능이다.**
<br>예를 들어 `List<String>`을 선언하면 컴파일러가 문자열만 추가되도록 보장해 런타임 오류를 예방할 수 있다.

## 왜 나왔을까?
Generic이 없던 시절에는 List 같은 컬렉션이 모든 요소를 Object로 다뤘다.
<br>따라서 값을 꺼낼 때마다 개발자가 직접 원하는 타입으로 캐스팅해야 했고, 잘못된 타입을 넣어도 컴파일 단계에서는 잡히지 않고 런타임에서 ClassCastException이 발생했다.

Generic을 쓰면 List<String>처럼 컴파일러가 타입을 강제하기 때문에, add(123) 같은 잘못된 값의 삽입은 컴파일 에러로 걸러진다.
<br>그리고 값을 꺼낼 때도 이미 타입이 보장되어 있으므로 별도의 형변환이 필요 없다.
<br>결국 불필요한 캐스팅이 줄고, 런타임 오류가 컴파일 오류로 당겨져 안정성이 높아졌다.

## 특징

- 이점
    - 컴파일 타임에 타입을 검사하기 때문에 타입 안정성을 높일 수 있고, 런타임 오류를 방지해준다.
    - 타입을 일반화해 여러 타입에서 동일한 코드를 재사용 할 수 있게 해준다.
    - 코드가 명확해져 가독성도 향상된다.



- 제약
    - 제네릭은 타입 소거법(Type Eraser)으로 동작하기 때문에 런타임에는 제네릭 타입 정보가 사라진다.
    - 그래서 `new T()` 같은 객체 생성이나 primitive type을 직접 사용할 수 없다.


### `new T()` 같은 객체 생성이나 primitive type을 직접 사용할 수 없다. 왜?
- `new T()` 불가
    - 타입 소거법으로 동작해, 컴파일 이후 타입 매개변수 T는 상위 바운드 타입(없으면 Object)으로 치환된다.
    - 그러나 `new T()`를 작성하면, 컴파일러는 런타임에 어떤 구체 타입의 생성자를 호출해야 하는지 알 수 없다.
    - 단순히 `new Object()`로 치환하면 Generic이 의도한 타입 안정성 보장이 깨져버리기 때문에 아예 금지되어 있다.
- primitive type 불가
    - 타입 소거 후 Object로 치환되는데, primitive type은 Object의 서브타입이 아니다.

## 타입 소거법(Type Eraser) 과 와일드 카드
Generic은 타입 소거법 기반으로 동작한다.
<br>즉, 컴파일 시점에는 타입 정보를 이용해 타입 안정성을 보장하지만, 바이트코드로 변환할 때는 타입 정보가 제거되고 상위 바운드 타입으로 치환된다.
<br>예를 들어 `List<String>`과 `List<Integer>`은 런타임에 모두 같은 `List`로 동작한다.

### 와일드 카드
와일드 카드에는 `? extends`와 `? super`이 있다.
- `? extends T`
    - 상한 제한으로, T나 그 하위 타입을 받을 수 있다.
    - 읽기 전용에 적합하다.
    - ex. `List<? extends Number>`는 `Integer`, `Double`을 읽을 수 있지만, 새 값을 안전하게 추가할 수는 없다.
  ```java
    List<? extends Number> list = new ArrayList<Integer>();
    // Number 또는 그 하위 타입을 담을 수 있고, 안전하게 읽을 수 있다.
    Number n = list.get(0); // O 읽기 가능
    // 하지만 정확히 어떤 하위 타입인지 모르기 때문에 새로운 값을 넣을 수는 없다.
    list.add(123); // X 컴파일 에러
  ```
- `? super T`
    - 하한 제한으로, `T`나 그 상위 타입을 받을 수 있다.
    - 쓰기 전용에 적합하다.
    - ex. `List<? super Integer>`에는 `Integer` 또는 그 상위 타입은 추가할 수 있지만, 꺼낼 때는 Object오만 안전하게 다룰 수 있다.
  ```java
    List<? super Integer> list = new ArrayList<Number>();
    // Integer 또는 그 상위 타입을 담을 수 있고, 안전하게 Integer를 추가할 수 있다.
    list.add(123); // Integer 추가 가능
    // 하자만 꺼낼 때는 구체적인 타입을 알 수 없으므로 Object로만 읽을 수 있다.
    Object obj = list.get(0); // 읽을 순 있지만 타입은 Object
  ```

### 상위 바운드 타입으로 치환된다?
컴파일이 끝나면 T 같은 타입 파라미터는 사라지고 대신 상위 바운드 타입(없으면 Object)으로 치환된다.
- ex. `<T extends Number>` 라면 `T`는 런타임에 Number로 변경된다.
- `<T>` 처럼 바운드가 없으면 그냥 `Object`로 변경된다.

### 바운드란?
Generic에서 T 같은 타입 파라미터가 어떤 타입을 쓸 수 있는지 제한하는 규칙
<br>즉, 바운드가 없으면 T는 아무 타입이나 들어올 수 있지만, 바운드를 걸면 특정 계층 안에서만 허용된다.

- 상위 바운드
    - T가 반드시 특정 타입이거나 그 하위 타입만 오도록 제한하는 것
    - 문법 : `<T extends SomeType>`
  ```java
    class Box<T extends Number> {
        T value;
    }
  ```
- 하위 바운드
    - 와읻드카드와 같이 사용됨 즉, T 같은 파라미터를 쓰지 않고 `? super Type` 형태로만 사용함
    - Type 타입이거나 그 상위 타입만 허용한다는 뜻
  ```java
    public void addNumber(List<? super Integer> list) {
        list.add(123);
    }
  ```
