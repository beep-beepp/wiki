### 석희
어디서 들어봤지만  애매하게 알고있는 내용들 정리

## 다형성(Polymorphism)
- 하나의 인터페이스나 부모 클래스 타입으로 여러 다른 구현체들을 동일하게 다룰 수 있는 능력

### 장점
1. **확장성**: 새로운 결제 방식 추가 시 기존 코드 수정 없이 새 구현체만 추가하면 됨
2. **유지보수성**: 각 결제 방식의 로직이 분리되어 있어 수정이 용이
3. **테스트 용이성**: Mock 객체로 쉽게 테스트 가능

### 주의사항
1. **런타임 에러 가능성**: 컴파일 타임에 잡히지 않는 오류가 런타임에 발생할 수 있음
2. **성능 오버헤드**: 가상 메서드 테이블 참조로 인한 미세한 성능 저하
   ## 가상 메서드 테이블(Virtual Method Table, VMT)
    - 가상 메서드 테이블은 **다형성을 구현하기 위해 JVM이 런타임에 어떤 메서드를 호출할지 결정하는 메커니즘**.
   ### 동작 방식

      ```jsx
      PaymentService service = new KakaoPaymentService(); *// 실제 객체는 KakaoPaymentService*
      service.process(request); *// 어떤 process() 메서드를 호출할까?*
      ```

    1. **컴파일 타임**: `PaymentService.process()` 호출이라고만 결정
    2. **런타임**: 실제 객체(KakaoPaymentService)의 VMT를 참조해서 `KakaoPaymentService.process()` 호출

   ### 성능 오버헤드가 발생하는 이유

      ```jsx
      *// 직접 호출 (빠름)*
      KakaoPaymentService service = new KakaoPaymentService();
      service.process(request); *// 바로 KakaoPaymentService.process() 호출// 다형성 호출 (약간 느림)*  
      
      PaymentService service = new KakaoPaymentService();
      service.process(request); *// VMT 참조 -> 실제 메서드 찾기 -> 호출*
      ```

   **하지만 실무에서는 이 성능 차이는 거의 무시할 수 있는 수준.**
3. **복잡성 증가**: 상속 구조가 깊어질수록 이해하기 어려워짐

## SOLID
### Single Responsibility Principle (단일 책임 원칙)
- **개념**: 한 클래스는 하나의 책임만 가져야 한다.
### Open/Closed Principle (개방-폐쇄 원칙)
- **개념**: 확장에는 열려있고 수정에는 닫혀있어야 한다.
### Liskov Substitution Principle (리스코프 치환 원칙)
- **개념**: 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체해도 프로그램의 동작이 변하지 않아야 한다.
  즉 부모 클래스로 작성된 코드가 자식 클래스 객체로도 정상 동작해야 함.
### Interface Segregation Principle (인터페이스 분리 원칙)
- **개념**: 클라이언트는 사용하지 않는 메서드에 의존하면 안 된다.
### Dependency Inversion Principle (의존성 역전 원칙)
- **개념**:
1. 상위 모듈은 하위 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다.
2. 추상화는 구체화에 의존해서는 안 되며, 구체화는 추상화에 의존해야 한다.
   **→ 변경에 대한 안정성** 때문

### Spring Boot에서 SOLID 적용 시 장점

1. **테스트 용이성**: Mock 객체로 쉽게 단위 테스트 가능
2. **확장성**: 새로운 기능 추가 시 기존 코드 수정 최소화
3. **유지보수성**: 각 클래스의 책임이 명확해 디버깅과 수정이 용이
4. **Spring의 DI 컨테이너와 완벽 호환**: @Autowired, @Service 등과 자연스럽게 연동

### 실무에 적용시 가이드라인

1. **소프트웨어 개발 3원칙 준수**
   ### **KISS (Keep It Simple, Stupid)**

    - **의미**: 코드는 **단순하고 이해하기 쉽게 작성**해야 함.
    - **목표**: 불필요한 복잡성을 제거하여 코드의 **가독성, 유지보수성**을 높이는 것.
    - **이유**: 복잡한 코드는 버그를 유발하기 쉽고, 유지보수가 어렵다.

   ### **YAGNI (You Aren't Gonna Need It)**

    - **의미**: 지금 당장 필요하지 않은 기능은 **구현하지 말라**는 원칙.
    - **목표**: 불필요한 기능 추가를 방지하고 개발 **시간과 비용**을 절약하는 것.
    - **이유**: "나중에 필요할 수도 있다"라는 이유로 기능을 미리 추가하면 대부분 필요하지 않고 코드만 복잡해짐.

   ### **DRY (Don't Repeat Yourself)**

    - **의미**: **중복된 코드를 작성하지 말고 재사용 가능하도록 만들라**는 원칙.
    - **목표**: 중복을 제거해 코드의 **유지보수성**과 **일관성**을 높이는 것.
    - **이유**: 같은 코드를 여러 번 작성하면 수정할 때 모든 부분을 변경해야 하기 때문에 오류 발생 가능성이 높아짐.
2. 도메인간 응집도를 파악하여 적당히 트레이드 오프
3. **Rule of Three**: 같은 코드가 3번 반복되면 추상화 고려
4. **팀의 이해도**: 팀 전체가 이해할 수 있는 수준에서 추상화
5. **비즈니스 가치 우선**: 추상화보다 기능 구현이 더 중요할 때가 많음
6. **점진적 개선**: 처음부터 완벽하게 하려 하지 말고 필요에 따라 개선

## 느낀점
취업 준비 시절에는 SOLID 같은 개발 원칙들을 절대적인 진리처럼 여겼다.
'이 원칙들을 완벽하게 지켜야만 좋은 코드를 작성할 수 있다'는 강박이 있었고,
이를 어기는 것은 곧 좋은 개발자가 될 수 없다고 생각했다.

하지만 실무에 투입되어 실제 프로젝트를 진행하면서 생각이 완전히 바뀌었다. 원칙을 적용하다 보니 오히려 역효과가 발생하는 경우를 자주 목격했다. 당장 필요하지도 않은 확장성을 위해 불필요한 인터페이스를 만들고, 단순한 로직을 여러 클래스로 분산시켜 코드 추적을 어렵게 만드는 일이 반복됐다. 결과적으로 가독성은 떨어지고 복잡도만 높아진 프로젝트가 되어버렸었다.

지금은 실무 경험을 통해 균형감을 찾아가고 있다. 프로젝트 일정과 현실적 제약, 기존 코드베이스의 구조 등을 종합적으로 고려한다. 중복 코드가 있더라도 당장 큰 문제가 되지 않고, 향후 확장 계획이 불분명하다면 굳이 무리해서 추상화하지 않는다. 대신 기술 부채로 인식하고 적절한 시점에 리팩토링을 계획하게 되는 것 같다.

결국 좋은 코드란 원칙을 맹목적으로 따르는 것이 아니라, 상황에 맞는 적절한 트레이드오프를 찾는 것이라고 생각한다. 기능만 돌아가면 된다는 식의 무책임한 개발도 문제지만, 과도한 원칙주의 역시 프로젝트를 복잡하게 만들 수 있다는 것을 깨달았다.
