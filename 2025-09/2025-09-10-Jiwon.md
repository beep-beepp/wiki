### 지원

### JMM (Java Memory Model)

## 1. 왜 필요한가?

1. 자바는 멀티 스레드 프로그래밍을 많이 한다.
2. 하지만 실제로 CPU와 메모리 사이에는 캐시, 레지스터, 최적화가 존재해서 스레드마다 다른 값을 볼 수 있다.
3. 그래서 스레드간 consistency 를 보장하는 규칙이 필요하다. 이것이 JMM이다.

## 2. 주요 개념

1. visibility
   - 한 스레드가 변경한 값이 다른 스레드에서 보이는 성질
   - ex. 캐시에만 쓰고 메모리에 반영하지 않으면 다른 스레드에서 변경한 값을 못 본다.
2. atomicity
   - 연산이 쪼개지지 않고 한 번에 실행되는 성질
   - ex. count++는 내부적으로 읽기-더하기-쓰기 3단계라 원자성이 보장되지 않는다.
3. ordering
   - 컴파일러나 CPU가 최적화를 위해 코드 순서를 바꿔도, 프로그램의 의미가 깨지지 않게 보장하는 성질
   - ex. flag = true; data = 1; 이 실제 실행에서는 순서가 바뀔 수 있다.

## 3. 주요 키워드

1. volatile
   - 해당 변수는 항상 메모리에서 읽고 쓴다.
   - 가시성 + 순서성 보장
   - 하지만 i++ 같은 복합 연산의 원자성은 보장하지 않는다.
   - 순서성이 보장된다는 뜻이 정확히 뭘까?
    - JMM에서 volatile 변수애 대한 읽기/쓰기 앞뒤 명령어 재배치를 금지한다.
    - volatile write 앞에 있는 모든 연산은 실제로도 먼저 실행되로 flush된 다음 volatile 쓰기가 일어난다.
    - volatile read 뒤에 있는 모든 연산은 실제로도 그 이후에 실행된다.
    - 즉, volatile이 메모리 장벽 역할을 해서 코드 순서를 의도한대로 유지시켜준다.
2. synchronized, Lock
   - 임계영역을 한 번에 한 스레드만 실행할 수 있다.
   - 락 해제시 메모리에 즉시 반영하고, 다른 스레드가 락 획득시 최신 값을 읽는다.
   - 가시성, 원자성, 순서성 모두 보장한다.
3. happens-before
   - "한 작업의 결과가 다른 작업에서 반드시 보인다."는 순서보장 관계를 말한다.
   - A happens-before B : A가 끝난 후에 모든 결과가 B에서 반드시 관측된다.
   - 두 작업의 실행 순서를 보장하는 JMM의 핵심 규칙
    - ex. 같은 스레드 안의 코드 순서 -> happens-before
    - unlock -> 그 다음 lock은 happens-before
    - volatile write -> 그 다음 read는 happens-before

## 4. 예시

```jsx
   class Example {
     private volatile boolean ready = false;
     private int data = 0;
     
     public void writer() {
       data = 42;
       ready = true;
     }
     
     public void reader() {
       if (ready) {
         System.out.println(data);
       }
     }
   }
```

## 5. 정리

JMM이란 멀티 스레드 환경에서 스레드가 메모리를 어떻게 읽고 쓰는지 정의하는 규칙으로,
Visibility, Atomicity, Ordering 을 보장하기 위해 volatile, synchronized, happens-before 관계를 제공한다.
