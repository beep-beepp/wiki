# GC

GC는 가비지 컬렉션의 약자이다.

자바에서 더 이상 사용하지 않는 객체들을 자동으로 메모리에서 해제하는 기능이다.

# GC가 왜 필요한가?

자바는 C/C++ 같은 언어처럼 개발자가 malloc이나 free로 메모리를 직접 관리하지 않는다.

대신 JVM이 GC를 통해 메모리를 자동으로 관리해준다.

개발자가 메모리를 관리하면 어떤 이슈가 있나?

**직접 메모리 관리는 그 자체로 강력하지만 개발자가 실수할 가능성이 높아지고 유지보수가 어렵게 된다.**

1. Memory leak - 할당하고 해제하지 않은 채로 있으면 메모리가 계속 쌓여 프로그램이 죽을 수도 있음
2. double free - free한 메모리를 또 free하면 프로그램이 비정상 종료됨
3. dangling pointer(해제된 메모리 참조) - free한 메모리를 참조하면 정의되지 않은 동작이 발생함
4. buffer overflow - 할당한 크기를 넘어서 데이터를 쓰게 되면 인접한 메모리를 덮어쓰게됨(보안 취약점)

개발자가 메모리를 관리하게 되면 관리 포인트가 많아지고, 코드도 복잡하게 됨

# 어떤 방식으로 GC가 진행될까?

GC Root를 시작으로 참조 그래프를 따라가며 도달할 수 없는 객체를 찾아내고, 이를 사용하지 않는 객체로 간주해 메모리에서 제거함.

# GC 종류는?

1. Serial GC - 단일 스레드로 작동. 적은 메모리에 효율적
2. Parallel GC - 멀티스레드로 작동. throughput 높음
3. CMS GC - 응답 속도 빠름. 하지만 메모리 fragmentation 있음
4. G1 GC - 대규모 힙에 적합. Full GC를 줄이는데 강점
5. ZGC / Shenandoah - 초지연시간. 최신 JVM에서 사용됨

## Serial GC

모든 GC를 단일 스레드로 전체 힙을 처리하는 GC.

GC가 진행하는 동안 Stop-the-world가 발생한다.

### 장단점

장점

- 구현이 단순 - 디버깅이나 분석하기 좋음
- 낮은 오버헤드
    - 멀티스레드에 비해 컨텍스트 스위칭이나 동기화 비용이 없다.
    - 작은 힙(≤100MB)에선 오히려 더 효율적이다.
- 저사양 환경에 적합
    - 단일 코어, 메모리 제한이 있는 환경에서 가장 적합

단점

- 힙이 커질수록 Stop-the-world 시간이 김
    - GC가 작동하면 전체 애플리케이션이 멈춤.
    - 단일 스레드만 사용하므로 대용량 힙에서는 정지 시간이 길어져 응답성이 떨어짐멀
- 멀티코어 활용 불가 - 대부분의 시스템이 멀티코어인데, 1개 스레드만 사용하기 때문에 자원 활용도가 낮음
- Throughput 낮음 - 전체 처리량이 낮아서 대용량 서버나 고성능 시스템에 부적합
- 지연시간에 민감한 시스템엔 부적절
    - 짧은 응답시간을 요구하는 서버, 실시간 시스템에서는 Stop-the-world가 치명적이다.
- 스케일링 한계 - CPU 코어나 메모리를 늘려도 성능 개선 효과가 없다.

### 동작방식

Generational GC model을 사용함.

- Young Generation - Eden, 2개 Survivor
- Old Generation

### 1. Minor GC - Eden 영역이 가득차면 실행됨

단일 스레드로 실행되고, GC하는 동안 Stop-the-world 발생

1. 새 객체는 Eden에 할당됨
2. Eden이 가득차면 GC 발생
3. 살아남은 객체는 Survivor 영역으로 복사됨
4. Survivor 영역에서 여러번 살아남으면 Old 영역으로 승격됨

### 2. Major GC - Old 영역이 가득차면 실행됨

단일 스레드로 실행되고, GC하는 동안 Stop-the-world 발생

1. Mark - GC Root부터 참조 그래프를 따라가며 참조 가능한 객체 탐색
2. Sweep - 사용되지 않는 객체 제거
3. Compact - 메모리 단편화 방지를 위해 압축

   → Serial GC는 기본적으로 압축함


### 결론

SerialGC는 단일 스레드로 GC를 처리하는 기본적인 가비지 컬렉터로, 구조가 단순하고 작은 힙 환경에선 효율적이지만, Stop-the-world 시간이 길고 멀티코어를 활용하지 못해 대규모 어플리케이션엔 적합하지 않습니다.
