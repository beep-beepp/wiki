# GC
GC는 Garbage Collection의 약자로, Java같은 언어에서 더 이상 참조되지 않는 객체(Reachable하지 않은 객체)들을 자동으로 메모리에서 해제해주는 기능이다.

## GC는 왜 필요할까?
C/C++처럼 개발자가 malloc이나 free를 사용해 직접 메모리를 관리할 수도 있다.
<br>직접 메모리를 관리하는건 유용하지만 위험하다. 개발자가 실수할 가능성이 증가하기 때문이다. 
<br>GC는 개발자의 실수 가능성을 줄이고 유지보수를 더 쉽게 만들어준다.
<br>성능이 극도로 중요한 경우 (OS, 임베디드, 게임 엔진 등) 여전히 메모리를 수동적으로 관리해주지만, 대부분의 애플리케이션은 GC 언어로도 충분히 안전하게 개발된다.

### 직접 메모리를 관리할 경우 대표적인 문제점
1. Memory Leak
    - 메모리를 할당은 했는데 해제하지 않으면 계속 메모리를 차지한다.
    - 장기적으로 실행하는 프로세스에서는 점점 메모리가 쌓여서 시스템이 죽을 수도 있다.
    ```java
    char* ptr = malloc(100);
    // 사용하고 free 안함 -> Memory Leak 발생
    ```
2. Double Free
   - 이미 해제한 메모리를 또 해제하면 프로그램이 비정상 종료된다.
   ```java
   char* ptr = malloc(10);
   free(ptr);
   free(ptr); // 이중 해제
   ```
3. Dangling Pointer
   - 해제한 메모리를 참조하면 정의되지 않은 동작(UB, crash, 보안 취약점 등)이 발생한다.
   ```java
   char* ptr = malloc(10);
   free(ptr);
   ptr[0] = 'A'; // 해제된 영역에 접근
   ```
4. Buffer Overflow
   - 할당할 크기를 넘어서 데이터를 쓰게되면, 인접 메모리를 덮어쓰게 된다.
   - 보안 공격(ex. Stack Overflow의 원인)이 여기서 발생한다.
   ```java
   char* str = malloc(4);
   strcpy(str, "Overflow!"); // 할당된 4바이트 초과
   ```
5. 복잡도 증가
   - 누가 언제 free해야 하는가?를 관리하기 어렵다.
   - 함수 간 데이터 이동, 에러 발생 시 예외 흐름까지 전부 고려해서 메모리를 적절히 해제해야 한다. -> 코드가 굉장히 복잡해진다.

## GC는 어떻게 동작할까?
1. 루트 객체(GC Root)부터 시작해서
2. 참조 그래프를 따라가며
3. 도달할 수 없는 객체들을 "사용하지 않는 객체"로 간주하고
4. 그 객체들을 메모리에서 제거한다.
즉, GC Root부터 출발해서, 참조하는 객체들만 따라가서 살려두고, 나머지는 전부 "더 이상 사용하지 않는 것"이라고 판단해 제거해버리는 것

## GC 종류
Java에서 사용하는 대표적인 GC 알고리즘

| 종류               | 특징                                    |
|------------------|---------------------------------------|
| Serial GC        | 단일 스레드로 작동. 적은 메모리에서 효율적.             |
| Parallel GC      | 멀티 스레드로 작동. Throughput이 높음.           |
| CMS GC           | 애플리케이션과 동시에 작동. 하지만 Fragmentation 있음. |
| G1 GC            | 대규모 힙에 적합. Full GC를 줄이는데 강점.          |
| ZGC / Shenandoah | Ultra Low Pause. 최신 JVM에서 사용됨.        |

### 각 GC의 적용과정

| Java 버전 | Default GC  | 추가된 GC                                   | 핵심 변화                                             |
|---------|-------------|------------------------------------------|---------------------------------------------------|
| 1~3     | Serial GC   | --                                       | 단일 스레드로 동작하는 전통적인 GC. 선택 옵션 없었음.                  |
| 4       | Serial GC   | Parallel GC, CMS GC                      | 처음으로 병렬 Young GC와 CMS가 실험적으로 추가됨.                 |
| 5       | Parallel GC | Parallel Old GC                          | 서버 환경에서 기본 GC가 Parallel로 변경됨. CMS는 여전히 선택 사항.     |
| 6       | Parallel GC | Parallel Old 기본                          | Parallel GC를 사용할 경우 Old 영역도 병렬로 동작하도록 기본 설정됨.     |
| 7       | Parallel GC | G1 GC (Experimental)                     | G1이 처음으로 공식 옵션으로 제공됨.                             |
| 8       | Parallel GC | G1 GC (안정화)                              | G1이 실서비스에 사용 가능한 수준으로 안정화됨.                       |
| 9       | G1 GC       | --                                       | G1이 Default GC로 변경됨.                              |
| 10      | G1 GC       | G1 Full GC 병렬화                           | G1의 Full GC가 병렬로 수행되도록 개선됨.                       |
| 11      | G1 GC       | ZGC(Experimental), Epsilon(Experimental) | 초저지연 ZGC와 No-Op GC(Epsilon) 추가.                   |
| 12      | G1 GC       | Shenandoah(Experimental)                 | Redhat 주도 저지연 GC Shenandoah 추가.                   |
| 13      | G1 GC       | ZGC 메모리 반환 기능                            | 사용하지 않는 메모리를 OS에 반납할 수 있도록 개선.                    |
| 14      | G1 GC       | ZGC macOS/Windows 지원                     | ZGC 지원 플랫폼이 Linux -> macOS/Windows로 확대.           |
| 15      | G1 GC       | ZGC, Shenandoah 정식화                      | 두 GC 모두 Experimental 상태에서 정식 Production 수준으로 승격됨. |
| 16      | G1 GC       | ZGC 내부 개선                                | 스택 병렬 처리 등 성능 최적화.                                |
| 17(LTS) | G1 GC       | --                                       | ZGC와 Shenandoah의 안정성, 성능 향상.                      |
| 18      | G1 GC       | --                                       | ZGC 병렬 참조 처리 최적화                                  |
| 19      | G1 GC       | Generational ZGC (Preview)               | ZGC에 Generation(Young/Old) 구분이 추가됨.               |
| 20      | G1 GC       | Generational ZGC 개선                      | 성능 및 안정성 보완.                                      |
| 21(LTS) | G1 GC       | Generational ZGC 정식화                     | ZGC의 세대별 버전이 정식으로 기본 기능으로 채택됨.                    |

# Serial GC
단일 스레드로 동작하고, 전체 힙을 STW 방식으로 정리하는 가장 기본적인 GC이다.

## 장단점

| 장점              | 설명                                          |
|-----------------|---------------------------------------------|
| 구현이 단순함         | 구조가 간단하고 동작이 예측이 가능함. 따라서 디버깅이나 GC 분석에 용이함. |
| 낮은 오버헤드         | 멀티스레드 컨텍스트 스위칭이 없어서 작은 힙 환경에서는 오히려 빠를 수 있음. |
| 작은 힙에 적합        | 약 100MB 이하 힙에서는 병렬 GC보다 효율적임.               |
| 임베디드/저사양 환경에 유리 | 단일 코어, 메모리 제약이 있는 환경에서 가장 안정적으로 동작함.        |
| 학습/실험용으로 적합     | 가장 단순한 구조이기 때문에 GC 동작 원리를 이해하거나 테스트할 때 적합함. |

| 단점                 | 설명                                                  |
|--------------------|-----------------------------------------------------|
| STW 시간이 김          | GC 중에는 모든 애플리케이션 스레드가 멈추므로, 애플리케이션 Pause time이 길어짐. |
| 멀티코어 활용 불가         | 항상 단일 스레드로 수행되어 CPU 코어를 병렬로 사용하지 못함.                |
| Throughput 낮음      | 병렬 처리가 불가능하므로 전체 처리량이 낮아 서버 환경에는 부적합함.              |
| 지연시간에 민감한 시스템엔 부적절 | Pause time이 길어 실시간 응답이 중요한 서비스에는 적합하지 않음.           |
| 확장성 한계             | CPU나 메모리 자원을 늘려도 성능이 거의 향상되지 않음.                    |

## 작동 방식
Serial GC은 Generational 구조를 사용한다.
<br>즉, 힙은 Young Generation(Eden + Survivor)와 Old Generation으로 구분된다.

```text
Java Heap
 ├── Young Generation
 │    ├── Eden
 │    └── Survivor (S0, S1)
 └── Old Generation
```

### 1. Young GC (Minor GC)
발생 조건 : Eden영역이 가득 찼을 때
<br>동작 : 전체 과정이 STW로 수행되며, Copying Collector 알고리즘을 사용한다.

동작 순서
1. 새 객체가 Eden 영역에 할당된다.
2. Eden이 가득차면 GC가 발생한다.
3. 살아남은 객체는 Survivor 영역으로 복사된다.
4. 여러번 살아남은 객체는 Old 영역으로 Tenuring된다.

### 2. Old GC
발생 조건 : Old 영역이 가득찼을 때
동작 : 전체 과정이 STW로 수행되며, Mark-Sweep-Compact 알고리즘을 사용한다.

동작 순서
1. GC Root에서 Reachable한 객체를 Marking한다. -> Mark
2. 참조되지 않는 객체를 제거한다. -> Sweep
3. 메모리 Fragmentation을 방지하기 위해 연속적으로 압축한다. -> Compact

### 항상 STW
- GC가 시작되면 모든 애플리케이션 스레드가 중단(STW)된다.
- GC 작업이 완료될 때까지 어떠한 애플리케이션 코드도 실행되지 않는다.
- Serial GC는 Parallel이나 Concurrent 단계가 전혀 없는 순차적으로 처리하는 GC이다.

## 결론
Serial GC는 가장 단순한 형태의 GC로, 단일 스레드로 수행하는 대신 구조가 명확하고 동작이 예측 가능하다.
<br>작은 힙, 단일 코어, 임베디드 환경에선 효율적이지만 STW 시간이 길고 멀티코어를 활용하지 못해 대규모 서버 애플리케이션에는 적합하지 않다.
